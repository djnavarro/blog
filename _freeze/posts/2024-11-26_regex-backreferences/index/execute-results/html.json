{
  "hash": "c28ff443dd6a491f660ec0286e8d8665",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Baby got backreferences\"\ndescription: \"Now I have \\\\\\\\2 problems\"\ndate: \"2024-11-26\"\nimage: \"feather2.jpg\"\n--- \n\n\n\n<!--------------- my typical setup ----------------->\n\n\n\n\n\n\n\n::: {.cell}\n<style type=\"text/css\">\n@import url('https://fonts.googleapis.com/css2?family=Tangerine:wght@400;700&display=swap');\n\n.tangerine-regular {\n  font-family: \"Tangerine\", cursive;\n  font-weight: 400;\n  font-style: normal;\n}\n\n.tangerine-bold {\n  font-family: \"Tangerine\", cursive;\n  font-weight: 700;\n  font-style: normal;\n}\n</style>\n:::\n\n\n\n<!--------------- post begins here ----------------->\n\nAt least once a week I have this moment when a yawning pit of black despair opens at my feet, and the barbed tentacles of despair wrap around my legs, poison injects chill into my veins, the icy claws of anxiety rip through my viscera, and a withered voice of pure evil slithers into my brain and speaks to me in the disturbingly-seductive language of Mordor:\n\n<p class=\"tangerine-bold\" align=\"center\" style=\"font-size: 28pt\">why not write a regular expression?</p>\n\nI try to resist. I'm a good girl, I tell the Dark Lord. I would never. Not on a first date anyway. Well, buy a girl a drink first maybe? And... oh it's so cold outside and, I mean, Sauron is kinda hot. Have you not watched Rings of Power? Sometimes a girl has needs.\n\nUm. Anyway. What was I talking about? Oh, right. [Regular expressions](https://www.regular-expressions.info/).\n\n<br>\n\n::: {layout-ncol=2}\n\n![Writing a regular expression](feather1.jpg)\n\n![When the regular expression encounters a string](feather2.jpg)\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr)\nlibrary(tibble)\nlibrary(brio)\n\nfeather <- read_lines(\"feather.txt\")\nfemininomenon <- read_lines(\"femininomenon.txt\")\nmidnight <- read_lines(\"midnight.txt\")\n```\n:::\n\n\n\n## Warning\n\nLet's start this descent into madness with a disclaimer: I have *never* wanted to write a primer on working with regular expressions in R. I loathe regular expressions, and I am not good at them. So why am I, a grotesquely unqualified woman, writing one anyway? Honestly, the answer is because __this post is the tutorial that I need__. I'm writing this as an act of kindness for future Danielle, who will find inevitably herself crying at her keyboard trying to make a basic regex work, and will need to remind herself of the basics. With that in mind, and knowing exactly who will be revisiting this post in six months time in tears... you got this girl. I believe in you. \n\n## Simple matches\n\nIt begins with the very, very basics. The simplest way to write a regular expression is to detect strings that match a specific, fixed subset of text. For instance, let's say I want to find every line in [Femininomenon](https://www.youtube.com/watch?v=xdaKBAuO8zg) in which Chappell Roan sings the word `\"femininomenon\"`. I'll use the `str_view()` function from the stringr package to do this. It's not the best tool for using in a script, but it's ideal as a way of looking at the results of a regular expression match:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(\n  string = femininomenon,   # the song lyrics\n  pattern = \"femininomenon\" # the regular expression\n)\n```\n\n<pre>[24] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[28] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[53] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[57] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[65] │ Well, what we really need is a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[66] │ (A what?) A <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[72] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[82] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[86] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[90] │ Make a bitch, it's a fem (It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>)\n</pre>\n:::\n\n\n\nIn this output, the teal-highlighted text^[At the R console, this highlighting appears automatically. Normally you wouldn't see this highlighting in a quarto document like this one, because quarto strips out the ANSI control characters that the console uses to add colour to the output. However, for the purposes of this post I cheated a little, by writing a [knitr hook](/posts/2023-12-30_knitr-hooks/) that crudely mimics the same behaviour in this document.] enclosed in angle brackets displays the sections of the text that match the regular expression. In this case our regular expression is very simple. It's just a literal string `\"femininomenon\"`, so the output highlights every instance of that word. \n\nNotice also that not every line in the song is shown by `str_view()`. Only those lines that match the regular expression are included (you can see that in the numbers to the left of each match). However, we can change this behaviour using the `match` argument to `str_view()`. For example, if wanted to see only those lines that don't include the letter `e`, we could do this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(\n  string = femininomenon,\n  pattern = \"e\", \n  match = FALSE\n)\n```\n\n<pre>[11] │ Why can't any man\n[12] │ \n[19] │ \n[20] │ [Chorus]\n[29] │ \n[40] │ Why can't any man\n[41] │ \n[48] │ \n[49] │ [Chorus]\n[58] │ \n[67] │ \n[77] │ \n[78] │ [Chorus]\n[87] │ \n[88] │ [Outro]\n</pre>\n:::\n\n\n\nAlternatively, we could set `match = NA`. If we do this, `str_view()` will return every line in the song, whether it matches or not. Here's an example. Let's search for every instance of the word `\"you\"`, and set `match = NA`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(\n  string = femininomenon,\n  pattern = \"you\",\n  match = NA\n)\n```\n\n<pre> [1] │ [Verse 1]\n [2] │ Same old story, time again\n [3] │ Got so close but then <span style='color:#008080'>&lt;you&gt;</span> lost it\n [4] │ Should've listened to <span style='color:#008080'>&lt;you&gt;</span>r friends\n [5] │ 'Bout his girlfriend back in Boston\n [6] │ You sent him pictures and playlists and phone sex\n [7] │ He disappeared from the second that <span style='color:#008080'>&lt;you&gt;</span> said\n [8] │ \"Let's get coffee, let's meet up\"\n [9] │ I'm so sick of online love\n[10] │ And I don't understand\n[11] │ Why can't any man\n[12] │ \n[13] │ [Pre-Chorus]\n[14] │ Hit it like, get it hot\n[15] │ Make a bitch, it's a fem\n[16] │ Hit it like, get it hot\n[17] │ Make a bitch, it's a—\n[18] │ Um, can <span style='color:#008080'>&lt;you&gt;</span> play a song with a fucking beat?\n[19] │ \n[20] │ [Chorus]\n... and 72 more\n</pre>\n:::\n\n\n\nThis output illustrates two things. First, you can see that there's a match on lines 3, 4, 7, 18, and probably others too (the remaining 72 lines of the song aren't shown in the output but they are actually included in the `str_view()` output). Second, it shows that our regular expression isn't quite doing the job we want it to: the match on line 4 matches the first three letters of the word \"your\", and it doesn't match to line 6 because that line contains the word \"You\" with an upper case \"Y\". If we want a regular expression to match \"you\" and \"You\" but not match against \"your\", it needs to be something a little more nuanced than setting `pattern = \"you\"` like I did above. \n\n## Quantifiers\n\nFor the moment, let's set aside the thorny question of how to handle capitalisation, and focus instead on the \"you\" vs \"your\" issue. Moreover, let's move the goalposts, and pretend that our new goal is actually to detect *both* `\"you\"` and `\"your\"`. We can do that with the help of **quantifiers**. In regular expression syntax, certain character (sometimes called \"metacharacters\") have special meanings. For example, the `?` character is used to indicate that the preceding character is optional. When we write `\"your?\"` as our regular expression, the `r?` part indicates that the `r` character is optional. It will match against both `\"you\"` and `\"your\"`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"your?\")\n```\n\n<pre> [3] │ Got so close but then <span style='color:#008080'>&lt;you&gt;</span> lost it\n [4] │ Should've listened to <span style='color:#008080'>&lt;your&gt;</span> friends\n [7] │ He disappeared from the second that <span style='color:#008080'>&lt;you&gt;</span> said\n[18] │ Um, can <span style='color:#008080'>&lt;you&gt;</span> play a song with a fucking beat?\n[33] │ Lying to <span style='color:#008080'>&lt;your&gt;</span> friends about\n[35] │ Stuck in the suburbs, <span style='color:#008080'>&lt;you&gt;</span>'re folding his laundry\n[36] │ Got what <span style='color:#008080'>&lt;you&gt;</span> wanted, so stop feeling sorry\n[47] │ Dude, can <span style='color:#008080'>&lt;you&gt;</span> play a song with a fucking beat?\n[60] │ Ladies, <span style='color:#008080'>&lt;you&gt;</span> know what I mean\n[61] │ And <span style='color:#008080'>&lt;you&gt;</span> know what <span style='color:#008080'>&lt;you&gt;</span> need\n[76] │ Did <span style='color:#008080'>&lt;you&gt;</span> hear me? Play the fucking beat\n</pre>\n:::\n\n\n\nHere you can see that it matches the `\"you\"` on line 3 and the `\"your\"` on line 4. However, on line 35 where it encounters the word `\"you're\"` it detects a match, but *only* to the `\"you\"` part of the word.  \n\nThere are several quantifiers supported by most regular expression flavours.^[There are a ghastly number of different regular expression flavours out there. They are very similar to each other, but have subtle differences. Somewhat frustratingly, there are *three* different regular expression flavours that are widely used in R (two in base R and one in tidyverse), and every now and then I find myself running into cases where they don't produce identical results. More on this later in the post.] Quantifiers always refer to the previous item, and specify the number of repetitions of the previous item that can be matched: \n\n- `?` matches the previous item zero or one time\n- `*` matches the previous item zero or more times\n- `+` matches the previous item one or more times\n- `{n}` matches the previous item exactly n times\n- `{n,}` matches the previous item n or more times\n- `{n,m}` matches the previous item at least n times but not more than m times\n\nThis behaviour is (of course!) described in numerous places in the R documentation, but I find it helps a lot to have a concrete example that shows the differences between each of these. In the table below, the rows correspond to the strings `\"a\"`, `\"ab\"`, `\"abb\"`, and so on. Each column corresponds to a a regular expression that is always `\"ab\"` with a quantifier applied to the letter `\"b\"`. In each cell of the table, I've used `str_view()` to show how each string matches (or doesn't match) against each of the regexes:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntibble(\n  string    = c(\"a\", \"ab\", \"abb\", \"abbb\", \"abbbb\", \"abbbbb\"),\n  `ab?`     = str_view(string, pattern = \"ab?\", match = NA),\n  `ab*`     = str_view(string, pattern = \"ab*\", match = NA),\n  `ab+`     = str_view(string, pattern = \"ab+\", match = NA),\n  `ab{2}`   = str_view(string, pattern = \"ab{2}\", match = NA),\n  `ab{2,}`  = str_view(string, pattern = \"ab{2,}\", match = NA),\n  `ab{2,4}` = str_view(string, pattern = \"ab{2,4}\", match = NA)\n)\n```\n\n<pre># A tibble: 6 × 7\n  string `ab?`      `ab*`      `ab+`      `ab{2}`    `ab{2,}`   `ab{2,4}` \n  <span style='color:#008080'>&lt;chr&gt;</span>  <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span>\n1 a      <span style='color:#008080'>&lt;a&gt;</span>        <span style='color:#008080'>&lt;a&gt;</span>        a          a          a          a         \n2 ab     <span style='color:#008080'>&lt;ab&gt;</span>       <span style='color:#008080'>&lt;ab&gt;</span>       <span style='color:#008080'>&lt;ab&gt;</span>       ab         ab         ab        \n3 abb    <span style='color:#008080'>&lt;ab&gt;</span>b      <span style='color:#008080'>&lt;abb&gt;</span>      <span style='color:#008080'>&lt;abb&gt;</span>      <span style='color:#008080'>&lt;abb&gt;</span>      <span style='color:#008080'>&lt;abb&gt;</span>      <span style='color:#008080'>&lt;abb&gt;</span>     \n4 abbb   <span style='color:#008080'>&lt;ab&gt;</span>bb     <span style='color:#008080'>&lt;abbb&gt;</span>     <span style='color:#008080'>&lt;abbb&gt;</span>     <span style='color:#008080'>&lt;abb&gt;</span>b     <span style='color:#008080'>&lt;abbb&gt;</span>     <span style='color:#008080'>&lt;abbb&gt;</span>    \n5 abbbb  <span style='color:#008080'>&lt;ab&gt;</span>bbb    <span style='color:#008080'>&lt;abbbb&gt;</span>    <span style='color:#008080'>&lt;abbbb&gt;</span>    <span style='color:#008080'>&lt;abb&gt;</span>bb    <span style='color:#008080'>&lt;abbbb&gt;</span>    <span style='color:#008080'>&lt;abbbb&gt;</span>   \n6 abbbbb <span style='color:#008080'>&lt;ab&gt;</span>bbbb   <span style='color:#008080'>&lt;abbbbb&gt;</span>   <span style='color:#008080'>&lt;abbbbb&gt;</span>   <span style='color:#008080'>&lt;abb&gt;</span>bbb   <span style='color:#008080'>&lt;abbbbb&gt;</span>   <span style='color:#008080'>&lt;abbbb&gt;</span>b  \n</pre>\n:::\n\n\n\nNotice that these are all **eager** (sometimes called **greedy**), in the sense that they will always match to as many repetitions as they possibly can while satisfying the rules. However, you can reverse this behaviour and make a quantifier **lazy** by appending  `?` immediately after the quantifier. A lazy quantifier will match against the fewest number of repetitions as it can possibly can while satisfying the rule. Here's what that looks like:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntibble(\n  string    = c(\"a\", \"ab\", \"abb\", \"abbb\", \"abbbb\", \"abbbbb\"),\n  `ab??`     = str_view(string, pattern = \"ab??\", match = NA),\n  `ab*?`     = str_view(string, pattern = \"ab*?\", match = NA),\n  `ab+?`     = str_view(string, pattern = \"ab+?\", match = NA),\n  `ab{2}?`   = str_view(string, pattern = \"ab{2}?\", match = NA),\n  `ab{2,}?`  = str_view(string, pattern = \"ab{2,}?\", match = NA),\n  `ab{2,4}?` = str_view(string, pattern = \"ab{2,4}?\", match = NA)\n)\n```\n\n<pre># A tibble: 6 × 7\n  string `ab??`     `ab*?`     `ab+?`     `ab{2}?`   `ab{2,}?`  `ab{2,4}?`\n  <span style='color:#008080'>&lt;chr&gt;</span>  <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span>\n1 a      <span style='color:#008080'>&lt;a&gt;</span>        <span style='color:#008080'>&lt;a&gt;</span>        a          a          a          a         \n2 ab     <span style='color:#008080'>&lt;a&gt;</span>b       <span style='color:#008080'>&lt;a&gt;</span>b       <span style='color:#008080'>&lt;ab&gt;</span>       ab         ab         ab        \n3 abb    <span style='color:#008080'>&lt;a&gt;</span>bb      <span style='color:#008080'>&lt;a&gt;</span>bb      <span style='color:#008080'>&lt;ab&gt;</span>b      <span style='color:#008080'>&lt;abb&gt;</span>      <span style='color:#008080'>&lt;abb&gt;</span>      <span style='color:#008080'>&lt;abb&gt;</span>     \n4 abbb   <span style='color:#008080'>&lt;a&gt;</span>bbb     <span style='color:#008080'>&lt;a&gt;</span>bbb     <span style='color:#008080'>&lt;ab&gt;</span>bb     <span style='color:#008080'>&lt;abb&gt;</span>b     <span style='color:#008080'>&lt;abb&gt;</span>b     <span style='color:#008080'>&lt;abb&gt;</span>b    \n5 abbbb  <span style='color:#008080'>&lt;a&gt;</span>bbbb    <span style='color:#008080'>&lt;a&gt;</span>bbbb    <span style='color:#008080'>&lt;ab&gt;</span>bbb    <span style='color:#008080'>&lt;abb&gt;</span>bb    <span style='color:#008080'>&lt;abb&gt;</span>bb    <span style='color:#008080'>&lt;abb&gt;</span>bb   \n6 abbbbb <span style='color:#008080'>&lt;a&gt;</span>bbbbb   <span style='color:#008080'>&lt;a&gt;</span>bbbbb   <span style='color:#008080'>&lt;ab&gt;</span>bbbb   <span style='color:#008080'>&lt;abb&gt;</span>bbb   <span style='color:#008080'>&lt;abb&gt;</span>bbb   <span style='color:#008080'>&lt;abb&gt;</span>bbb  \n</pre>\n:::\n\n\n\nObviously, some of those are silly. There's no point whatsoever in writing a regular expression like `ab{2,4}?`, because it produces exactly the same behaviour as `ab{2}`.\n\nTo give an example where these fancier quantifiers come in handy, I'll use a recent [Midnight Pals thread](https://bsky.app/profile/midnightpals.bsky.social/post/3ld7vr34nok2n). If you're not a regular reader of Midnight Pals, it's essentially a literary satire that makes oblique references to current events. Edgar Allen Poe, Stephen King, Clive Barker, and Mary Shelley are recurring characters, for instance. So too is JK Rowling, though she doesn't associate with the other characters and instead tends to live in her own \"mysterious circle of robed figures\". One of the conceits of the JKR character is that she hisses many of her lines and so the text often contains words like `\"bluesssky\"` or `\"transssses\"`. The actual number of repetitions varies of course, so we might want to use a regular expression like `s{3,}` to find instances of three or more successive `s` characters:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(midnight, \"s{3,}\")\n```\n\n<pre> [3] │ Rowling: what new<span style='color:#008080'>&lt;sss&gt;</span>, wormtongue?\n [4] │ Rowling: how goes the infiltration of blue<span style='color:#008080'>&lt;sss&gt;</span>ky?\n[17] │ Rowling: door'<span style='color:#008080'>&lt;sss&gt;</span> open, boy<span style='color:#008080'>&lt;sss&gt;</span>!\n[20] │ Rowling: i know you did, je<span style='color:#008080'>&lt;ssss&gt;</span>e\n[22] │ Rowling: yess you did great je<span style='color:#008080'>&lt;sss&gt;</span>e\n[43] │ Rowling: patience, <span style='color:#008080'>&lt;ssss&gt;</span>isster, we must bide our time\n[54] │ Rowling: sure, je<span style='color:#008080'>&lt;sss&gt;</span>e might look like a sniveling worm, a nasty crawling slithering little shit, a spineless craven buffoon\n</pre>\n:::\n\n\n\nIdeally, we'd like a regular expression that captures the entire hissssssed word, but to do that we'll need to get a little fancier, and dive a little deeper into regular expression syntax.\n\n## Backslash escape\n\nThe discussion of quantifiers leads to the natural question: what if I don't want to use `?` as a quantifier, and instead want to match a literal `?` in the string. To do that we can **escape** the special character by prefixing it with a backslash. That is, within a regular expression we would write `\\?` to match a literal `?`. \n\nIt gets complicated, though, because the way we represent the regular expression is via an R string,^[I'm not talking about raw strings in this post. Sorry.] and `\\` has a special meaning in R strings, because it's used as an escape character in R too. So if we want to \"pass\" a literal `\\` into the regular expression, the thing we need to type in R is `\"\\\\\"`. This is... confusing. I find this helps:\n\n- write `\"\\\\+\"` in R to mean `\\+` in the regex, and match a literal `+`\n- write `\"\\\\.\"` in R to mean `\\.` in the regex, and match a literal `.`\n- write `\"\\\\?\"` in R to mean `\\?` in the regex, and match a literal `?`\n- write `\"\\\\*\"` in R to mean `\\*` in the regex, and match a literal `*`\n- write `\"\\\\{\"` in R to mean `\\{` in the regex, and match a literal `{`\n\nIt obviously follows that since `\\` is used as the escape character it too must be escaped if you want to treat it as a literal:\n\n- write `\"\\\\\\\\\"` in R to mean `\\\\` in the regex, and match a literal `\\`\n\nHere's an example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"\\\\?\")\n```\n\n<pre>[18] │ Um, can you play a song with a fucking beat<span style='color:#008080'>&lt;?&gt;</span>\n[47] │ Dude, can you play a song with a fucking beat<span style='color:#008080'>&lt;?&gt;</span>\n[63] │ But does it happen<span style='color:#008080'>&lt;?&gt;</span> (No)\n[64] │ But does it happen<span style='color:#008080'>&lt;?&gt;</span> (No)\n[66] │ (A what<span style='color:#008080'>&lt;?&gt;</span>) A femininomenon\n[76] │ Did you hear me<span style='color:#008080'>&lt;?&gt;</span> Play the fucking beat\n</pre>\n:::\n\n\n\nThe same logic applies to special characters like line feed `\\n` and tabs `\\t`. \n\n- write `\"\\\\n\"` in R to mean `\\n` in the regex, and match a line feed\n- write `\"\\\\t\"` in R to mean `\\t` in the regex, and match a tab\n- write `\"\\\\u\"` in R to mean `\\u` in the regex, and use it to specify a unicode character\n\nAn example with unicode. Let's say you have text with mathematical symbols. For example, `\\u2192` is the unicode specification for a rightward arrow:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(\"n → ∞\", \"\\\\u2192\")\n```\n\n<pre>[1] │ n <span style='color:#008080'>&lt;→&gt;</span> ∞\n</pre>\n:::\n\n\n\n\n## Character sets\n\nEarlier in the post we encountered the irritating problem of capital letters. If we want to detect all lines where Chappell Roan sings `\"you\"` or `\"your\"` without worrying about capitalisation, we need a way of describing \"a single character that can either be `y` or `Y`\". We can do this by defining a **character set** (sometimes referred to as a **category** or **class**) by enclosing the set of allowed characters in square brackets. For example, the character set `[yY]` will match to a single instance of `y` or a single instance of `Y`. Our regular expression now becomes `\"[Yy]our?\"`, as shown below:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"[Yy]our?\")\n```\n\n<pre> [3] │ Got so close but then <span style='color:#008080'>&lt;you&gt;</span> lost it\n [4] │ Should've listened to <span style='color:#008080'>&lt;your&gt;</span> friends\n [6] │ <span style='color:#008080'>&lt;You&gt;</span> sent him pictures and playlists and phone sex\n [7] │ He disappeared from the second that <span style='color:#008080'>&lt;you&gt;</span> said\n[18] │ Um, can <span style='color:#008080'>&lt;you&gt;</span> play a song with a fucking beat?\n[32] │ <span style='color:#008080'>&lt;You&gt;</span> pretend to love his mother\n[33] │ Lying to <span style='color:#008080'>&lt;your&gt;</span> friends about\n[35] │ Stuck in the suburbs, <span style='color:#008080'>&lt;you&gt;</span>'re folding his laundry\n[36] │ Got what <span style='color:#008080'>&lt;you&gt;</span> wanted, so stop feeling sorry\n[47] │ Dude, can <span style='color:#008080'>&lt;you&gt;</span> play a song with a fucking beat?\n[60] │ Ladies, <span style='color:#008080'>&lt;you&gt;</span> know what I mean\n[61] │ And <span style='color:#008080'>&lt;you&gt;</span> know what <span style='color:#008080'>&lt;you&gt;</span> need\n[76] │ Did <span style='color:#008080'>&lt;you&gt;</span> hear me? Play the fucking beat\n</pre>\n:::\n\n\n\nYou can apply quantifiers to character sets, but you need to be a little careful about this. Let's say I have the character set `[femino]`, and I want to apply the quantifier `{4,}` to detect four or more repetitions of the character set. The regular expression `[femino]{4,}` will match against literal repetitions like `\"oooo\"` or `\"mmmmm\"`, but it will also match to words like `\"omen\"` and `\"feminine\"` because evey letter in those words belongs to the character set:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"[femino]{4,}\")\n```\n\n<pre> [8] │ \"Let's get c<span style='color:#008080'>&lt;offee&gt;</span>, let's meet up\"\n[24] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[28] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[53] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[57] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[65] │ Well, what we really need is a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[66] │ (A what?) A <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[72] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[82] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[86] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[90] │ Make a bitch, it's a fem (It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>)\n</pre>\n:::\n\n\n\n... oh yeah, it also matches the `\"offee\"` in `\"coffee\"`.\n\n### Ranges and shorthand notation\n\nWhen referring to alphabetic characters or digits, you can use a hyphen within a character set to define a **range** of characters. For example, `[0-9]` is essentially a shorthand for `[0123456789]` and `[a-e]` is short hand for `[abcde]`. You can define multiple ranges within a single character set, so `[a-zA-Z0-9]` will match against alphanumeric characters.\n\nSome character sets are used so often that there is a shorthand notation for them:\n\n- `\\d` denotes digits, and is equivalent to `[0-9]`\n- `\\w` denotes word characters. At a minimum it supports alphanumeric characters, but it will also match against unicode characters used in words. \n- `\\s` denotes whitespace characters, and will match a space `\" \"`, a tab `\"\\t\"`, a carriage return `\"\\r\"`, a line feed `\"\\n\"`, or a form feed `\"\\f\"`; as well as unicode separator characters if the regex flavour supports unicode\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntibble(\n  string    = c(\"1 11\", \"a aa\", \"A AA\"),\n  `\\\\d+`     = str_view(string, pattern = \"\\\\d+\", match = NA),\n  `\\\\w+`     = str_view(string, pattern = \"\\\\w+\", match = NA),\n  `\\\\s+`     = str_view(string, pattern = \"\\\\s+\", match = NA)\n)\n```\n\n<pre># A tibble: 3 × 4\n  string `\\\\d+`     `\\\\w+`     `\\\\s+`    \n  <span style='color:#008080'>&lt;chr&gt;</span>  <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span>\n1 1 11   <span style='color:#008080'>&lt;1&gt;</span> <span style='color:#008080'>&lt;11&gt;</span>   <span style='color:#008080'>&lt;1&gt;</span> <span style='color:#008080'>&lt;11&gt;</span>   1<span style='color:#008080'>&lt; &gt;</span>11    \n2 a aa   a aa       <span style='color:#008080'>&lt;a&gt;</span> <span style='color:#008080'>&lt;aa&gt;</span>   a<span style='color:#008080'>&lt; &gt;</span>aa    \n3 A AA   A AA       <span style='color:#008080'>&lt;A&gt;</span> <span style='color:#008080'>&lt;AA&gt;</span>   A<span style='color:#008080'>&lt; &gt;</span>AA    \n</pre>\n:::\n\n\n\n\n### Arithmetic\n\nSubtraction\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"[[a-z]-[femino]]{5,}\")\n```\n\n<pre> [6] │ You sent him pictures and <span style='color:#008080'>&lt;playl&gt;</span>ists and phone sex\n[35] │ Stuck in the <span style='color:#008080'>&lt;suburbs&gt;</span>, you're folding his laundry\n</pre>\n:::\n\n\n\nNegation:\n\nSuppose though I wanted to invert the match, and find strings of length 5 or more that do not contain any of these characters:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"[^femino]{5,}\")\n```\n\n<pre> [2] │ Same o<span style='color:#008080'>&lt;ld st&gt;</span>o<span style='color:#008080'>&lt;ry, t&gt;</span>ime again\n [3] │ Got so close<span style='color:#008080'>&lt; but th&gt;</span>en you lost it\n [4] │ Sho<span style='color:#008080'>&lt;uld'v&gt;</span>e listened to your friends\n [5] │ 'Bout his girlfrien<span style='color:#008080'>&lt;d back &gt;</span>in Boston\n [6] │ You sent him pictures an<span style='color:#008080'>&lt;d playl&gt;</span>i<span style='color:#008080'>&lt;sts a&gt;</span>nd phone sex\n [7] │ He disappeared from the secon<span style='color:#008080'>&lt;d that y&gt;</span>ou said\n [8] │ \"Le<span style='color:#008080'>&lt;t's g&gt;</span>et coffee, let's mee<span style='color:#008080'>&lt;t up\"&gt;</span>\n[10] │ An<span style='color:#008080'>&lt;d I d&gt;</span>on't understand\n[11] │ <span style='color:#008080'>&lt;Why ca&gt;</span>n't any man\n[15] │ Make a bi<span style='color:#008080'>&lt;tch, &gt;</span>i<span style='color:#008080'>&lt;t's a &gt;</span>fem\n[17] │ Make a bi<span style='color:#008080'>&lt;tch, &gt;</span>i<span style='color:#008080'>&lt;t's a—&gt;</span>\n[18] │ Um, can yo<span style='color:#008080'>&lt;u play a s&gt;</span>ong wi<span style='color:#008080'>&lt;th a &gt;</span>fucking beat?\n[22] │ (Get it hot) Get it hot like<span style='color:#008080'>&lt; Papa J&gt;</span>ohn\n[23] │ (Make a bi<span style='color:#008080'>&lt;tch) Mak&gt;</span>e a bi<span style='color:#008080'>&lt;tch g&gt;</span>o on and on\n[24] │ <span style='color:#008080'>&lt;(It's a &gt;</span>fem<span style='color:#008080'>&lt;) It's a &gt;</span>femininomenon\n[26] │ (Get it hot) Get it hot like<span style='color:#008080'>&lt; Papa J&gt;</span>ohn\n[27] │ (Make a bi<span style='color:#008080'>&lt;tch) Mak&gt;</span>e a bi<span style='color:#008080'>&lt;tch g&gt;</span>o on and on\n[28] │ <span style='color:#008080'>&lt;(It's a &gt;</span>fem<span style='color:#008080'>&lt;) It's a &gt;</span>femininomenon\n[31] │ So le<span style='color:#008080'>&lt;t's say &gt;</span>i<span style='color:#008080'>&lt;t's w&gt;</span>orking out\n[33] │ Lying to your frien<span style='color:#008080'>&lt;ds ab&gt;</span>out\n... and 36 more\n</pre>\n:::\n\n\n\n### idk where \n\nWhen used at the beginning of the category `^` is interpreted as negation. So notice the difference: the regex `[^a]` matches a single character that is not an `a` whereas `[a^]` matches a single character that is either `a` or `^`. The difference is illustrated here:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(\"aaa bbb ^^^ ccc\", \"[^a]+\")\n```\n\n<pre>[1] │ aaa<span style='color:#008080'>&lt; bbb ^^^ ccc&gt;</span>\n</pre>\n\n```{.r .cell-code}\nstr_view(\"aaa bbb ^^^ ccc\", \"[a^]+\")\n```\n\n<pre>[1] │ <span style='color:#008080'>&lt;aaa&gt;</span> bbb <span style='color:#008080'>&lt;^^^&gt;</span> ccc\n</pre>\n:::\n\n\n\nWe now have four rules for `^`:\n\n- If `^` appears outside a category it is the anchor\n- If `^` appears at the start of a category it inverts the category\n- If `^` appears elsewhere in a category it is a literal\n- If `^` appears outside a category but after `\\` it is a literal\n\nSo let's suppose I want to capture \"everything from the start of a string, up to (and including) the first `^` character appears\". The regular expression I need is `^[^^]+\\^`, and of course I need the extra slash in the R string so I write `\"^[^^]+\\\\^\"`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(\"hi there^^ hi^^ hi\", \"^[^^]+\\\\^\")\n```\n\n<pre>[1] │ <span style='color:#008080'>&lt;hi there^&gt;</span>^ hi^^ hi\n</pre>\n:::\n\n\n\nThere are four:\n\n- `^` is used for negation (e.g., `[^a]` maches all characters except `a`)\n- `]` is used to close the category (e.g. you need to do `[\\][]` to match open or close brackets)\n- `-` is used to specify character ranges (e.g., `[a-d]` matches `a`, `b`, `c` or `d`)\n\nIn other words, characters like `*`, `.`, and `?` which are metacharacters *outside* a category, are treated as literals inside a category\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"[*.?+]\")\n```\n\n<pre>[18] │ Um, can you play a song with a fucking beat<span style='color:#008080'>&lt;?&gt;</span>\n[47] │ Dude, can you play a song with a fucking beat<span style='color:#008080'>&lt;?&gt;</span>\n[63] │ But does it happen<span style='color:#008080'>&lt;?&gt;</span> (No)\n[64] │ But does it happen<span style='color:#008080'>&lt;?&gt;</span> (No)\n[66] │ (A what<span style='color:#008080'>&lt;?&gt;</span>) A femininomenon\n[76] │ Did you hear me<span style='color:#008080'>&lt;?&gt;</span> Play the fucking beat\n</pre>\n:::\n\n\n\n\n## Groups\n\nSuppose we want something a little fancier. Let's say, I want to find every line in which she sings either \"fem\" or \"femininomenon\". To do this, we wrap each of these strings in parentheses to define **groups**,^[Specifically, these are \"capturing\" groups because this syntax supports \"backreferencing\", which will come up later. This can be distinguished from \"non-capturing\" groups that can be written using slightly different syntax, but in all honesty I almost always use capturing groups because I'm lazy.] and use the `|` to indicate that the string can match against either of these groups. So our regular expression becomes `\"(femininomenon)|(fem)\"`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"(femininomenon)|(fem)\")\n```\n\n<pre>[15] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>\n[24] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[28] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[44] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>\n[53] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[57] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[65] │ Well, what we really need is a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[66] │ (A what?) A <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[72] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[82] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[86] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[90] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span> (It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>)\n[92] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>\n</pre>\n:::\n\n\n\nImportantly, the `|` operator looks for matches by testing the left-hand side before the right-hand side. To see this, look at what happens when I reverse the order of the two groups:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"(fem)|(femininomenon)\")\n```\n\n<pre>[15] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>\n[24] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[28] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[44] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>\n[53] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[57] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[65] │ Well, what we really need is a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[66] │ (A what?) A <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[72] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[82] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[86] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[90] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span> (It's a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon)\n[92] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>\n</pre>\n:::\n\n\n\nNotice that this *never* detects a match against the `\"femininomenon\"` (the second group) because `\"fem\"` (the first group) matches every string that `\"feminomenon\"` could possibly have matched against.\n\nAn alternative way of approaching this -- and possibly a better one -- is to use quantifiers. In the previous section I only applied quantifiers like `?`, `*`, and `+` to a single character, but you can also apply them to a group. Because of that, the regular expression `\"fem(ininomenon)?\"` will work as expected here:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"fem(ininomenon)?\")\n```\n\n<pre>[15] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>\n[24] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[28] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[44] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>\n[53] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[57] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[65] │ Well, what we really need is a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[66] │ (A what?) A <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[72] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[82] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[86] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[90] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span> (It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>)\n[92] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>\n</pre>\n:::\n\n\n\n## Backreferences\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"f?([aeiou][rpnm])\\\\1+\")\n```\n\n<pre>[24] │ (It's a fem) It's a fem<span style='color:#008080'>&lt;inin&gt;</span>omenon\n[28] │ (It's a fem) It's a fem<span style='color:#008080'>&lt;inin&gt;</span>omenon\n[53] │ (It's a fem) It's a fem<span style='color:#008080'>&lt;inin&gt;</span>omenon\n[57] │ (It's a fem) It's a fem<span style='color:#008080'>&lt;inin&gt;</span>omenon\n[65] │ Well, what we really need is a fem<span style='color:#008080'>&lt;inin&gt;</span>omenon\n[66] │ (A what?) A fem<span style='color:#008080'>&lt;inin&gt;</span>omenon\n[72] │ (It's a fem) It's a fem<span style='color:#008080'>&lt;inin&gt;</span>omenon\n[82] │ (It's a fem) It's a fem<span style='color:#008080'>&lt;inin&gt;</span>omenon\n[86] │ (It's a fem) It's a fem<span style='color:#008080'>&lt;inin&gt;</span>omenon\n[90] │ Make a bitch, it's a fem (It's a fem<span style='color:#008080'>&lt;inin&gt;</span>omenon)\n</pre>\n:::\n\n\n\nCompare to this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"f?([aeiou][rpnm]){2,}\")\n```\n\n<pre>[24] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[28] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[53] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[57] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[65] │ Well, what we really need is a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[66] │ (A what?) A <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[72] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[82] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[86] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[90] │ Make a bitch, it's a fem (It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>)\n</pre>\n:::\n\n\n\n\n\n\n## Anchors\n\nYou can use `^` to match the start of a string and `$` to match the end. So `^L` would match the upper-case letter L, but only if it is the first character in the string:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"^L\")\n```\n\n<pre>[33] │ <span style='color:#008080'>&lt;L&gt;</span>ying to your friends about\n[60] │ <span style='color:#008080'>&lt;L&gt;</span>adies, you know what I mean\n</pre>\n:::\n\n\n\nWe can extend this to capture the first word in a string, so long as it starts with an upper-case L:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"^L[a-zA-z]*\")\n```\n\n<pre>[33] │ <span style='color:#008080'>&lt;Lying&gt;</span> to your friends about\n[60] │ <span style='color:#008080'>&lt;Ladies&gt;</span>, you know what I mean\n</pre>\n:::\n\n\n\nOr we could do the same trick, but for the end of a string. The regular expression `\"f[a-zA-z]*$\"` will match to all lines in the text that end in a word beginning with a lower-case f. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"f[a-zA-z]*$\")\n```\n\n<pre> [4] │ Should've listened to your <span style='color:#008080'>&lt;friends&gt;</span>\n[15] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>\n[24] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[28] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[44] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>\n[53] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[57] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[65] │ Well, what we really need is a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[66] │ (A what?) A <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[72] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[82] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[86] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[92] │ Make a bitch, it's a fem, fem, fem, <span style='color:#008080'>&lt;fem&gt;</span>\n</pre>\n:::\n\n\n\nAbout 99% of my use of anchors is either `$` or `^` but there are other anchors. It varies across engines, but from an R perspective you can use `\\A` to match the start of a match group (i.e., it works simularly to `^`) and `\\Z` to match the end, similar to `$`. So this is another way of detecting the first word in a line, as long as it starts with `L`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"\\\\AL[a-zA-z]*\")\n```\n\n<pre>[33] │ <span style='color:#008080'>&lt;Lying&gt;</span> to your friends about\n[60] │ <span style='color:#008080'>&lt;Ladies&gt;</span>, you know what I mean\n</pre>\n:::\n\n\n\n## more on escapes\n\nA little more subtle is the fact that *opening* (left) braces, brackets, and parentheses need to be escaped...\n\n- write `\"\\\\[\"` in R to mean `\\[` in the regex and match a literal `]`\n- write `\"\\\\(\"` in R to mean `\\(` in the regex and match a literal `]`\n- write `\"\\\\{\"` in R to mean `\\{` in the regex and match a literal `]`\n\nBut... while the same logic applies to a closing *parenthesis* `)`, it is *not* true for closing brackets `]` or braces `}`. Those two are treated as literals and should not be escaped:\n\n- write `\"]\"` in R to mean `]` in the regex and match a literal `]`\n- write `\"\\\\)\"` in R to mean `\\)` in the regex and match a literal `)`\n- write `\"}\"` in R to mean `}` in the regex and match a literal `}`\n\nThis is subtle enough that it's worth a couple of examples. Let's say I want to detect all instances of the bracketed literal text `[Chorus]` in the \"Feminomenon\" lyrics. I need to escape the opening bracket, so my regular expression begins with `\"\\\\[\"`, but I don't need to escape the closing bracket, so the regex ends with `\"]\"`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"\\\\[Chorus]\")\n```\n\n<pre>[20] │ <span style='color:#008080'>&lt;[Chorus]&gt;</span>\n[49] │ <span style='color:#008080'>&lt;[Chorus]&gt;</span>\n[78] │ <span style='color:#008080'>&lt;[Chorus]&gt;</span>\n</pre>\n:::\n\n\n\nHowever, if I want to match the literal text `(Get it hot)` I have to escape both of the parentheses, like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"\\\\(Get it hot\\\\)\")\n```\n\n<pre>[22] │ <span style='color:#008080'>&lt;(Get it hot)&gt;</span> Get it hot like Papa John\n[26] │ <span style='color:#008080'>&lt;(Get it hot)&gt;</span> Get it hot like Papa John\n[51] │ <span style='color:#008080'>&lt;(Get it hot)&gt;</span> Get it hot like Papa John\n[55] │ <span style='color:#008080'>&lt;(Get it hot)&gt;</span> Get it hot like Papa John\n[70] │ <span style='color:#008080'>&lt;(Get it hot)&gt;</span> Get it hot like Papa John\n[74] │ <span style='color:#008080'>&lt;(Get it hot)&gt;</span> Get it hot like Papa John\n[80] │ <span style='color:#008080'>&lt;(Get it hot)&gt;</span> Get it hot like Papa John\n[84] │ <span style='color:#008080'>&lt;(Get it hot)&gt;</span> Get it hot like Papa John\n</pre>\n:::\n\n\n\n\n\n## It gets messy\n\nThis gets messy quite quickly. Suppose I want to match every instance where text is enclosed in brackets or parentheses:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"(\\\\[[^\\\\]]*])|(\\\\([^)]*\\\\))\")\n```\n\n<pre> [1] │ <span style='color:#008080'>&lt;[Verse 1]&gt;</span>\n[13] │ <span style='color:#008080'>&lt;[Pre-Chorus]&gt;</span>\n[20] │ <span style='color:#008080'>&lt;[Chorus]&gt;</span>\n[21] │ <span style='color:#008080'>&lt;(Hit it like)&gt;</span> Hit it like rom-pom-pom-pom\n[22] │ <span style='color:#008080'>&lt;(Get it hot)&gt;</span> Get it hot like Papa John\n[23] │ <span style='color:#008080'>&lt;(Make a bitch)&gt;</span> Make a bitch go on and on\n[24] │ <span style='color:#008080'>&lt;(It's a fem)&gt;</span> It's a femininomenon\n[25] │ <span style='color:#008080'>&lt;(Hit it like)&gt;</span> Hit it like rom-pom-pom-pom\n[26] │ <span style='color:#008080'>&lt;(Get it hot)&gt;</span> Get it hot like Papa John\n[27] │ <span style='color:#008080'>&lt;(Make a bitch)&gt;</span> Make a bitch go on and on\n[28] │ <span style='color:#008080'>&lt;(It's a fem)&gt;</span> It's a femininomenon\n[30] │ <span style='color:#008080'>&lt;[Verse 2]&gt;</span>\n[42] │ <span style='color:#008080'>&lt;[Pre-Chorus]&gt;</span>\n[49] │ <span style='color:#008080'>&lt;[Chorus]&gt;</span>\n[50] │ <span style='color:#008080'>&lt;(Hit it like)&gt;</span> Hit it like rom-pom-pom-pom\n[51] │ <span style='color:#008080'>&lt;(Get it hot)&gt;</span> Get it hot like Papa John\n[52] │ <span style='color:#008080'>&lt;(Make a bitch)&gt;</span> Make a bitch go on and on\n[53] │ <span style='color:#008080'>&lt;(It's a fem)&gt;</span> It's a femininomenon\n[54] │ <span style='color:#008080'>&lt;(Hit it like)&gt;</span> Hit it like rom-pom-pom-pom\n[55] │ <span style='color:#008080'>&lt;(Get it hot)&gt;</span> Get it hot like Papa John\n... and 24 more\n</pre>\n:::\n\n\n\nTo unpack a little:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntests <- c(\n  \"[this should match] the bracketed part\",\n  \"(this should match) the parenthetical part\",\n  \"(this should [] match) the outer parenthetical\",\n  \"[this should () match] the outer brackets\",\n  \"[this should not match at all\",\n  \"[this should not match) at all\"\n)\nstr_view(tests, \"(\\\\[[^\\\\]]*])|(\\\\([^)]*\\\\))\")\n```\n\n<pre>[1] │ <span style='color:#008080'>&lt;[this should match]&gt;</span> the bracketed part\n[2] │ <span style='color:#008080'>&lt;(this should match)&gt;</span> the parenthetical part\n[3] │ <span style='color:#008080'>&lt;(this should [] match)&gt;</span> the outer parenthetical\n[4] │ <span style='color:#008080'>&lt;[this should () match]&gt;</span> the outer brackets\n</pre>\n:::\n\n\n\n## Oh no not another take\n\nA persistent headache I have when writing regular expressions, besides the fact that they suck, is that there are so many slight variations on the same idea. At [regular-expressions.info](https://regular-expressions.info), for instance, you can find quick lookup tables for a wide variety of different regular expression engines. It lists [regular expressions in R](https://www.regular-expressions.info/rlanguage.html) as one of those systems, but it's important to remember that this refers to the syntax used by base R tools like `grep()`, `gsub()`, `gregexpr()` and so on. Or, more precisely, it refers to the default POSIX standard for extended regular expressions. Base R actually supports two different engines, so if you set `perl = TRUE` when calling base R functions then you would need to look at the [rules for PCRE](https://www.regular-expressions.info/pcre.html). In tidyverse, regular expressions are usually handled with the [stringr](https://stringr.tidyverse.org/) package that is built on top of [stringi](https://stringi.gagolewski.com/), which in turn uses the [ICU](https://icu.unicode.org/) engine that conforms to Unicode standards and as such provides comprehensive Unicode support. The [stringi regular expressions](https://stringi.gagolewski.com/weave/regular_expressions.html) page has a nice discussion. \n\nLike an idiot, I forget this on a semi-regular basis, and I try to debug something by looking up the wrong regex syntax and yes, this sometimes matters. For instance, in the help documentation for regex in base R, you can find some discussion of various predefined POSIX classes (e.g., `\"[[:alpha:]]\"` matches alphabetic characters, `[[:digit:]]` matches numeric digits, and `\"[[:punct:]]\"` matches punctuation characters). However, different engines interpret these classes differently, which means you'll sometimes get different results depending on which engine you use.^[It also depends on the system locale. Not surprising, of course, but that does add to the sheer chaos of it all.]\n\nTo illustrate this I'll use an example that I have shamelessly stolen directly from the [stringi documentation](https://stringi.gagolewski.com/weave/regular_expressions.html#avoiding-posix-classes), in order to show how very differently `\"[[:punct:]]\"` is interpreted across the three most commonly used regex engines in R. But first, because I cannot even with the base R regular expression syntax,^[I mean, wtf. I am genuinely sympathetic to R core, and deeply appreciate their willingness to maintain backward compatibility even for the bits of R that are just bizarre. But oh my god.] I'll define a `base_extract_all()` function that is roughly analogous to `stringr::str_extract_all()`, but uses the base R functions to do the work:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_extract_all <- function(string, pattern, perl = FALSE) {\n  matches <- gregexpr(pattern = pattern, text = string, perl = perl)\n  regmatches(x = string, m = matches)\n}\n```\n:::\n\n\n\nNext, I'll define a string `punct` containing a lot of punctuation characters:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npunct <- \",./|\\\\<>?;:'\\\"[]{}-=_+()*&^%$€#@!`~×‒„”\"\n```\n:::\n\n\n\nSo, what happens when we match `punct` to `\"[[:punct:]]\"`? Well, it depends heavily on which engine you're using. If you're using ERE (i.e., base R with `perl = FALSE`), you get this as the result:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_extract_all(punct, \"[[:punct:]]\")\n```\n\n<pre>[[1]]\n [1] \",\"  \".\"  \"/\"  \"|\"  \"\\\\\" \"<span style='color:#008080'>&lt;\"  \"&gt;</span>\"  \"?\"  \";\"  \":\"  \"'\"  \"\\\"\" \"[\"  \"]\" \n[15] \"{\"  \"}\"  \"-\"  \"=\"  \"_\"  \"+\"  \"(\"  \")\"  \"*\"  \"&\"  \"^\"  \"%\"  \"$\"  \"€\" \n[29] \"#\"  \"@\"  \"!\"  \"`\"  \"~\"  \"×\"  \"‒\"  \"„\"  \"”\" \n</pre>\n:::\n\n\n\nWhat about PCRE? Let's set `perl = TRUE` and have a look:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_extract_all(punct, \"[[:punct:]]\", perl = TRUE)\n```\n\n<pre>[[1]]\n [1] \",\"  \".\"  \"/\"  \"|\"  \"\\\\\" \"<span style='color:#008080'>&lt;\"  \"&gt;</span>\"  \"?\"  \";\"  \":\"  \"'\"  \"\\\"\" \"[\"  \"]\" \n[15] \"{\"  \"}\"  \"-\"  \"=\"  \"_\"  \"+\"  \"(\"  \")\"  \"*\"  \"&\"  \"^\"  \"%\"  \"$\"  \"#\" \n[29] \"@\"  \"!\"  \"`\"  \"~\" \n</pre>\n:::\n\n\n\nOkay yeah that is not even close to being the same thing. But what about the ICU engine? If you're working in tidyverse, internally you're probably relying on this engine and, well...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_extract_all(punct, \"[[:punct:]]\")\n```\n\n<pre>[[1]]\n [1] \",\"  \".\"  \"/\"  \"\\\\\" \"?\"  \";\"  \":\"  \"'\"  \"\\\"\" \"[\"  \"]\"  \"{\"  \"}\"  \"-\" \n[15] \"_\"  \"(\"  \")\"  \"*\"  \"&\"  \"%\"  \"#\"  \"@\"  \"!\"  \"‒\"  \"„\"  \"”\" \n</pre>\n:::\n\n\n\nLe sigh. Of course. \n\n\n\n## I'm so sorry for my loss\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrules <- tribble(\n              ~pattern, ~replacement,\n    \"([Dd]o)(-[Dd]o)+\",         \"🎶\", # do-do, do-do-do -> musical note\n             \"feather\",         \"🪶\", # feather -> emoji feather\n                \"wine\",         \"🍷\", # wine -> emoji wine\n         \"\\\\([Aa]h\\\\)\",      \"...😌\", # (ah) -> ...emoji relief\n  \"\\\\[([^\\\\[\\\\]]+)\\\\]\",          \"~\"  # replace square bracketed text\n)\n\nstr_rewrite <- function(string, rules) {\n  purrr::reduce2(\n    .x = rules$pattern, \n    .y = rules$replacement, \n    .f = str_replace_all, \n    .init = string\n  )\n}\n\nfeather |> \n  str_rewrite(rules) |> \n  cat(sep = \"\\n\")\n```\n\n<pre>~\n(🎶, 🎶, 🎶, 🎶)\n(🎶, 🎶, 🎶, 🎶)\nOh, not another take\n\n~\nOh, it's like that, I'm your dream come true\nWhen it's on a platter for you\nThen you pull back when I try to make plans\nMore than two hours in advance, mm\n\n~\nI slam the door, I hit ignore\nI'm saying, \"No, no, no, no more\"\nI got you blocked, after this, an afterthought\nI finally cut you off\n\n~\nI feel so much lighter like a 🪶 with you off my mind ...😌\nFloatin' through the memories like whatever, you're a waste of time ...😌\nYour signals are mixed, you act like a bitch\nYou fit every stereotype, \"Send a pic\"\nI feel so much lighter like a 🪶 with you out my life\nWith you out my life\n\n~\n(🎶, 🎶, 🎶, 🎶)\n(🎶, 🎶, 🎶, 🎶)\nLike a 🪶, like a 🪶, like a 🪶, yeah\n\n~\nIt feels so good\nNot carin' where you are tonight\nAnd it feels so good\nNot pretendin' to like the 🍷 you like\n\n~\nI slam the door (Slam the door), I hit ignore (Hit ignore)\nI'm saying, \"No, no, no, no more\"\nI got you blocked, excited to never talk, I\nI'm so sorry for your loss\n\n~\nI feel so much lighter like a 🪶 with you off my mind ...😌\nFloatin' through the memories like whatever, you're a waste of time ...😌\nYour signals are mixed, you act like a bitch (A bitch)\nYou fit every stereotype, \"Send a pic\"\nI feel so much lighter like a 🪶 with you out my life\nWith you out my life\n\n~\n(🎶, 🎶, 🎶, 🎶)\nAh, mm\n(🎶, 🎶, 🎶, 🎶)\nLike a 🪶, like a 🪶, like a 🪶\n\n~\nYou want me? I'm done\nYou miss me? No duh\nWhere I'm at, I'm up where I'm at\nYou want me? I'm done (I'm done)\nYou miss me? No duh (No duh)\nWhere I'm at, I'm up (I'm up) where I'm at\n\n~\nYou want me? I'm done\n(I feel so much lighter like a 🪶 with you off my mind)\nYou miss me? No duh\nWhere I'm at, I'm up where I'm at\n(Like a 🪶, like a 🪶, like a 🪶)\nYou want me? I'm done\n(I feel so much lighter like a 🪶 with you off my mind)\nYou miss me? No duh\nWhere I'm at, I'm up where I'm at\n(Like a 🪶, like a 🪶, like a 🪶, yeah)\n</pre>\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}