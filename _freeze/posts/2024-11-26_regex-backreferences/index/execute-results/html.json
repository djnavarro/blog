{
  "hash": "18feda62e7403ef39b10389c3c800bde",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Baby got back references\"\ndescription: \"Now I have \\\\\\\\2 problems\"\ndate: \"2024-11-26\"\nimage: \"feather2.jpg\"\n--- \n\n\n\n<!--------------- my typical setup ----------------->\n\n\n\n\n\n\n\n::: {.cell}\n<style type=\"text/css\">\n@import url('https://fonts.googleapis.com/css2?family=Tangerine:wght@400;700&display=swap');\n\n.tangerine-regular {\n  font-family: \"Tangerine\", cursive;\n  font-weight: 400;\n  font-style: normal;\n}\n\n.tangerine-bold {\n  font-family: \"Tangerine\", cursive;\n  font-weight: 700;\n  font-style: normal;\n}\n</style>\n:::\n\n\n\n<!--------------- post begins here ----------------->\n\nAt least once a week I have this moment when a yawning pit of black despair opens at my feet, and the barbed tentacles of despair wrap around my legs, poison injects chill into my veins, the icy claws of anxiety rip through my viscera, and a withered voice of pure evil slithers into my brain and speaks to me in the disturbingly-seductive language of Mordor:\n\n<p class=\"tangerine-bold\" align=\"center\" style=\"font-size: 28pt\">why not write a regular expression?</p>\n\nI try to resist. I'm a good girl, I tell the Dark Lord. I would never. Not on a first date anyway. Well, buy a girl a drink first maybe? And... oh it's so cold outside and, I mean, Sauron is kinda hot. Have you not watched Rings of Power? Sometimes a girl has needs.\n\nUm. Anyway. What was I talking about? Oh, right. [Regular expressions](https://www.regular-expressions.info/).\n\n<br>\n\n::: {layout-ncol=2}\n\n![Writing a regular expression](feather1.jpg)\n\n![When the regular expression encounters a string](feather2.jpg)\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr)\nlibrary(tibble)\nlibrary(brio)\n```\n:::\n\n\n\n## A regularomenon\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfemininomenon <- read_lines(\"femininomenon.txt\")\ncat(femininomenon[60:66], sep = \"\\n\")\n```\n\n<pre>Ladies, you know what I mean\nAnd you know what you need\nAnd so does he\nBut does it happen? (No)\nBut does it happen? (No)\nWell, what we really need is a femininomenon\n(A what?) A femininomenon\n</pre>\n:::\n\n\n\nNot intending this to be a tutorial on regular expressions, but it's probably not a bad idea to very briefly talk about the descent into madness. The simplest form of regular expression is finding strings that match a specific, fixed subset of text. For instance, here's every line in \"Femininomenon\" in which Chappell Roan says \"femininomenon\":\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"femininomenon\")\n```\n\n<pre>[24] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[28] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[53] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[57] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[65] │ Well, what we really need is a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[66] │ (A what?) A <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[72] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[82] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[86] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[90] │ Make a bitch, it's a fem (It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>)\n</pre>\n:::\n\n\n\n### Groups\n\nSuppose we want something a little fancier. Let's say, I want to find every line in which she sings either \"fem\" or \"femininomenon\". To do this, we wrap each of these strings in parentheses to define **groups**,^[Specifically, these are \"capturing\" groups because this syntax supports \"backreferencing\", which will come up later. This can be distinguished from \"non-capturing\" groups that can be written using slightly different syntax, but in all honesty I almost always use capturing groups because I'm lazy.] and use the `|` to indicate that the string can match against either of these groups. So our regular expression becomes `\"(femininomenon)|(fem)\"`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"(femininomenon)|(fem)\")\n```\n\n<pre>[15] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>\n[24] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[28] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[44] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>\n[53] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[57] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[65] │ Well, what we really need is a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[66] │ (A what?) A <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[72] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[82] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[86] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[90] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span> (It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>)\n[92] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>\n</pre>\n:::\n\n\n\nImportantly, the `|` operator looks for matches by testing the left-hand side before the right-hand side. To see this, look at what happens when I reverse the order of the two groups:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"(fem)|(femininomenon)\")\n```\n\n<pre>[15] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>\n[24] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[28] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[44] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>\n[53] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[57] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[65] │ Well, what we really need is a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[66] │ (A what?) A <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[72] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[82] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[86] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[90] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span> (It's a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon)\n[92] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>\n</pre>\n:::\n\n\n\nNotice that this *never* detects a match against the `\"femininomenon\"` (the second group) because `\"fem\"` (the first group) matches every string that `\"feminomenon\"` could possibly have matched against.\n\n### Quantifiers\n\nAn alternative way of approaching this, and possibly a better one, is to use **quantifiers**. There are several quantifiers supported by most regular expression flavours. Quantifiers always refer to the previous item, and specify the number of repetitions of the previous item that can be matched: \n\n- `?` matches zero or one time\n- `*` matches zero or more times\n- `+` matches one or more times\n- `{n}` matches exactly n times\n- `{n,}` matches n or more times\n- `{n,m}` matches at least n times but not more than m times\n\nHere's a little demonstration:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntibble(\n  string    = c(\"a\", \"ab\", \"abb\", \"abbb\", \"abbbb\", \"abbbbb\"),\n  `ab?`     = str_view(string, pattern = \"ab?\", match = NA),\n  `ab*`     = str_view(string, pattern = \"ab*\", match = NA),\n  `ab+`     = str_view(string, pattern = \"ab+\", match = NA),\n  `ab{2}`   = str_view(string, pattern = \"ab{2}\", match = NA),\n  `ab{2,}`  = str_view(string, pattern = \"ab{2,}\", match = NA),\n  `ab{2,4}` = str_view(string, pattern = \"ab{2,4}\", match = NA)\n)\n```\n\n<pre># A tibble: 6 × 7\n  string `ab?`      `ab*`      `ab+`      `ab{2}`    `ab{2,}`   `ab{2,4}` \n  <span style='color:#008080'>&lt;chr&gt;</span>  <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span>\n1 a      <span style='color:#008080'>&lt;a&gt;</span>        <span style='color:#008080'>&lt;a&gt;</span>        a          a          a          a         \n2 ab     <span style='color:#008080'>&lt;ab&gt;</span>       <span style='color:#008080'>&lt;ab&gt;</span>       <span style='color:#008080'>&lt;ab&gt;</span>       ab         ab         ab        \n3 abb    <span style='color:#008080'>&lt;ab&gt;</span>b      <span style='color:#008080'>&lt;abb&gt;</span>      <span style='color:#008080'>&lt;abb&gt;</span>      <span style='color:#008080'>&lt;abb&gt;</span>      <span style='color:#008080'>&lt;abb&gt;</span>      <span style='color:#008080'>&lt;abb&gt;</span>     \n4 abbb   <span style='color:#008080'>&lt;ab&gt;</span>bb     <span style='color:#008080'>&lt;abbb&gt;</span>     <span style='color:#008080'>&lt;abbb&gt;</span>     <span style='color:#008080'>&lt;abb&gt;</span>b     <span style='color:#008080'>&lt;abbb&gt;</span>     <span style='color:#008080'>&lt;abbb&gt;</span>    \n5 abbbb  <span style='color:#008080'>&lt;ab&gt;</span>bbb    <span style='color:#008080'>&lt;abbbb&gt;</span>    <span style='color:#008080'>&lt;abbbb&gt;</span>    <span style='color:#008080'>&lt;abb&gt;</span>bb    <span style='color:#008080'>&lt;abbbb&gt;</span>    <span style='color:#008080'>&lt;abbbb&gt;</span>   \n6 abbbbb <span style='color:#008080'>&lt;ab&gt;</span>bbbb   <span style='color:#008080'>&lt;abbbbb&gt;</span>   <span style='color:#008080'>&lt;abbbbb&gt;</span>   <span style='color:#008080'>&lt;abb&gt;</span>bbb   <span style='color:#008080'>&lt;abbbbb&gt;</span>   <span style='color:#008080'>&lt;abbbb&gt;</span>b  \n</pre>\n:::\n\n\n\nNotice that these are all \"greedy\", and the maximum number of repetitions is used whenever possible. You can make them lazy by appending `?` immediately after the quantifier. Here's what that looks like if we do this for all the regular expressions in the table above:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntibble(\n  string    = c(\"a\", \"ab\", \"abb\", \"abbb\", \"abbbb\", \"abbbbb\"),\n  `ab??`     = str_view(string, pattern = \"ab??\", match = NA),\n  `ab*?`     = str_view(string, pattern = \"ab*?\", match = NA),\n  `ab+?`     = str_view(string, pattern = \"ab+?\", match = NA),\n  `ab{2}?`   = str_view(string, pattern = \"ab{2}?\", match = NA),\n  `ab{2,}?`  = str_view(string, pattern = \"ab{2,}?\", match = NA),\n  `ab{2,4}?` = str_view(string, pattern = \"ab{2,4}?\", match = NA)\n)\n```\n\n<pre># A tibble: 6 × 7\n  string `ab??`     `ab*?`     `ab+?`     `ab{2}?`   `ab{2,}?`  `ab{2,4}?`\n  <span style='color:#008080'>&lt;chr&gt;</span>  <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span>\n1 a      <span style='color:#008080'>&lt;a&gt;</span>        <span style='color:#008080'>&lt;a&gt;</span>        a          a          a          a         \n2 ab     <span style='color:#008080'>&lt;a&gt;</span>b       <span style='color:#008080'>&lt;a&gt;</span>b       <span style='color:#008080'>&lt;ab&gt;</span>       ab         ab         ab        \n3 abb    <span style='color:#008080'>&lt;a&gt;</span>bb      <span style='color:#008080'>&lt;a&gt;</span>bb      <span style='color:#008080'>&lt;ab&gt;</span>b      <span style='color:#008080'>&lt;abb&gt;</span>      <span style='color:#008080'>&lt;abb&gt;</span>      <span style='color:#008080'>&lt;abb&gt;</span>     \n4 abbb   <span style='color:#008080'>&lt;a&gt;</span>bbb     <span style='color:#008080'>&lt;a&gt;</span>bbb     <span style='color:#008080'>&lt;ab&gt;</span>bb     <span style='color:#008080'>&lt;abb&gt;</span>b     <span style='color:#008080'>&lt;abb&gt;</span>b     <span style='color:#008080'>&lt;abb&gt;</span>b    \n5 abbbb  <span style='color:#008080'>&lt;a&gt;</span>bbbb    <span style='color:#008080'>&lt;a&gt;</span>bbbb    <span style='color:#008080'>&lt;ab&gt;</span>bbb    <span style='color:#008080'>&lt;abb&gt;</span>bb    <span style='color:#008080'>&lt;abb&gt;</span>bb    <span style='color:#008080'>&lt;abb&gt;</span>bb   \n6 abbbbb <span style='color:#008080'>&lt;a&gt;</span>bbbbb   <span style='color:#008080'>&lt;a&gt;</span>bbbbb   <span style='color:#008080'>&lt;ab&gt;</span>bbbb   <span style='color:#008080'>&lt;abb&gt;</span>bbb   <span style='color:#008080'>&lt;abb&gt;</span>bbb   <span style='color:#008080'>&lt;abb&gt;</span>bbb  \n</pre>\n:::\n\n\n\nObviously, some of those are silly. There's really no point in specifying a regular expression like `ab{2,4}?` because it's the same as `ab{2}`\n\nSo, to return to the femininomenon example, we could use `\"fem(ininomenon)?\"` as the regular expression and it will do the same job: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"fem(ininomenon)?\")\n```\n\n<pre>[15] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>\n[24] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[28] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[44] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>\n[53] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[57] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[65] │ Well, what we really need is a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[66] │ (A what?) A <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[72] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[82] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[86] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[90] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span> (It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>)\n[92] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>\n</pre>\n:::\n\n\n\n### Categories\n\nSubstrings (of at least three characters) comprised only from the letters f, e, m, i, n, and o:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"[femino]{3,}\")\n```\n\n<pre> [2] │ Same old story, t<span style='color:#008080'>&lt;ime&gt;</span> again\n [4] │ Should've list<span style='color:#008080'>&lt;ene&gt;</span>d to your fr<span style='color:#008080'>&lt;ien&gt;</span>ds\n [5] │ 'Bout his girlfr<span style='color:#008080'>&lt;ien&gt;</span>d back in Boston\n [6] │ You sent him pictures and playlists and ph<span style='color:#008080'>&lt;one&gt;</span> sex\n [8] │ \"Let's get c<span style='color:#008080'>&lt;offee&gt;</span>, let's <span style='color:#008080'>&lt;mee&gt;</span>t up\"\n [9] │ I'm so sick of onl<span style='color:#008080'>&lt;ine&gt;</span> love\n[15] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>\n[24] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[28] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[33] │ Lying to your fr<span style='color:#008080'>&lt;ien&gt;</span>ds about\n[36] │ Got what you wanted, so stop <span style='color:#008080'>&lt;fee&gt;</span>ling sorry\n[38] │ I'm so sick of onl<span style='color:#008080'>&lt;ine&gt;</span> love\n[44] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>\n[53] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[57] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[61] │ And you know what you <span style='color:#008080'>&lt;nee&gt;</span>d\n[65] │ Well, what we really <span style='color:#008080'>&lt;nee&gt;</span>d is a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[66] │ (A what?) A <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[72] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[82] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n... and 3 more\n</pre>\n:::\n\n\n\n### Backreferences\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"f?([aeiou][rpnm])\\\\1+\")\n```\n\n<pre>[24] │ (It's a fem) It's a fem<span style='color:#008080'>&lt;inin&gt;</span>omenon\n[28] │ (It's a fem) It's a fem<span style='color:#008080'>&lt;inin&gt;</span>omenon\n[53] │ (It's a fem) It's a fem<span style='color:#008080'>&lt;inin&gt;</span>omenon\n[57] │ (It's a fem) It's a fem<span style='color:#008080'>&lt;inin&gt;</span>omenon\n[65] │ Well, what we really need is a fem<span style='color:#008080'>&lt;inin&gt;</span>omenon\n[66] │ (A what?) A fem<span style='color:#008080'>&lt;inin&gt;</span>omenon\n[72] │ (It's a fem) It's a fem<span style='color:#008080'>&lt;inin&gt;</span>omenon\n[82] │ (It's a fem) It's a fem<span style='color:#008080'>&lt;inin&gt;</span>omenon\n[86] │ (It's a fem) It's a fem<span style='color:#008080'>&lt;inin&gt;</span>omenon\n[90] │ Make a bitch, it's a fem (It's a fem<span style='color:#008080'>&lt;inin&gt;</span>omenon)\n</pre>\n:::\n\n\n\nCompare to this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"f?([aeiou][rpnm]){2,}\")\n```\n\n<pre>[24] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[28] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[53] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[57] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[65] │ Well, what we really need is a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[66] │ (A what?) A <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[72] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[82] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[86] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[90] │ Make a bitch, it's a fem (It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>)\n</pre>\n:::\n\n\n\n\n### Anchors\n\nYou can use `^` to match the start of a string and `$` to match the end. So `^L` would match the upper-case letter L, but only if it is the first character in the string:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"^L\")\n```\n\n<pre>[33] │ <span style='color:#008080'>&lt;L&gt;</span>ying to your friends about\n[60] │ <span style='color:#008080'>&lt;L&gt;</span>adies, you know what I mean\n</pre>\n:::\n\n\n\nWe can extend this to capture the first word in a string, so long as it starts with an upper-case L:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"^L[a-zA-z]*\")\n```\n\n<pre>[33] │ <span style='color:#008080'>&lt;Lying&gt;</span> to your friends about\n[60] │ <span style='color:#008080'>&lt;Ladies&gt;</span>, you know what I mean\n</pre>\n:::\n\n\n\nOr we could do the same trick, but for the end of a string. The regular expression `\"f[a-zA-z]*$\"` will match to all lines in the text that end in a word beginning with a lower-case f. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"f[a-zA-z]*$\")\n```\n\n<pre> [4] │ Should've listened to your <span style='color:#008080'>&lt;friends&gt;</span>\n[15] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>\n[24] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[28] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[44] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>\n[53] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[57] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[65] │ Well, what we really need is a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[66] │ (A what?) A <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[72] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[82] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[86] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[92] │ Make a bitch, it's a fem, fem, fem, <span style='color:#008080'>&lt;fem&gt;</span>\n</pre>\n:::\n\n\n\nAbout 99% of my use of anchors is either `$` or `^` but there are other anchors. It varies across engines, but from an R perspective you can use `\\A` to match the start of a match group (i.e., it works simularly to `^`) and `\\Z` to match the end, similar to `$`. So this is another way of detecting the first word in a line, as long as it starts with `L`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"\\\\AL[a-zA-z]*\")\n```\n\n<pre>[33] │ <span style='color:#008080'>&lt;Lying&gt;</span> to your friends about\n[60] │ <span style='color:#008080'>&lt;Ladies&gt;</span>, you know what I mean\n</pre>\n:::\n\n\n\n### The backslash headache\n\nNotice that in the last section I used `\\A` in the text to refer to the anchor, but used `\"\\\\A\"` in the R string used to specify it. This is because R uses `\\` as the \"escape\" character, and so if you want to insert a literal `\\` into an R string then you need to escape it:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(\"\\\\A\")\n```\n\n<pre>\\A\n</pre>\n:::\n\n\n\nTo unpack it slightly more:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslashes <- c(\n  \"This R string contains a single literal backslash \\\\\", \n  \"This R string contains two literal backslashes, \\\\ and \\\\\",\n  \"This R string has one linebreak character \\n but no backslashes\"\n)\ncat(slashes, sep = \"\\n\")\n```\n\n<pre>This R string contains a single literal backslash \\\nThis R string contains two literal backslashes, \\ and \\\nThis R string has one linebreak character \n but no backslashes\n</pre>\n:::\n\n\n\nThe headache when using regular expressions is that `\\` is *also* the escape character in the regex. That is, if you want your regular expression to match a literal `\\`, then the regular expression itself needs to be `\\\\`. And if you want to describe it as an R string, then you need to escape both of those too, so the string that specifies the regular expression is now `\"\\\\\\\\\"`. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(\"\\\\\\\\\")\n```\n\n<pre>\\\\\n</pre>\n:::\n\n\n\nHere's what I mean:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(slashes, \"\\\\\\\\\", match = NA)\n```\n\n<pre>[1] │ This R string contains a single literal backslash <span style='color:#008080'>&lt;\\&gt;</span>\n[2] │ This R string contains two literal backslashes, <span style='color:#008080'>&lt;\\&gt;</span> and <span style='color:#008080'>&lt;\\&gt;</span>\n[3] │ This R string has one linebreak character \n    │  but no backslashes\n</pre>\n:::\n\n\n\n## Get me away I'm dying\n\n### Using backslash to escape\n\nCharacters that have special syntactic meaning need to be escaped if you want to treat them as literals. Quantifiers, for example:\n\n- write `\"\\\\+\"` in R to mean `\\+` in the regex and match a literal `+`\n- write `\"\\\\.\"` in R to mean `\\.` in the regex and match a literal `.`\n- write `\"\\\\?\"` in R to mean `\\?` in the regex and match a literal `?`\n- write `\"\\\\*\"` in R to mean `\\*` in the regex and match a literal `*`\n- write `\"\\\\{\"` in R to mean `\\{` in the regex and match a literal `{`\n\nIt obviously follows that since `\\` is used as the escape character it too must be escaped if you want to treat it as a literal:\n\n- write `\"\\\\\\\\\"` in R to mean `\\\\` in the regex and match a literal `\\`\n\nA little more subtle is the fact that *opening* (left) braces, brackets, and parentheses need to be escaped...\n\n- write `\"\\\\[\"` in R to mean `\\[` in the regex and match a literal `]`\n- write `\"\\\\(\"` in R to mean `\\(` in the regex and match a literal `]`\n- write `\"\\\\{\"` in R to mean `\\{` in the regex and match a literal `]`\n\nBut... while the same logic applies to a closing *parenthesis* `)`, it is *not* true for closing brackets `]` or braces `}`. Those two are treated as literals and should not be escaped:\n\n- write `\"]\"` in R to mean `]` in the regex and match a literal `]`\n- write `\"\\\\)\"` in R to mean `\\)` in the regex and match a literal `)`\n- write `\"}\"` in R to mean `}` in the regex and match a literal `}`\n\nThis is subtle enough that it's worth a couple of examples. Let's say I want to detect all instances of the bracketed literal text `[Chorus]` in the \"Feminomenon\" lyrics. I need to escape the opening bracket, so my regular expression begins with `\"\\\\[\"`, but I don't need to escape the closing bracket, so the regex ends with `\"]\"`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"\\\\[Chorus]\")\n```\n\n<pre>[20] │ <span style='color:#008080'>&lt;[Chorus]&gt;</span>\n[49] │ <span style='color:#008080'>&lt;[Chorus]&gt;</span>\n[78] │ <span style='color:#008080'>&lt;[Chorus]&gt;</span>\n</pre>\n:::\n\n\n\nHowever, if I want to match the literal text `(Get it hot)` I have to escape both of the parentheses, like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"\\\\(Get it hot\\\\)\")\n```\n\n<pre>[22] │ <span style='color:#008080'>&lt;(Get it hot)&gt;</span> Get it hot like Papa John\n[26] │ <span style='color:#008080'>&lt;(Get it hot)&gt;</span> Get it hot like Papa John\n[51] │ <span style='color:#008080'>&lt;(Get it hot)&gt;</span> Get it hot like Papa John\n[55] │ <span style='color:#008080'>&lt;(Get it hot)&gt;</span> Get it hot like Papa John\n[70] │ <span style='color:#008080'>&lt;(Get it hot)&gt;</span> Get it hot like Papa John\n[74] │ <span style='color:#008080'>&lt;(Get it hot)&gt;</span> Get it hot like Papa John\n[80] │ <span style='color:#008080'>&lt;(Get it hot)&gt;</span> Get it hot like Papa John\n[84] │ <span style='color:#008080'>&lt;(Get it hot)&gt;</span> Get it hot like Papa John\n</pre>\n:::\n\n\n\n## It gets messy\n\nThis gets messy quite quickly. Suppose I want to match every instance where text is enclosed in brackets or parentheses:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"(\\\\[[^\\\\]]*])|(\\\\([^)]*\\\\))\")\n```\n\n<pre> [1] │ <span style='color:#008080'>&lt;[Verse 1]&gt;</span>\n[13] │ <span style='color:#008080'>&lt;[Pre-Chorus]&gt;</span>\n[20] │ <span style='color:#008080'>&lt;[Chorus]&gt;</span>\n[21] │ <span style='color:#008080'>&lt;(Hit it like)&gt;</span> Hit it like rom-pom-pom-pom\n[22] │ <span style='color:#008080'>&lt;(Get it hot)&gt;</span> Get it hot like Papa John\n[23] │ <span style='color:#008080'>&lt;(Make a bitch)&gt;</span> Make a bitch go on and on\n[24] │ <span style='color:#008080'>&lt;(It's a fem)&gt;</span> It's a femininomenon\n[25] │ <span style='color:#008080'>&lt;(Hit it like)&gt;</span> Hit it like rom-pom-pom-pom\n[26] │ <span style='color:#008080'>&lt;(Get it hot)&gt;</span> Get it hot like Papa John\n[27] │ <span style='color:#008080'>&lt;(Make a bitch)&gt;</span> Make a bitch go on and on\n[28] │ <span style='color:#008080'>&lt;(It's a fem)&gt;</span> It's a femininomenon\n[30] │ <span style='color:#008080'>&lt;[Verse 2]&gt;</span>\n[42] │ <span style='color:#008080'>&lt;[Pre-Chorus]&gt;</span>\n[49] │ <span style='color:#008080'>&lt;[Chorus]&gt;</span>\n[50] │ <span style='color:#008080'>&lt;(Hit it like)&gt;</span> Hit it like rom-pom-pom-pom\n[51] │ <span style='color:#008080'>&lt;(Get it hot)&gt;</span> Get it hot like Papa John\n[52] │ <span style='color:#008080'>&lt;(Make a bitch)&gt;</span> Make a bitch go on and on\n[53] │ <span style='color:#008080'>&lt;(It's a fem)&gt;</span> It's a femininomenon\n[54] │ <span style='color:#008080'>&lt;(Hit it like)&gt;</span> Hit it like rom-pom-pom-pom\n[55] │ <span style='color:#008080'>&lt;(Get it hot)&gt;</span> Get it hot like Papa John\n... and 24 more\n</pre>\n:::\n\n\n\nTo unpack a little:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntests <- c(\n  \"[this should match] the bracketed part\",\n  \"(this should match) the parenthetical part\",\n  \"(this should [] match) the outer parenthetical\",\n  \"[this should () match] the outer brackets\",\n  \"[this should not match at all\",\n  \"[this should not match) at all\"\n)\nstr_view(tests, \"(\\\\[[^\\\\]]*])|(\\\\([^)]*\\\\))\")\n```\n\n<pre>[1] │ <span style='color:#008080'>&lt;[this should match]&gt;</span> the bracketed part\n[2] │ <span style='color:#008080'>&lt;(this should match)&gt;</span> the parenthetical part\n[3] │ <span style='color:#008080'>&lt;(this should [] match)&gt;</span> the outer parenthetical\n[4] │ <span style='color:#008080'>&lt;[this should () match]&gt;</span> the outer brackets\n</pre>\n:::\n\n\n\n## Oh no not another take\n\nA persistent headache I have when writing regular expressions, besides the fact that they suck, is that there are so many slight variations on the same idea. At [regular-expressions.info](https://regular-expressions.info), for instance, you can find quick lookup tables for a wide variety of different regular expression engines. It lists [regular expressions in R](https://www.regular-expressions.info/rlanguage.html) as one of those systems, but it's important to remember that this refers to the syntax used by base R tools like `grep()`, `gsub()`, `gregexpr()` and so on. Or, more precisely, it refers to the default POSIX standard for extended regular expressions. Base R actually supports two different engines, so if you set `perl = TRUE` when calling base R functions then you would need to look at the [rules for PCRE](https://www.regular-expressions.info/pcre.html). In tidyverse, regular expressions are usually handled with the [stringr](https://stringr.tidyverse.org/) package that is built on top of [stringi](https://stringi.gagolewski.com/), which in turn uses the [ICU](https://icu.unicode.org/) engine that conforms to Unicode standards and as such provides comprehensive Unicode support. The [stringi regular expressions](https://stringi.gagolewski.com/weave/regular_expressions.html) page has a nice discussion. \n\nLike an idiot, I forget this on a semi-regular basis, and I try to debug something by looking up the wrong regex syntax and yes, this sometimes matters. For instance, in the help documentation for regex in base R, you can find some discussion of various predefined POSIX classes (e.g., `\"[[:alpha:]]\"` matches alphabetic characters, `[[:digit:]]` matches numeric digits, and `\"[[:punct:]]\"` matches punctuation characters). However, different engines interpret these classes differently, which means you'll sometimes get different results depending on which engine you use.^[It also depends on the system locale. Not surprising, of course, but that does add to the sheer chaos of it all.]\n\nTo illustrate this I'll use an example that I have shamelessly stolen directly from the [stringi documentation](https://stringi.gagolewski.com/weave/regular_expressions.html#avoiding-posix-classes), in order to show how very differently `\"[[:punct:]]\"` is interpreted across the three most commonly used regex engines in R. But first, because I cannot even with the base R regular expression syntax,^[I mean, wtf. I am genuinely sympathetic to R core, and deeply appreciate their willingness to maintain backward compatibility even for the bits of R that are just bizarre. But oh my god.] I'll define a `base_extract_all()` function that is roughly analogous to `stringr::str_extract_all()`, but uses the base R functions to do the work:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_extract_all <- function(string, pattern, perl = FALSE) {\n  matches <- gregexpr(pattern = pattern, text = string, perl = perl)\n  regmatches(x = string, m = matches)\n}\n```\n:::\n\n\n\nNext, I'll define a string `punct` containing a lot of punctuation characters:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npunct <- \",./|\\\\<>?;:'\\\"[]{}-=_+()*&^%$€#@!`~×‒„”\"\n```\n:::\n\n\n\nSo, what happens when we match `punct` to `\"[[:punct:]]\"`? Well, it depends heavily on which engine you're using. If you're using ERE (i.e., base R with `perl = FALSE`), you get this as the result:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_extract_all(punct, \"[[:punct:]]\")\n```\n\n<pre>[[1]]\n [1] \",\"  \".\"  \"/\"  \"|\"  \"\\\\\" \"<span style='color:#008080'>&lt;\"  \"&gt;</span>\"  \"?\"  \";\"  \":\"  \"'\"  \"\\\"\" \"[\"  \"]\" \n[15] \"{\"  \"}\"  \"-\"  \"=\"  \"_\"  \"+\"  \"(\"  \")\"  \"*\"  \"&\"  \"^\"  \"%\"  \"$\"  \"€\" \n[29] \"#\"  \"@\"  \"!\"  \"`\"  \"~\"  \"×\"  \"‒\"  \"„\"  \"”\" \n</pre>\n:::\n\n\n\nWhat about PCRE? Let's set `perl = TRUE` and have a look:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_extract_all(punct, \"[[:punct:]]\", perl = TRUE)\n```\n\n<pre>[[1]]\n [1] \",\"  \".\"  \"/\"  \"|\"  \"\\\\\" \"<span style='color:#008080'>&lt;\"  \"&gt;</span>\"  \"?\"  \";\"  \":\"  \"'\"  \"\\\"\" \"[\"  \"]\" \n[15] \"{\"  \"}\"  \"-\"  \"=\"  \"_\"  \"+\"  \"(\"  \")\"  \"*\"  \"&\"  \"^\"  \"%\"  \"$\"  \"#\" \n[29] \"@\"  \"!\"  \"`\"  \"~\" \n</pre>\n:::\n\n\n\nOkay yeah that is not even close to being the same thing. But what about the ICU engine? If you're working in tidyverse, internally you're probably relying on this engine and, well...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_extract_all(punct, \"[[:punct:]]\")\n```\n\n<pre>[[1]]\n [1] \",\"  \".\"  \"/\"  \"\\\\\" \"?\"  \";\"  \":\"  \"'\"  \"\\\"\" \"[\"  \"]\"  \"{\"  \"}\"  \"-\" \n[15] \"_\"  \"(\"  \")\"  \"*\"  \"&\"  \"%\"  \"#\"  \"@\"  \"!\"  \"‒\"  \"„\"  \"”\" \n</pre>\n:::\n\n\n\nLe sigh. Of course. \n\n\n\n## I'm so sorry for my loss\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfeather <- read_lines(\"feather.txt\")\n\nrules <- tribble(\n              ~pattern, ~replacement,\n    \"([Dd]o)(-[Dd]o)+\",         \"🎶\", # do-do, do-do-do -> musical note\n             \"feather\",         \"🪶\", # feather -> emoji feather\n                \"wine\",         \"🍷\", # wine -> emoji wine\n         \"\\\\([Aa]h\\\\)\",      \"...😌\", # (ah) -> ...emoji relief\n  \"\\\\[([^\\\\[\\\\]]+)\\\\]\",          \"~\"  # replace square bracketed text\n)\n\nstr_rewrite <- function(string, rules) {\n  purrr::reduce2(\n    .x = rules$pattern, \n    .y = rules$replacement, \n    .f = str_replace_all, \n    .init = string\n  )\n}\n\nfeather |> \n  str_rewrite(rules) |> \n  cat(sep = \"\\n\")\n```\n\n<pre>~\n(🎶, 🎶, 🎶, 🎶)\n(🎶, 🎶, 🎶, 🎶)\nOh, not another take\n\n~\nOh, it's like that, I'm your dream come true\nWhen it's on a platter for you\nThen you pull back when I try to make plans\nMore than two hours in advance, mm\n\n~\nI slam the door, I hit ignore\nI'm saying, \"No, no, no, no more\"\nI got you blocked, after this, an afterthought\nI finally cut you off\n\n~\nI feel so much lighter like a 🪶 with you off my mind ...😌\nFloatin' through the memories like whatever, you're a waste of time ...😌\nYour signals are mixed, you act like a bitch\nYou fit every stereotype, \"Send a pic\"\nI feel so much lighter like a 🪶 with you out my life\nWith you out my life\n\n~\n(🎶, 🎶, 🎶, 🎶)\n(🎶, 🎶, 🎶, 🎶)\nLike a 🪶, like a 🪶, like a 🪶, yeah\n\n~\nIt feels so good\nNot carin' where you are tonight\nAnd it feels so good\nNot pretendin' to like the 🍷 you like\n\n~\nI slam the door (Slam the door), I hit ignore (Hit ignore)\nI'm saying, \"No, no, no, no more\"\nI got you blocked, excited to never talk, I\nI'm so sorry for your loss\n\n~\nI feel so much lighter like a 🪶 with you off my mind ...😌\nFloatin' through the memories like whatever, you're a waste of time ...😌\nYour signals are mixed, you act like a bitch (A bitch)\nYou fit every stereotype, \"Send a pic\"\nI feel so much lighter like a 🪶 with you out my life\nWith you out my life\n\n~\n(🎶, 🎶, 🎶, 🎶)\nAh, mm\n(🎶, 🎶, 🎶, 🎶)\nLike a 🪶, like a 🪶, like a 🪶\n\n~\nYou want me? I'm done\nYou miss me? No duh\nWhere I'm at, I'm up where I'm at\nYou want me? I'm done (I'm done)\nYou miss me? No duh (No duh)\nWhere I'm at, I'm up (I'm up) where I'm at\n\n~\nYou want me? I'm done\n(I feel so much lighter like a 🪶 with you off my mind)\nYou miss me? No duh\nWhere I'm at, I'm up where I'm at\n(Like a 🪶, like a 🪶, like a 🪶)\nYou want me? I'm done\n(I feel so much lighter like a 🪶 with you off my mind)\nYou miss me? No duh\nWhere I'm at, I'm up where I'm at\n(Like a 🪶, like a 🪶, like a 🪶, yeah)\n</pre>\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}