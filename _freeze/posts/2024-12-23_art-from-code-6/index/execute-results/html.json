{
  "hash": "a3492f9d15064b9a52a341d830341d45",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Art from code VI: Tiles and tessellations\"\ndescription: \"This is a subtitle\"\ndate: \"2024-12-23\"\ncategories: [\"R\", \"Art\"]\nimage: \"subdivision.png\"\n--- \n\n\n\n<!--------------- my typical setup ----------------->\n\n\n\n\n\n\n\n<!--------------- post begins here ----------------->\n\n(Adapted from my [Art From Code](https://art-from-code.netlify.app/day-2/session-2/) workshop)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(tibble)\nlibrary(ggplot2)\nlibrary(ggforce)\nlibrary(deldir)\nlibrary(ggthemes)\nlibrary(voronoise)\nlibrary(tictoc)\nlibrary(ambient)\nlibrary(purrr)\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(truchet)\nlibrary(sf)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsample_canva2 <- function(seed = NULL, n = 4) {\n  if(!is.null(seed)) set.seed(seed)\n  sample(ggthemes::canva_palettes, 1)[[1]] |>\n    (\\(x) colorRampPalette(x)(n))()  \n}\n```\n:::\n\n\n\n\n## Rectangle subdivision\n\nOne of my favourite generative artists in the R community is [Ijeamaka Anyene](https://ijeamaka-anyene.netlify.app/), partly because she's fabulous but also partly because her approach is so different to mine and she makes things I'd never think to try. She has a talent for designing colourful pieces in a minimalist, geometric style. Minimalism in art is not something I'm good at: I have a habit of overcomplicating my pieces! However, in this first section I'm going to resist the temptation to add complexity, and build a system inspired by Ijeamaka's recursive rectangle subdivision art. She has a [blog post](https://ijeamaka-anyene.netlify.app/posts/2021-09-07-so-you-want-to-subdivide-a-rectangle/) on her approach, by the way.\n\nRecursive rectangle subdivisions come up a lot in real life. Suppose you have a parcel of land and want to divide it in two parts A and B. In doing so you create a boundary. Later, land unit A wants to divide: this adds a new boundary, splitting A into A1 and A2, but leaving unit B untouched. If this process repeats often enough, you end up with subdivisions that have a very recognisable structure. Here's a subdivision depicting a [1939 land use survey map for a part of the San Fernando valley in Los Angeles](https://picryl.com/media/wpa-land-use-survey-map-for-the-city-of-los-angeles-book-3-san-fernando-valley-00c11b)\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](wpa-land-use-survey-map.jpg){fig-align='center' width=512}\n:::\n:::\n\n\n\nLet's design a generative art system that mimics this process. Suppose we have some data frame `blocks` where each row represents one rectangular block, and one of the columns it stores is the `area` of that rectangle. Now imagine that our subdivision process deliberately targets larger blocks: the probability of choosing the a block for subdivision is proportional to its area. The `choose_rectangle()` function below takes the `blocks` data frame as input, and randomly selects a row with probability proportional to `blocks$area`. It returns the row number for the selected rectangle:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchoose_rectangle <- function(blocks) {\n  sample(nrow(blocks), 1, prob = blocks$area)\n}\n```\n:::\n\n\n\nFor this system we assume that you can only subdivide a rectangle in one of two ways: horizontally, or vertically. We aren't going to allow diagonal lines or anything that would produce other kinds of polygons. The input to a subdivision is a rectangle, and the output should be two rectangles. \n\nIf we're going to do that, we need to select a \"break point\". The `choose_break()` function will do that for us. It takes a `lower` and `upper` value as input, and returns a value (expressed as the distance from the `lower` boundary) specifying where the break is inserted:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchoose_break <- function(lower, upper) {\n  round((upper - lower) * runif(1))\n}\n```\n:::\n\n\n\nNotice that I've called `round()` here to ensure that the outputs will always be integer value. As a consequence, all of our subdivisions will line up on a grid of some kind: that comes in handy later if, for example, we want to plot the result as a bitmap or a raster object. \n\nNext, we need a function that can subdivide a rectangle! For the moment, let's assume that we're splitting horizontally, so in a moment we'll write a function called `split_rectangle_x()` to do this for us. It's going to take a `rectangle` as the main argument, which is presumably going to be a tibble that contains columns that define a rectangle. To make life a little simpler, here's a convenience function `create_rectangles()` that creates this tibble for us:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_rectangles <- function(left, right, bottom, top, value) {\n  tibble(\n    left = left,\n    right = right,\n    bottom = bottom,\n    top = top,\n    width = right - left,\n    height = top - bottom,\n    area = width * height,\n    value = value\n  )\n}\n```\n:::\n\n\n\nNote that this function can create multiple rectangles. It doesn't check to see if the rectangles overlap, though. If I wanted to write rigorous code I would probably prevent it from allowing rectangles to overlap, but I'm not being super rigorous here. It's not production code!\n\nAnyway, here are a couple of rectangles that represent a vertical split, where one of them sits above the other:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrect <- create_rectangles(\n  left = 1, \n  right = 10, \n  bottom = c(1, 4), \n  top = c(4, 10),\n  value = 1:2\n)\nrect\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 8\n   left right bottom   top width height  area value\n  <dbl> <dbl>  <dbl> <dbl> <dbl>  <dbl> <dbl> <int>\n1     1    10      1     4     9      3    27     1\n2     1    10      4    10     9      6    54     2\n```\n\n\n:::\n:::\n\n\n\nNow we can write our horizontal subdivision function, `split_rectangle_x()`, and it's vertical counterpart  `split_rectangle_y()`. Each of these takes a single `rectangle` as input, calls `choose_break()` to determine where the break point should be, and then creates two new rectangles that will replace the old one. When called, they'll automatically recalculate the width, height, and areas for both rectangles. The `value` of the first rectangle (the one to the left or on the lower side) remains unchanged, and and the `new_value` argument is used to assign a value to the second rectangle:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsplit_rectangle_x <- function(rectangle, new_value) {\n  with(rectangle, {\n    split <- choose_break(left, right)\n    new_left  <- c(left, left + split)\n    new_right <- c(left + split, right)\n    new_value <- c(value, new_value)\n    create_rectangles(new_left, new_right, bottom, top, new_value)\n  })\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsplit_rectangle_y <- function(rectangle, new_value) {\n  with(rectangle, {\n    split <- choose_break(bottom, top)\n    new_bottom <- c(bottom, bottom + split)\n    new_top <- c(bottom + split, top)\n    new_value <- c(value, new_value)\n    create_rectangles(left, right, new_bottom, new_top, new_value)\n  })\n}\n```\n:::\n\n\n\nWhile we are here, we can write a `split_rectangle()` function that randomly decides whether to split horizontally or vertically, and then calls the relevant function to do the splitting:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsplit_rectangle <- function(rectangle, value) {\n  if(runif(1) < .5) {\n    return(split_rectangle_x(rectangle, value))\n  }\n  split_rectangle_y(rectangle, value)\n}\n```\n:::\n\n\n\nHere it is in action:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\nsplit_rectangle(rectangle = rect[1, ], value = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 8\n   left right bottom   top width height  area value\n  <dbl> <dbl>  <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl>\n1     1     4      1     4     3      3     9     1\n2     4    10      1     4     6      3    18     3\n```\n\n\n:::\n:::\n\n\n\nNotice that it is possible to create a block with zero area. That's okay: that block will never be selected for later subdivision. We could filter out all zero-area rectangles if we wanted to, but I'm too lazy to bother!\n\nNow we are in a position to define a function called `split_block()` that takes `block`, a tibble of one or more rectangles as input, selects one to be subdivided using `choose_rectangle()`, and then splits it with `split_rectangle()`. The old, now-subdivided rectangle is removed from the `block`, the two new ones are added, and the updated block of rectangles is returned:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsplit_block <- function(blocks, value) {\n  old <- choose_rectangle(blocks) \n  new <- split_rectangle(blocks[old, ], value)\n  bind_rows(blocks[-old, ], new)\n}\n```\n:::\n\n\n\nHere it is at work:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsplit_block(rect, value = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 8\n   left right bottom   top width height  area value\n  <dbl> <dbl>  <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl>\n1     1    10      1     4     9      3    27     1\n2     1    10      4     5     9      1     9     2\n3     1    10      5    10     9      5    45     3\n```\n\n\n:::\n:::\n\n\n\nNow that we have a `create_rectangles()` function that can generate a new rectangle and a `split_block()` function that can pick one rectangle and split it, we can write `subdivision()` function quite succinctly. We repeatedly apply the `split_block()` function until it has created enough splits for us. I could write this as a loop, but it feels more elegant to me to use the `reduce()` function from the purrr package to do this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubdivision <- function(ncol = 1000, \n                        nrow = 1000, \n                        nsplits = 50, \n                        seed = NULL) {\n  \n  if(!is.null(seed)) set.seed(seed)\n  blocks <- create_rectangles(\n    left = 1, \n    right = ncol, \n    bottom = 1, \n    top = nrow, \n    value = 0\n  )\n  reduce(1:nsplits, split_block, .init = blocks)\n}\n\nsubdivision(nsplits = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 8\n   left right bottom   top width height   area value\n  <dbl> <dbl>  <dbl> <dbl> <dbl>  <dbl>  <dbl> <dbl>\n1     1  1000    661  1000   999    339 338661     1\n2     1   207      1   661   206    660 135960     0\n3   207  1000    255   661   793    406 321958     3\n4   207   776      1   255   569    254 144526     2\n5   776   950      1   255   174    254  44196     4\n6   950  1000      1   255    50    254  12700     5\n```\n\n\n:::\n:::\n\n\n\nAs you can see, in this version of the system I've arranged it so that the `value` column represents the iteration number upon which the corresponding rectangle was created.\n\nFinally we get to the part where we make art! The `develop()` function below uses `geom_rect()` to draw the rectangles, mapping the `value` to the fill aesthetic:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndevelop <- function(div, seed = NULL) {\n  \n  div |> \n    ggplot(aes(\n      xmin = left, \n      xmax = right, \n      ymin = bottom, \n      ymax = top,\n      fill = value\n    )) +\n    geom_rect(\n      colour = \"#ffffff\", \n      size = 3,\n      show.legend = FALSE\n    ) +\n    scale_fill_gradientn(\n      colours = sample_canva2(seed)\n    ) +\n    coord_equal() +\n    theme_void() +\n    theme(\n      plot.background = element_rect(\n        fill = \"#ffffff\"\n      )\n    ) \n}\n\nsubdivision(seed = 1) |> develop() \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/rectangle-subdivision-1.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\nThe uneven spacing here is not accidental. Because the rectangles are plotted with a thick white border, and plotted against a white background, very thin rectangles are invisible. That leads to a slightly irregular pattern among the visible rectangles. I quite like it!\n\nHere are a few more outputs from the system:\n\n\n\n::: {.cell .column-screen-inset layout-ncol=\"3\" layout-align=\"center\"}\n\n```{.r .cell-code}\nsubdivision(nsplits = 100, seed = 123) |> develop()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/subdivision-extras-1.png){fig-align='center' width=1800}\n:::\n\n```{.r .cell-code}\nsubdivision(nsplits = 200, seed = 102) |> develop()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/subdivision-extras-2.png){fig-align='center' width=1800}\n:::\n\n```{.r .cell-code}\nsubdivision(nsplits = 500, seed = 103) |> develop()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/subdivision-extras-3.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\n::: {.callout-important icon=false #exercise-subdivision}\n## Exercise\n\nCode for this system is included in the `subdivision.R` script.\n\n:::\n\n\n\n## Mosaica\n\nRemember earlier when I said I have this compulsive tendency to make my generative art systems unnecessarily elaborate? I was not lying. Now that I've created this simple and clean `subdivision()` system my first instinct is to use it as the basis for something more complicated. The `fill_rectangle()` function below takes a single rectangle as input, divides it into a grid of squares with edge length 1, and then assigns each of those squares a `fill` value generated with a randomly sampled fractal (using the ambient package to do the work):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfill_rectangle <- function(left, right, bottom, top, width, \n                           height, area, value, nshades = 100) {\n  \n  set.seed(value)\n  fractals <- list(billow, fbm, ridged)\n  generators <- list(gen_simplex, gen_perlin, gen_worley)\n  \n  expand_grid(\n    x = left:right, \n    y = bottom:top, \n  ) |>\n    mutate(\n      fill = 10 * value + fracture(\n        x = x * sample(-3:3, 1),\n        y = y * sample(-3:3, 1),\n        noise = sample(generators, 1)[[1]],\n        fractal = sample(fractals, 1)[[1]],\n        octaves = sample(10, 1),\n        frequency = sample(10, 1) / 20,\n        value = \"distance2\"\n      ) |>\n        normalise(to = c(1, nshades)) |> \n        round()\n    )\n}\n```\n:::\n\n\n\nI'll also write a `draw_mosaic()` function that plots a collection of these unit-square sized tiles:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndraw_mosaic <- function(dat, palette) {\n  background <- sample(palette, 1)\n  dat |>\n    ggplot(aes(x, y, fill = fill)) +\n    geom_tile(show.legend = FALSE, colour = background, size = .2) +\n    scale_size_identity() +\n    scale_colour_gradientn(colours = palette) +\n    scale_fill_gradientn(colours = palette) +\n    scale_x_continuous(expand = expansion(add = 5)) +\n    scale_y_continuous(expand = expansion(add = 5)) +\n    coord_equal() +\n    theme_void() +\n    theme(plot.background = element_rect(fill = background)) \n}\n```\n:::\n\n\n\nWhen combined with the original `subdivision()` function I can now write a generative art system called `mosaica()` that uses `subdivision()` to partition a grid into rectangular units, then applies `fill_rectangle()` to separate each of these rectangles into unit squares and fill each of these squares with a colour based on a spatial noise pattern generated using ambient. Then it draws a picture:\n\n\n\n::: {.cell .column-screen-inset layout-align=\"center\"}\n\n```{.r .cell-code}\nmosaica <- function(ncol = 60, \n                    nrow = 60, \n                    nsplits = 30, \n                    seed = NULL) {\n  \n  subdivision(ncol, nrow, nsplits, seed) |>\n    pmap_dfr(fill_rectangle) |> \n    slice_sample(prop = .995) |>\n    filter(!is.na(fill)) |>\n    draw_mosaic(palette = sample_canva2(seed))\n}\n\nmosaica(ncol = 200, nrow = 100, nsplits = 200, seed = 1302)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/mosaica-1.png){fig-align='center' width=6000}\n:::\n:::\n\n\n\nIt makes me happy :)\n\n\n\n::: {.cell .column-screen-inset layout-ncol=\"3\" layout-align=\"center\"}\n\n```{.r .cell-code}\nmosaica(seed = 1977)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/mosaica-extras-1.png){fig-align='center' width=1800}\n:::\n\n```{.r .cell-code}\nmosaica(seed = 2022)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/mosaica-extras-2.png){fig-align='center' width=1800}\n:::\n\n```{.r .cell-code}\nmosaica(seed = 1969)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/mosaica-extras-3.png){fig-align='center' width=1800}\n:::\n:::\n\n::: {.cell .column-screen-inset layout-ncol=\"3\" layout-align=\"center\"}\n\n```{.r .cell-code}\nmosaica(nrow = 100, seed = 1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/even-more-mosaica-1.png){fig-align='center' width=1800}\n:::\n\n```{.r .cell-code}\nmosaica(nrow = 100, seed = 2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/even-more-mosaica-2.png){fig-align='center' width=1800}\n:::\n\n```{.r .cell-code}\nmosaica(nrow = 100, seed = 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/even-more-mosaica-3.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\n\n::: {.callout-important icon=false #exercise-mosaica}\n## Exercise\n\nCode for this system is included in the `mosaica.R` script.\n\n:::\n\n\n## Voronoi tesselation\n\nLet's switch gears a little. So far we've only looked at rectangular tilings, but there are many other ways to tile a two dimensional plane. One method for constructing an irregular tiling -- one that generative artists are especially fond of -- is to generate a collection of points and then computing the [Voronoi tesselation](https://en.wikipedia.org/wiki/Voronoi_diagram) (also known as a Voronoi diagram) of those points. Wikipedia definitions are, once again, helpful:\n\n> A Voronoi diagram is a partition of a plane into regions close to each of a given set of objects. In the simplest case, these objects are just finitely many points in the plane (called seeds, sites, or generators). For each seed there is a corresponding region, called a Voronoi cell, consisting of all points of the plane closer to that seed than to any other.\n\nExtremely conveniently for our purposes, the ggforce package provides two handy geom functions -- `geom_voronoi_segment()` and `geom_voronoi_tile()` -- that plot the Voronoi tesselation for a set of points. All you have to do as the user is specify the `x` and `y` aesthetics (corresponding to the coordinate values of the points), and ggplot2 will do all the work for you. Let's see what we can do using these tools!\n\nIn the beginning there were points...\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(61)\ndat <- tibble(\n  x = runif(20),\n  y = runif(20),\n  val = runif(20)\n)\n\npic <- ggplot(dat, aes(x, y, fill = val)) +\n  coord_equal(xlim = c(-.3, 1.3), ylim = c(-.3, 1.3)) +\n  guides(fill = guide_none()) +\n  theme_void()\n\npic + geom_point(colour = \"white\", size = 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/voronoi-points-1.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\nThe points themselves are not very artistically impressive, but we can make something more interesting if we add the Voronoi tesselation. The minimal way to do this is with `geom_voronoi_segment()`\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npic + \n  geom_voronoi_segment(colour = \"white\") + \n  geom_point(colour = \"white\", size = 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/voronoi-segments-1.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\nWe can already see the beginnings of something pleasing. I mean, if I'm being honest this is already quite pretty in a minimalist way but -- as I keep saying -- I have an urge to tinker and see what elaborations we can add. First, let's switch from `geom_voronoi_segment()` to `geom_voronoi_tile()`:  \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npic + \n  geom_voronoi_tile(colour = \"white\") + \n  geom_point(colour = \"white\", size = 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/voronoi-tiles-1.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\nSetting the `max.radius` argument prevents any tile extending beyond a fixed distance from the point generating the tile, giving the image as a whole a \"bubbly\" look:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npic + \n  geom_voronoi_tile(colour = \"white\", max.radius = .2) + \n  geom_point(colour = \"white\", size = 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/voronoi-tiles-max-size-1.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\nHm. Those sharp corners between tiles aren't the prettiest thing I've ever seen. Let's round those corners a little bit, shall we? The `radius` argument lets us do that:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npic + \n  geom_voronoi_tile(\n    colour = \"white\", \n    max.radius = .2, \n    radius = .02 \n  ) + \n  geom_point(colour = \"white\", size = 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/voronoi-tiles-round-corners-1.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\nNext, let's shrink all the tiles a tiny bit to create small gaps between adjacent tiles:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npic + \n  geom_voronoi_tile(\n    colour = \"white\", \n    max.radius = .2, \n    radius = .02,\n    expand = -.005\n  ) + \n  geom_point(colour = \"white\", size = 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/voronoi-tiles-shrink-1.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\nLet's remove the points themselves, leaving only the rounded tiles:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npic + \n  geom_voronoi_tile(\n    colour = \"white\", \n    max.radius = .2, \n    radius = .02,\n    expand = -.005\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/voronoi-tiles-only-1.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\nFinally, we'll create another tiling and use it as a background texture:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbg_dat <- tibble(\n  x = runif(500, min = -.5, max = 1.5),\n  y = runif(500, min = -.5, max = 1.5)\n)\npic + \n  geom_voronoi_tile(\n    data = bg_dat,\n    fill = \"#333333\", \n    radius = .01,\n    expand = -.0025\n  ) +\n  geom_voronoi_tile(\n    colour = \"white\", \n    max.radius = .2, \n    radius = .02,\n    expand = -.005\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/voronoi-tiles-double-1.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\n\n::: {.callout-important icon=false #exercise-voronoi-tiles}\n## Exercise\n\nA script reproducing this piece is included in the `voronoi-tiles.R` file\n\n:::\n\n\n## Studies in Voronoi baroque: Part I\n\nWhen I first started playing around with Voronoi tesselations the pieces I made looked a lot like the worked example: the [Voronoise](https://art.djnavarro.net/gallery/voronoise/) series I posted on my art site contains pieces that look like the one above, generated from random collections of points. What I started realising a little later is that if you feed a structured set of points into your Voronoi tesselations, you can create some very elaborate patterns. I've played around with this idea in a few series (my favourite so far is [Sadists Kiss](https://art.djnavarro.net/gallery/sadists-kiss/)).\n\nI'll illustrate the approach by reusing an earlier system. The `unboxy()` function shown below reimplements the \"unboxing\" system that I talked about in the section on iterated function systems:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunboxy <- function(iterations, layers) {\n  \n  coeffs <- array(\n    data = runif(9 * layers, min = -1, max = 1), \n    dim = c(3, 3, layers)\n  )\n  \n  point0 <- matrix(\n    data = runif(3, min = -1, max = 1), \n    nrow = 1,\n    ncol = 3\n  )\n  \n  funs <- list(\n    function(point) point + (sum(point ^ 2)) ^ (1/3),\n    function(point) sin(point),\n    function(point) 2 * sin(point)\n  )\n  \n  update <- function(point, t) {\n    l <- sample(layers, 1)\n    f <- sample(funs, 1)[[1]]\n    z <- point[3]\n    point[3] <- 1\n    point <- f(point %*% coeffs[,,l])\n    point[3] <- (point[3] + z)/2\n    return(point)\n  }\n  \n  points <- accumulate(1:iterations, update, .init = point0)\n  points <- matrix(unlist(points), ncol = 3, byrow = TRUE)\n  points <- as_tibble(as.data.frame(points)) \n  names(points) <- c(\"x\", \"y\", \"val\")\n  return(points)\n}\n```\n:::\n\n\n\nI'm not going to explain the inner workings of this function here (because they're already discussed elsewhere), but in case you need a refresher or haven't read the relevant page, here's a look at the kinds of data this function produces, and a scatterplot showing the very non-random spatial patterns it generates:\n\n\n\n::: {.cell layout-ncol=\"2\" layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(1)\ndat <- unboxy(iterations = 1000, layers = 5) \n\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,001 × 3\n        x       y     val\n    <dbl>   <dbl>   <dbl>\n 1  0.579  0.236   0.666 \n 2 -1.95   0.935  -0.0757\n 3 -0.884  1.09    0.672 \n 4 -0.929  2.04    0.401 \n 5  0.861  1.44    2.01  \n 6  0.404  1.29    1.46  \n 7  0.826  0.834  -0.909 \n 8  0.999 -2.00    1.94  \n 9  0.850  0.0301  1.61  \n10 -1.80   1.38   -0.381 \n# ℹ 991 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot(dat, aes(x, y)) + \n  geom_point(colour = \"white\", show.legend = FALSE) +\n  coord_equal(xlim = c(-2.5, 2.5), ylim = c(-2.5, 2.5)) + \n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/scatterplot-boxy-1.png){fig-align='center' width=1200}\n:::\n:::\n\n\n\nNow let's plot the Voronoi tesselation corresponding to these points, once again relying on our old friend `sample_canva2()` to generate the palette:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npic <- ggplot(dat, aes(x, y, fill = val)) +\n  theme_void() + \n  coord_equal(xlim = c(-2.5, 2.5), ylim = c(-2.5, 2.5)) + \n  scale_fill_gradientn(colours = sample_canva2()) + \n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0))\n\npic +\n  geom_voronoi_tile(\n    colour = \"#222222\",\n    size = .2, \n    show.legend = FALSE\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/voronoi-boxy-1.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\nRounding the corners and expanding the tiles gives the piece a different feel...\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npic +\n  geom_voronoi_tile(\n    radius = .01,\n    expand = .01,\n    colour = \"#222222\",\n    size = .2, \n    show.legend = FALSE\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/voronoi-boxy-2-1.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\nSo does this...\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npic +\n  geom_voronoi_tile(\n    max.radius = .1,\n    radius = .01,\n    expand = -.0001,\n    colour = \"#222222\",\n    size = .2, \n    show.legend = FALSE\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/voronoi-boxy-3-1.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\nThe possibilities are surprisingly rich, and quite a lot of fun to play around with!\n\n\n::: {.callout-important icon=false #exercise-voronoi-unbox}\n## Exercise\n\nA script containing code for this system is included in the materials folder, as the `voronoi-unbox.R` file\n\n:::\n\n\n\n## Studies in Voronoi baroque: Part II\n\nOkay, I need to confess something. Voronoi tiling art was the thing that finally pushed me to learn the [ggproto object oriented programming system](https://ggplot2.tidyverse.org/articles/extending-ggplot2.html) used by ggplot2. It's not because I'm a masochist and enjoy the pain of learning an OOP system that isn't used for anything except ggplot2. No-one is that much of a masochist, surely. No, it was because I wanted the ability to intercept and modify the Voronoi tiles during the plot construction process. Because... yeah, I don't even remember why I wanted that. Evil reasons, probably.\n\nEnter stage left, the [voronoise package](https://voronoise.djnavarro.net/). It's not on CRAN -- because I can't think of a single good reason to send it to CRAN -- but you can install it from GitHub with\n\n``` r\nremotes::install_github(\"djnavarro/voronoise\")\n```\n\nThe voronoise package only does one thing: it supplies `geom_voronoise()`, a geom that behaves just like `geom_voronoi_tile()` except for the fact you can pass it a \"perturbing function\" that modifies the tiles. Annoyingly -- because I was not a very good software developer at the time and I was not thinking about what someone else (i.e., future me) would use it for later -- the default arguments to `geom_voronoise()` aren't the same as the defaults for `geom_voronoi_tile()`, which means it's a good idea to explicitly specify things like `max.radius` etc even if you're \"just going to use the defaults\". Sorry. That was my mistake. I cannot stress enough that voronoise is not a good package. But... it'll do for my purposes today.\n\nHere's a simple example where the `perturb` argument is used to shift all the tiles to the right by a random offset:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npic +\n  geom_voronoi_tile( # original tiling in grey\n    max.radius = .1,\n    radius = .01,\n    expand = -.0001,\n    fill = \"#444444\",\n    colour = \"#222222\",\n    size = .2, \n    show.legend = FALSE\n  ) +\n  voronoise::geom_voronoise( # perturbed tiling\n    max.radius = .1,\n    radius = .01,\n    expand = -.0002,\n    perturb = \\(data) data |> \n      group_by(group) |> \n      mutate(x = x + runif(1, min = 0, max = .2)), \n    show.legend = FALSE\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/geom-voronoise-1.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\nThat's kind of neat. Another approach I've been fond of in the past is to use something like this `sift()` function, which computes a crude approximation to the area of each tile and perturbs only those tiles smaller than a certain size:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsift <- function(data) {\n  data <- data |>\n    group_by(group) |>\n    mutate(\n      tilesize = (max(x) - min(x)) * (max(y) - min(y)),\n      x = if_else(tilesize > .02, x, x + rnorm(1)/10), \n      y = if_else(tilesize > .02, y, y + rnorm(1)/10)\n    ) |>\n    ungroup()\n  return(data)\n}\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nvoronoi_baroque <- function(\n    seed, \n    perturb, \n    max.radius = NULL, \n    radius = 0, \n    expand = 0,\n    ...\n) {\n  \n  set.seed(seed)\n  \n  blank <- ggplot(mapping = aes(x, y, fill = val)) +\n    theme_void() + \n    coord_equal(xlim = c(-2.75, 2.75), ylim = c(-2.75, 2.75)) + \n    guides(fill = guide_none(), alpha = guide_none()) +\n    scale_fill_gradientn(colours = sample_canva2(seed)) + \n    scale_alpha_identity() + \n    scale_x_continuous(expand = c(0, 0)) +\n    scale_y_continuous(expand = c(0, 0))\n  \n  blank + \n    geom_voronoise(\n      data = unboxy(iterations = 10000, layers = 5),\n      perturb = perturb,\n      max.radius = max.radius,\n      radius = radius,\n      expand = expand,\n      ...,\n      show.legend = FALSE\n    )\n}\n```\n:::\n\n::: {.cell .column-screen-inset layout-ncol=\"3\"}\n\n```{.r .cell-code}\nvoronoi_baroque(1234, sift)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/voronoi-baroque-sift-1.png){width=1800}\n:::\n\n```{.r .cell-code}\nvoronoi_baroque(4000, sift)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/voronoi-baroque-sift-2.png){width=1800}\n:::\n\n```{.r .cell-code}\nvoronoi_baroque(2468, sift)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/voronoi-baroque-sift-3.png){width=1800}\n:::\n:::\n\n\n\nThe fun thing about `voronoi_baroque()` is that you can write whatever perturbation function you like... up to a point, of course. I cannot stress enough that the voronoise package is not particularly reliable! \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshake <- function(data) {\n  data |> \n    group_by(group) |>\n    mutate(\n      x = x + runif(1)/10, \n      y = y + runif(1)/10\n    ) |>\n    ungroup()\n}\n```\n:::\n\n::: {.cell .column-screen-inset layout-ncol=\"3\" layout-align=\"center\"}\n\n```{.r .cell-code}\nvoronoi_baroque(21, shake)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/voronoi-baroque-shake-1.png){fig-align='center' width=1800}\n:::\n\n```{.r .cell-code}\nvoronoi_baroque(43, shake)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/voronoi-baroque-shake-2.png){fig-align='center' width=1800}\n:::\n\n```{.r .cell-code}\nvoronoi_baroque(17, shake)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/voronoi-baroque-shake-3.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\n::: {.callout-important icon=false #exercise-voronoi-baroque}\n## Exercise\n\nCode for this system is included in the `voronoi-baroque.R` script.\n\n:::\n\n\n\n## Truchet tiles\n\nOne final topic to mention before: [truchet tiles](https://en.wikipedia.org/wiki/Truchet_tiles). Truchet tiles are square tiles decorated with asymmetric patterns, designed so that whenever you lay them out randomly, the patterns will connect up in aesthetically pleasing ways. To be honest, I've not explore them much myself but Antonio Páez has written the [truchet package](https://paezha.github.io/truchet/) that you can use to play with these. It's not currently on CRAN, but you can install from GitHub with:\n\n``` r\nremotes::install_github(\"paezha/truchet\")\n```\n\nThe basic idea in the truchet package is to represent the patterns compactly as a geometry column. If you're  familiar with the [sf package](https://r-spatial.github.io/sf/) this sort of output will be familiar to you:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nmosaic <- st_truchet_ms(\n  tiles = c(\"dr\", \"tn\", \"ane\"), \n  p1 = 0.2, # scale 1 \n  p2 = 0.6, # scale 2\n  p3 = 0.2, # scale 3\n  xlim = c(1, 6),\n  ylim = c(1, 6)\n)\nmosaic\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 797 features and 1 field\nGeometry type: GEOMETRY\nDimension:     XY\nBounding box:  xmin: 0.1666667 ymin: 0.1666667 xmax: 6.833333 ymax: 6.833333\nCRS:           NA\nFirst 10 features:\n   color                       geometry\n1      1 MULTIPOLYGON (((0.8292294 5...\n2      2 POLYGON ((0.4956387 6.16655...\n3      2 POLYGON ((0.8340757 5.53053...\n4      1 MULTIPOLYGON (((2.829229 2....\n5      2 POLYGON ((2.495639 3.166552...\n6      2 POLYGON ((2.834076 2.530531...\n7      1 MULTIPOLYGON (((1.829229 2....\n8      2 MULTIPOLYGON (((2.164615 2....\n9      1 POLYGON ((2.5 1.166667, 2.4...\n10     2 POLYGON ((2.833333 0.5, 2.8...\n```\n\n\n:::\n:::\n\n\n\nIf you're not familiar, the key things to note are that the `geometry` column stores the pattern as a polygon (or collection of polygons), and that `geom_sf()` understands this geometry column. So you can use code like this to plot your truchet tiling:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmosaic |> \n  ggplot(aes(fill = color)) +\n  geom_sf(color = NA, show.legend = FALSE) + \n  scale_fill_gradientn(colours = c(\"#222222\", \"#ffffff\")) + \n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/first-truchet-1.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\nIn this example you'll notice that I don't actually specify a mapping for `geometry`. That's a little unusual for ggplot2, but it is standard to name the column containing a \"simple features geometry\" as `geometry`, so `geom_sf()` will look for a column by that name. \n\nThat's about all I wanted to mention about the truchet package. It makes pretty things and you can check out the package website for more information :)\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(123)\nst_truchet_ss(\n  tiles = c(\n    \"silk_1\", \"silk_2\", \n    \"rainbow_1\", \"rainbow_2\",\n    \"cloud_1\", \"cloud_2\"\n  ),\n  xlim = c(1, 9),\n  ylim = c(1, 6)\n) |>\n  ggplot() +\n  geom_sf(colour = \"white\") +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0)) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/second-truchet-1.png){fig-align='center' width=2700}\n:::\n:::\n\n\n\n\n::: {.callout-important icon=false #exercise-truchet}\n## Exercise\n\nExample code for truchet tiles is included in the `truchet-example.R` script.\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}