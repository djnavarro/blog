{
  "hash": "c1e42025bf6cb2c9e229bbc88636ef98",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Baby got backreferences\"\ndescription: \"Now I have \\\\\\\\2 problems\"\ndate: \"2024-12-16\"\nimage: \"babygotback1.jpg\"\n--- \n\n\n\n<!--------------- my typical setup ----------------->\n\n\n\n\n\n\n\n::: {.cell}\n<style type=\"text/css\">\n@import url('https://fonts.googleapis.com/css2?family=Tangerine:wght@400;700&display=swap');\n\n.tangerine-regular {\n  font-family: \"Tangerine\", cursive;\n  font-weight: 400;\n  font-style: normal;\n}\n\n.tangerine-bold {\n  font-family: \"Tangerine\", cursive;\n  font-weight: 700;\n  font-style: normal;\n}\n</style>\n:::\n\n\n\n<!--------------- post begins here ----------------->\n\nAt least once a week I experience a particular kind of despair that is all to familiar to programmers. I am sitting alone with my laptop and my code, minding my own business, working quietly. Out of nothing a yawning pit of black despair opens at my feet, barbed tentacles wrap around my legs, poison injects chill into my veins, the icy claws of anxiety rip through my viscera, and a withered voice of pure evil slithers into my brain. The voice speaks to me in the disturbingly-seductive language of Mordor, and a terrible incantation consumes my thoughts:\n\n<p class=\"tangerine-bold\" align=\"center\" style=\"font-size: 28pt\">why not write a regular expression?</p>\n\nI try to resist. I'm a good girl, I tell the Dark Lord. I would never. Not on a first date anyway. Well, buy a girl a drink first maybe? And... oh it's so cold outside and, I mean, Sauron is kinda hot. Have you not watched Rings of Power? Sometimes a girl has needs.\n\nUm. Anyway. What was I talking about? Oh, right. [Regular expressions](https://www.regular-expressions.info/).\n\n\n![You don't have the look of someone to whom regular expressions happen by accident](sauron.jpg)\n\n<br>\n\n## Warning\n\nLet's start this love affair with darkness with a disclaimer: I have *never* wanted to write a primer on working with regular expressions in R. I loathe regular expressions, and I am not good at them. About 99% of my knowledge of regular expressions comes from weeping in abject despair with a dozen R documentation tabs open and desperately clicking on random links at [www.regular-expressions.info](https://www.regular-expressions.info) to work out why my regex doesn't work. \n\nI am, very clearly, not an expert. \n\nSo why am I, a grotesquely unqualified woman, writing this post anyway? Honestly, the answer is because __this post is the tutorial that I need__. I'm writing this as an act of solidarity with future Danielle, who will find inevitably herself crying at her keyboard trying to make a basic regex work, and will need a little kindness and support. With that in mind, and knowing exactly who will be revisiting this post in six months time in tears... you got this girl. I believe in you. \n\nLet's get started. In this post I'll be working mostly with the stringr package, so I'll load that at the beginning:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr)\n```\n:::\n\n\n\nI'll use a variety of sources for the text, mostly song lyrics. Each of those is stored in a text file so I'll read the text now:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfeather <- brio::read_lines(\"feather.txt\")\nfemininomenon <- brio::read_lines(\"femininomenon.txt\")\nmidnight <- brio::read_lines(\"midnight.txt\")\nbabygotback <- brio::read_lines(\"babygotback.txt\")\n```\n:::\n\n\n\nEach of these is a vector of strings. To give you a sense of what they look like, here's the first few lines in the opening to `babygotback`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(babygotback)\n```\n\n<pre>[1] \"[Intro: Girl]\"                                                        \n[2] \"Oh my God, Becky, look at her butt, it is so big, ugh\"                \n[3] \"She looks like one of those rap guys' girlfriends, but, ugh, you know\"\n[4] \"Who understands those rap guys? Ugh, they only talk to her\"           \n[5] \"Because she looks like a total prostitute, okay?\"                     \n[6] \"I mean, her butt, it's just so big\"                                   \n</pre>\n:::\n\n\n\nWe shall return to this classic text later, but the first few examples will all use `femininomenon`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(femininomenon)\n```\n\n<pre>[1] \"[Verse 1]\"                                        \n[2] \"Same old story, time again\"                       \n[3] \"Got so close but then you lost it\"                \n[4] \"Should've listened to your friends\"               \n[5] \"'Bout his girlfriend back in Boston\"              \n[6] \"You sent him pictures and playlists and phone sex\"\n</pre>\n:::\n\n\n\nHopefully you get the idea. Each of these is a vector, each element is a string, and we'll do some pattern matching on those strings, most often using `str_view()` from the stringr package to show which parts of the text each regex matches against. It's not the best tool for using in a script, but it's ideal as a way of visually inspecting the results of a regular expression matching exercise.\n\n## Simple matches\n\nIt begins with the very, very basics. Regular expressions are a tool for matching (and sometimes modifying) patterns in text strings. The simplest way to write a regular expression is to detect strings that match a specific, fixed subset of text. For instance, let's say I want to find every line in [Femininomenon](https://www.youtube.com/watch?v=xdaKBAuO8zg) in which Chappell Roan sings the word `\"femininomenon\"`. Using `str_view()` this is what we get:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(\n  string = femininomenon,   # the song lyrics\n  pattern = \"femininomenon\" # the regular expression\n)\n```\n\n<pre>[24] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[28] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[53] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[57] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[65] │ Well, what we really need is a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[66] │ (A what?) A <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[72] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[82] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[86] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[90] │ Make a bitch, it's a fem (It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>)\n</pre>\n:::\n\n\n\nIn this output, the teal-highlighted text^[At the R console, this highlighting appears automatically. Normally you wouldn't see this highlighting in a quarto document like this one, because quarto strips out the ANSI control characters that the console uses to add colour to the output. However, for the purposes of this post I cheated a little, by writing a [knitr hook](/posts/2023-12-30_knitr-hooks/) that crudely mimics the same behaviour in this document.] enclosed in angle brackets displays the sections of the text that match the regular expression. In this case our regular expression is very simple. It's just a literal string `\"femininomenon\"`, so the output highlights every instance of that word. \n\nNotice also that not every line in the song is shown by `str_view()`. Only those lines that match the regular expression are included (you can see that in the numbers to the left of each match). However, we can change this behaviour using the `match` argument to `str_view()`. For example, if wanted to see only those lines that *don't* include the letter `e`, we could do this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(\n  string = femininomenon,\n  pattern = \"e\", \n  match = FALSE\n)\n```\n\n<pre>[11] │ Why can't any man\n[12] │ \n[19] │ \n[20] │ [Chorus]\n[29] │ \n[40] │ Why can't any man\n[41] │ \n[48] │ \n[49] │ [Chorus]\n[58] │ \n[67] │ \n[77] │ \n[78] │ [Chorus]\n[87] │ \n[88] │ [Outro]\n</pre>\n:::\n\n\n\nAlternatively, we could set `match = NA`. If we do this, `str_view()` will return every line in the song, whether it matches or not. Here's an example. Let's search for every instance of the word `\"you\"`, and set `match = NA`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(\n  string = femininomenon,\n  pattern = \"you\",\n  match = NA\n)\n```\n\n<pre> [1] │ [Verse 1]\n [2] │ Same old story, time again\n [3] │ Got so close but then <span style='color:#008080'>&lt;you&gt;</span> lost it\n [4] │ Should've listened to <span style='color:#008080'>&lt;you&gt;</span>r friends\n [5] │ 'Bout his girlfriend back in Boston\n [6] │ You sent him pictures and playlists and phone sex\n [7] │ He disappeared from the second that <span style='color:#008080'>&lt;you&gt;</span> said\n [8] │ \"Let's get coffee, let's meet up\"\n [9] │ I'm so sick of online love\n[10] │ And I don't understand\n[11] │ Why can't any man\n[12] │ \n[13] │ [Pre-Chorus]\n[14] │ Hit it like, get it hot\n[15] │ Make a bitch, it's a fem\n[16] │ Hit it like, get it hot\n[17] │ Make a bitch, it's a—\n[18] │ Um, can <span style='color:#008080'>&lt;you&gt;</span> play a song with a fucking beat?\n[19] │ \n[20] │ [Chorus]\n... and 72 more\n</pre>\n:::\n\n\n\nThis output illustrates two things. First, you can see that there's a match on lines 3, 4, 7, 18, and probably others too (the remaining 72 lines of the song aren't shown in the output but they are actually included in the `str_view()` output). Second, it shows that our regular expression isn't quite doing the job we want it to: the match on line 4 matches the first three letters of the word \"your\", and it doesn't match to line 6 because that line contains the word \"You\" with an upper case \"Y\". If we want a regular expression to match \"you\" and \"You\" but not match against \"your\", it needs to be something a little more nuanced than setting `pattern = \"you\"` like I did above. \n\n![I sent him pictures and playlists and regex](femininomenon.jpg)\n\n\n## Quantifiers\n\nFor the moment, let's set aside the thorny question of how to handle capitalisation, and focus instead on the \"you\" vs \"your\" issue. Moreover, let's move the goalposts, and pretend that our new goal is actually to detect *both* `\"you\"` and `\"your\"`. This post is [not a place of honour](https://en.wikipedia.org/wiki/Long-term_nuclear_waste_warning_messages), and I'm not above cheating when it comes to these matters.\n\nWe can solve our new problem with the help of **quantifiers**. In regular expression syntax, certain character (sometimes called \"metacharacters\") have special meanings. For example, the `?` character is used to indicate that the preceding character is optional. When we write `\"your?\"` as our regular expression, the `r?` part indicates that the `r` character is optional. It will match against both `\"you\"` and `\"your\"`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"your?\")\n```\n\n<pre> [3] │ Got so close but then <span style='color:#008080'>&lt;you&gt;</span> lost it\n [4] │ Should've listened to <span style='color:#008080'>&lt;your&gt;</span> friends\n [7] │ He disappeared from the second that <span style='color:#008080'>&lt;you&gt;</span> said\n[18] │ Um, can <span style='color:#008080'>&lt;you&gt;</span> play a song with a fucking beat?\n[33] │ Lying to <span style='color:#008080'>&lt;your&gt;</span> friends about\n[35] │ Stuck in the suburbs, <span style='color:#008080'>&lt;you&gt;</span>'re folding his laundry\n[36] │ Got what <span style='color:#008080'>&lt;you&gt;</span> wanted, so stop feeling sorry\n[47] │ Dude, can <span style='color:#008080'>&lt;you&gt;</span> play a song with a fucking beat?\n[60] │ Ladies, <span style='color:#008080'>&lt;you&gt;</span> know what I mean\n[61] │ And <span style='color:#008080'>&lt;you&gt;</span> know what <span style='color:#008080'>&lt;you&gt;</span> need\n[76] │ Did <span style='color:#008080'>&lt;you&gt;</span> hear me? Play the fucking beat\n</pre>\n:::\n\n\n\nHere you can see that it matches the `\"you\"` on line 3 and the `\"your\"` on line 4. However, on line 35 where it encounters the word `\"you're\"` it detects a match, but *only* to the `\"you\"` part of the word.  \n\nThere are several quantifiers supported by most regular expression flavours.^[There are a ghastly number of different regular expression flavours out there. They are very similar to each other, but have subtle differences. Somewhat frustratingly, there are *three* different regular expression flavours that are widely used in R (two in base R and one in tidyverse), and every now and then I find myself running into cases where they don't produce identical results. More on this later in the post.] Quantifiers always refer to the previous item, and specify the number of repetitions of the previous item that can be matched: \n\n- `?` matches the previous item zero or one time\n- `*` matches the previous item zero or more times\n- `+` matches the previous item one or more times\n- `{n}` matches the previous item exactly n times\n- `{n,}` matches the previous item n or more times\n- `{n,m}` matches the previous item at least n times but not more than m times\n\nThis behaviour is (of course!) described in numerous places in the R documentation, but I find it helps a lot to have a concrete example that shows the differences between each of these. In the table below, the rows correspond to the strings `\"a\"`, `\"ab\"`, `\"abb\"`, and so on. Each column corresponds to a a regular expression that is always `\"ab\"` with a quantifier applied to the letter `\"b\"`. In each cell of the table, I've used `str_view()` to show how each string matches (or doesn't match) against each of the regexes:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntibble::tibble(\n  string    = c(\"a\", \"ab\", \"abb\", \"abbb\", \"abbbb\", \"abbbbb\"),\n  `ab?`     = str_view(string, pattern = \"ab?\", match = NA),\n  `ab*`     = str_view(string, pattern = \"ab*\", match = NA),\n  `ab+`     = str_view(string, pattern = \"ab+\", match = NA),\n  `ab{2}`   = str_view(string, pattern = \"ab{2}\", match = NA),\n  `ab{2,}`  = str_view(string, pattern = \"ab{2,}\", match = NA),\n  `ab{2,4}` = str_view(string, pattern = \"ab{2,4}\", match = NA)\n)\n```\n\n<pre># A tibble: 6 × 7\n  string `ab?`      `ab*`      `ab+`      `ab{2}`    `ab{2,}`   `ab{2,4}` \n  <span style='color:#008080'>&lt;chr&gt;</span>  <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span>\n1 a      <span style='color:#008080'>&lt;a&gt;</span>        <span style='color:#008080'>&lt;a&gt;</span>        a          a          a          a         \n2 ab     <span style='color:#008080'>&lt;ab&gt;</span>       <span style='color:#008080'>&lt;ab&gt;</span>       <span style='color:#008080'>&lt;ab&gt;</span>       ab         ab         ab        \n3 abb    <span style='color:#008080'>&lt;ab&gt;</span>b      <span style='color:#008080'>&lt;abb&gt;</span>      <span style='color:#008080'>&lt;abb&gt;</span>      <span style='color:#008080'>&lt;abb&gt;</span>      <span style='color:#008080'>&lt;abb&gt;</span>      <span style='color:#008080'>&lt;abb&gt;</span>     \n4 abbb   <span style='color:#008080'>&lt;ab&gt;</span>bb     <span style='color:#008080'>&lt;abbb&gt;</span>     <span style='color:#008080'>&lt;abbb&gt;</span>     <span style='color:#008080'>&lt;abb&gt;</span>b     <span style='color:#008080'>&lt;abbb&gt;</span>     <span style='color:#008080'>&lt;abbb&gt;</span>    \n5 abbbb  <span style='color:#008080'>&lt;ab&gt;</span>bbb    <span style='color:#008080'>&lt;abbbb&gt;</span>    <span style='color:#008080'>&lt;abbbb&gt;</span>    <span style='color:#008080'>&lt;abb&gt;</span>bb    <span style='color:#008080'>&lt;abbbb&gt;</span>    <span style='color:#008080'>&lt;abbbb&gt;</span>   \n6 abbbbb <span style='color:#008080'>&lt;ab&gt;</span>bbbb   <span style='color:#008080'>&lt;abbbbb&gt;</span>   <span style='color:#008080'>&lt;abbbbb&gt;</span>   <span style='color:#008080'>&lt;abb&gt;</span>bbb   <span style='color:#008080'>&lt;abbbbb&gt;</span>   <span style='color:#008080'>&lt;abbbb&gt;</span>b  \n</pre>\n:::\n\n\n\nNotice that these are all **eager** (sometimes called **greedy**), in the sense that they will always match to as many repetitions as they possibly can while satisfying the rules. However, you can reverse this behaviour and make a quantifier **lazy** by appending  `?` immediately after the quantifier. A lazy quantifier will match against the fewest number of repetitions as possible while still satisfying the rule. Here's what that looks like:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntibble::tibble(\n  string    = c(\"a\", \"ab\", \"abb\", \"abbb\", \"abbbb\", \"abbbbb\"),\n  `ab??`     = str_view(string, pattern = \"ab??\", match = NA),\n  `ab*?`     = str_view(string, pattern = \"ab*?\", match = NA),\n  `ab+?`     = str_view(string, pattern = \"ab+?\", match = NA),\n  `ab{2}?`   = str_view(string, pattern = \"ab{2}?\", match = NA),\n  `ab{2,}?`  = str_view(string, pattern = \"ab{2,}?\", match = NA),\n  `ab{2,4}?` = str_view(string, pattern = \"ab{2,4}?\", match = NA)\n)\n```\n\n<pre># A tibble: 6 × 7\n  string `ab??`     `ab*?`     `ab+?`     `ab{2}?`   `ab{2,}?`  `ab{2,4}?`\n  <span style='color:#008080'>&lt;chr&gt;</span>  <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span> <span style='color:#008080'>&lt;strngr_v&gt;</span>\n1 a      <span style='color:#008080'>&lt;a&gt;</span>        <span style='color:#008080'>&lt;a&gt;</span>        a          a          a          a         \n2 ab     <span style='color:#008080'>&lt;a&gt;</span>b       <span style='color:#008080'>&lt;a&gt;</span>b       <span style='color:#008080'>&lt;ab&gt;</span>       ab         ab         ab        \n3 abb    <span style='color:#008080'>&lt;a&gt;</span>bb      <span style='color:#008080'>&lt;a&gt;</span>bb      <span style='color:#008080'>&lt;ab&gt;</span>b      <span style='color:#008080'>&lt;abb&gt;</span>      <span style='color:#008080'>&lt;abb&gt;</span>      <span style='color:#008080'>&lt;abb&gt;</span>     \n4 abbb   <span style='color:#008080'>&lt;a&gt;</span>bbb     <span style='color:#008080'>&lt;a&gt;</span>bbb     <span style='color:#008080'>&lt;ab&gt;</span>bb     <span style='color:#008080'>&lt;abb&gt;</span>b     <span style='color:#008080'>&lt;abb&gt;</span>b     <span style='color:#008080'>&lt;abb&gt;</span>b    \n5 abbbb  <span style='color:#008080'>&lt;a&gt;</span>bbbb    <span style='color:#008080'>&lt;a&gt;</span>bbbb    <span style='color:#008080'>&lt;ab&gt;</span>bbb    <span style='color:#008080'>&lt;abb&gt;</span>bb    <span style='color:#008080'>&lt;abb&gt;</span>bb    <span style='color:#008080'>&lt;abb&gt;</span>bb   \n6 abbbbb <span style='color:#008080'>&lt;a&gt;</span>bbbbb   <span style='color:#008080'>&lt;a&gt;</span>bbbbb   <span style='color:#008080'>&lt;ab&gt;</span>bbbb   <span style='color:#008080'>&lt;abb&gt;</span>bbb   <span style='color:#008080'>&lt;abb&gt;</span>bbb   <span style='color:#008080'>&lt;abb&gt;</span>bbb  \n</pre>\n:::\n\n\n\nObviously, some of those are silly. There's no point whatsoever in writing a regular expression like `ab{2,4}?`, because it produces exactly the same behaviour as `ab{2}`. Nevertheless, there are some instances where lazy quantifiers turn out to be useful, so I'm mentioning them here just in case I come back in tears next year trying to figure out how the accursed things work.\n\nIn everyday life I find that 95% of the time the only quantifiers I ever need are `?`, `*`, and `+`, but every now and then I find a need to use the more flexible `{}` notation. To give one example of this, I'll use a recent [Midnight Pals thread](https://bsky.app/profile/midnightpals.bsky.social/post/3ld7vr34nok2n), which I loaded earlier as the `midnight` vector. If you're not a regular reader of Midnight Pals, it's essentially a literary satire that makes oblique references to current events. Edgar Allen Poe, Stephen King, Clive Barker, and Mary Shelley are recurring characters, for instance. So too is JK Rowling, though she doesn't associate with the other characters and instead tends to live in her own \"mysterious circle of robed figures\". To give you a sense of what the dialog typically looks like, here's the first few lines:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(midnight)\n```\n\n<pre>[1] \"[mysterious circle of robed figures]\"            \n[2] \"JK Rowling: hello children\"                      \n[3] \"Rowling: what newsss, wormtongue?\"               \n[4] \"Rowling: how goes the infiltration of bluesssky?\"\n[5] \"Jesse Singal: mommy mommy\"                       \n[6] \"Singal: it was SO HARD\"                          \n</pre>\n:::\n\n\n\nAs illustrated in this extract, one of the conceits of the JKR character is that she hisses many of her lines^[I usually imagine the character has a [yuan-ti](https://forgottenrealms.fandom.com/wiki/Yuan-ti) thing going on] and so the text often contains words like `\"bluesssky\"` or `\"transssses\"`. So let's see if we can write a regular expression to detect the hissed words. The actual number of `s`-repetitions in the JKR dialog varies of course, so we might want to use a regular expression like `s{3,}` to find instances of three or more successive `s` characters:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(midnight, \"s{3,}\")\n```\n\n<pre> [3] │ Rowling: what new<span style='color:#008080'>&lt;sss&gt;</span>, wormtongue?\n [4] │ Rowling: how goes the infiltration of blue<span style='color:#008080'>&lt;sss&gt;</span>ky?\n[17] │ Rowling: door'<span style='color:#008080'>&lt;sss&gt;</span> open, boy<span style='color:#008080'>&lt;sss&gt;</span>!\n[20] │ Rowling: i know you did, je<span style='color:#008080'>&lt;ssss&gt;</span>e\n[22] │ Rowling: yess you did great je<span style='color:#008080'>&lt;sss&gt;</span>e\n[43] │ Rowling: patience, <span style='color:#008080'>&lt;ssss&gt;</span>isster, we must bide our time\n[54] │ Rowling: sure, je<span style='color:#008080'>&lt;sss&gt;</span>e might look like a sniveling worm, a nasty crawling slithering little shit, a spineless craven buffoon\n</pre>\n:::\n\n\n\nIt doesn't work perfectly (e.g., it misses the `\"yess\"` on line 22), but it's not too bad given how simple the regex is. That said, it's also a bit limited insofar as it only detects the hissing (i.e., the `s`-repetition). Ideally, we'd like a regular expression that captures the entire hissssssed word, but to do that we'll need to get a little fancier, and dive a little deeper into regular expression syntax. We'll return to that later.\n\n::: {.column-margin}\n\n![[clive. clive don't be an instigator](https://bsky.app/profile/midnightpals.bsky.social/post/3kzf6vtc6fl26)](midnight1.png)\n\n:::\n\n## Backslashes (part I)\n\nThe discussion of quantifiers leads to the natural question: what if I don't want to use `?` as a quantifier, and instead want to match a literal `?` in the string. To do that we can **escape** the special character by prefixing it with a backslash. That is, within a regular expression we would write `\\?` to match a literal `?`. \n\nIt gets complicated, though, because the way we represent the regular expression is via an R string,^[I'm not talking about raw strings in this post. Sorry.] and `\\` has a special meaning in R strings, because it's used as an escape character in R too. So if we want to \"pass\" a literal `\\` into the regular expression, the thing we need to type in R is `\"\\\\\"`. This is... confusing. I find this helps:\n\n- write `\"\\\\+\"` in R to mean `\\+` in the regex, and match a literal `+`\n- write `\"\\\\?\"` in R to mean `\\?` in the regex, and match a literal `?`\n- write `\"\\\\*\"` in R to mean `\\*` in the regex, and match a literal `*`\n- write `\"\\\\{\"` in R to mean `\\{` in the regex, and match a literal `{`\n\nNotice the notation I've used here: when I enclose a string in quotation marks I'm referring to the string as it has to be specified in R, but when the quote marks are missing I am referring to the raw contents of the string/regex.\n\nIn any case, since we are using `\\` as the escape character, it follows that it too is considered a special character in regular expression syntax. As such, you have to escape the backslash if you want to treat it as a literal:\n\n- write `\"\\\\\\\\\"` in R to mean `\\\\` in the regex, and match a literal `\\`\n\nNot particularly pleasant, and as you can imagine it is very easy to write regular expressions that use the wrong number of backslashes and end up in tears. \n\nIn any case, here's an example. If I want to find all the question marks in the `femininomenon` lyrics, this is what I would have to do:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"\\\\?\")\n```\n\n<pre>[18] │ Um, can you play a song with a fucking beat<span style='color:#008080'>&lt;?&gt;</span>\n[47] │ Dude, can you play a song with a fucking beat<span style='color:#008080'>&lt;?&gt;</span>\n[63] │ But does it happen<span style='color:#008080'>&lt;?&gt;</span> (No)\n[64] │ But does it happen<span style='color:#008080'>&lt;?&gt;</span> (No)\n[66] │ (A what<span style='color:#008080'>&lt;?&gt;</span>) A femininomenon\n[76] │ Did you hear me<span style='color:#008080'>&lt;?&gt;</span> Play the fucking beat\n</pre>\n:::\n\n\n\nIt should also be noted that a similar thing happens with regards to special characters like `\\n` (line feed) that contain a backslash in their notation. The line feed character has no special meaning in a regular expression, but because you need to pass the textual representation from the R string down to the regular expression, you have to escape the backslash. That is:\n\n- write `\"\\\\n\"` in R to mean `\\n` in the regex, and match a line feed\n- write `\"\\\\t\"` in R to mean `\\t` in the regex, and match a tab\n\nI'll return to  this in a later section, because there are other characters that need to be escaped. But these are the ones we need for now. \n\n## Character sets\n\nEarlier in the post we encountered the irritating problem of capital letters. If we want to detect all lines where Chappell Roan sings `\"you\"` or `\"your\"` without worrying about capitalisation, we need a way of describing \"a single character that can either be `y` or `Y`\". We can do this by defining a **character set** (sometimes referred to as a **category** or **class**) by enclosing the set of allowed characters in square brackets. For example, the character set `[yY]` will match to a single instance of `y` or a single instance of `Y`. Our regular expression now becomes `\"[Yy]our?\"`, as shown below:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"[Yy]our?\")\n```\n\n<pre> [3] │ Got so close but then <span style='color:#008080'>&lt;you&gt;</span> lost it\n [4] │ Should've listened to <span style='color:#008080'>&lt;your&gt;</span> friends\n [6] │ <span style='color:#008080'>&lt;You&gt;</span> sent him pictures and playlists and phone sex\n [7] │ He disappeared from the second that <span style='color:#008080'>&lt;you&gt;</span> said\n[18] │ Um, can <span style='color:#008080'>&lt;you&gt;</span> play a song with a fucking beat?\n[32] │ <span style='color:#008080'>&lt;You&gt;</span> pretend to love his mother\n[33] │ Lying to <span style='color:#008080'>&lt;your&gt;</span> friends about\n[35] │ Stuck in the suburbs, <span style='color:#008080'>&lt;you&gt;</span>'re folding his laundry\n[36] │ Got what <span style='color:#008080'>&lt;you&gt;</span> wanted, so stop feeling sorry\n[47] │ Dude, can <span style='color:#008080'>&lt;you&gt;</span> play a song with a fucking beat?\n[60] │ Ladies, <span style='color:#008080'>&lt;you&gt;</span> know what I mean\n[61] │ And <span style='color:#008080'>&lt;you&gt;</span> know what <span style='color:#008080'>&lt;you&gt;</span> need\n[76] │ Did <span style='color:#008080'>&lt;you&gt;</span> hear me? Play the fucking beat\n</pre>\n:::\n\n\n\nYou can apply quantifiers to character sets, but you need to be a little careful about this. Let's say I have the character set `[femino]`, and I want to apply the quantifier `{4,}` to detect four or more repetitions of the character set. The regular expression `[femino]{4,}` will match against literal repetitions like `\"oooo\"` or `\"mmmmm\"`, but it will also match to words like `\"omen\"` and `\"feminine\"` because evey letter in those words belongs to the character set:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"[femino]{4,}\")\n```\n\n<pre> [8] │ \"Let's get c<span style='color:#008080'>&lt;offee&gt;</span>, let's meet up\"\n[24] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[28] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[53] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[57] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[65] │ Well, what we really need is a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[66] │ (A what?) A <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[72] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[82] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[86] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[90] │ Make a bitch, it's a fem (It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>)\n</pre>\n:::\n\n\n\n... oh yeah, it also matches the `\"offee\"` in `\"coffee\"`.\n\n### Ranges and shorthand notation\n\nWhen referring to alphabetic characters or digits, you can use a hyphen within a character set to define a **range** of characters. For example, `[0-9]` is essentially a shorthand for `[0123456789]` and `[a-e]` is short hand for `[abcde]`. You can define multiple ranges within a single character set, so `[a-zA-Z0-9]` will match against alphanumeric characters.\n\nSome character sets are used so often that there is a shorthand notation for them:\n\n- `\\d` denotes digits, and is equivalent to `[0-9]`\n- `\\w` denotes word characters. At a minimum it supports alphanumeric characters, but it will also match against unicode characters used in words. \n- `\\s` denotes whitespace characters, and will match a space `\" \"`, a tab `\"\\t\"`, a carriage return `\"\\r\"`, a line feed `\"\\n\"`, or a form feed `\"\\f\"`; as well as unicode separator characters if the regex flavour supports unicode\n\nThere are a variety of other shorthand classes too. If you look in the base R documentation, for instance, you'll find reference to various \"POSIX classes\" like `:digit:` and `:punct:` that do something similar. Over time I've become wary about these because they aren't implemented consistently across regex flavours (see later), so I try to avoid them.\n\nTo illustrate how to use these prespecified character sets, I'll do a little bit of regular expression matching on the opening lines to [One](https://genius.com/Harry-nilsson-one-lyrics) by Harry Nilsson, where I've used digits to represent the numbers rather than spelling out the words:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\none <- c(\n  \"1 is the loneliest number that you'll ever do\",\n  \"2 can be as bad as 1\",\n  \"It's the loneliest number since the number 1\"\n)\n```\n:::\n\n\n\nTo detect the digits in this text, the regular expression we need is just the character set `\\d` itself. The only nuance here is that we have to specify the regex as an R string, so we have to type `\"\\\\d\"` in R in order to get what we want:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(one, \"\\\\d\")\n```\n\n<pre>[1] │ <span style='color:#008080'>&lt;1&gt;</span> is the loneliest number that you'll ever do\n[2] │ <span style='color:#008080'>&lt;2&gt;</span> can be as bad as <span style='color:#008080'>&lt;1&gt;</span>\n[3] │ It's the loneliest number since the number <span style='color:#008080'>&lt;1&gt;</span>\n</pre>\n:::\n\n\n\nAlternatively, suppose I want to detect all words in the text. One approach (which doesn't quite work -- we'll come back to this later) would be to look for consecutive sequences of word characters, which we could specify using `\\w+` as the regular expression and, to belabour the point, writing `\"\\\\w+\"` as the R string that specifies that regular expression:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(one, \"\\\\w+\")\n```\n\n<pre>[1] │ <span style='color:#008080'>&lt;1&gt;</span> <span style='color:#008080'>&lt;is&gt;</span> <span style='color:#008080'>&lt;the&gt;</span> <span style='color:#008080'>&lt;loneliest&gt;</span> <span style='color:#008080'>&lt;number&gt;</span> <span style='color:#008080'>&lt;that&gt;</span> <span style='color:#008080'>&lt;you&gt;</span>'<span style='color:#008080'>&lt;ll&gt;</span> <span style='color:#008080'>&lt;ever&gt;</span> <span style='color:#008080'>&lt;do&gt;</span>\n[2] │ <span style='color:#008080'>&lt;2&gt;</span> <span style='color:#008080'>&lt;can&gt;</span> <span style='color:#008080'>&lt;be&gt;</span> <span style='color:#008080'>&lt;as&gt;</span> <span style='color:#008080'>&lt;bad&gt;</span> <span style='color:#008080'>&lt;as&gt;</span> <span style='color:#008080'>&lt;1&gt;</span>\n[3] │ <span style='color:#008080'>&lt;It&gt;</span>'<span style='color:#008080'>&lt;s&gt;</span> <span style='color:#008080'>&lt;the&gt;</span> <span style='color:#008080'>&lt;loneliest&gt;</span> <span style='color:#008080'>&lt;number&gt;</span> <span style='color:#008080'>&lt;since&gt;</span> <span style='color:#008080'>&lt;the&gt;</span> <span style='color:#008080'>&lt;number&gt;</span> <span style='color:#008080'>&lt;1&gt;</span>\n</pre>\n:::\n\n\n\nYou can see why this doesn't quite do what we want: the apostrophe is not a word character, and it doesn't get detected. There's a better approach to this using word boundaries, but I'll come to that later when talking about anchors. \n\n![I prefer the Aimee Mann cover](one1.jpg)\n\n### Logical operations with character sets\n\nTo some extent you can perform logical operations on character sets: set negation, set union, set intersection, add set subtraction. These operations are all supported by regular expressions, but this is another thing where the implementation varies a little across regular expression flavours. So let's talk about these in turn.\n\nOf the various operations, set union is the easiest one to describe. We've already talked about it. If you want to take the union of two character sets, all you have to do is concatenate them in the description. The lower case letters are represented by the range `[a-z]`, and the upper case letters are represented by `[A-Z]`. The union of these classes is simply `[a-zA-Z]`. These are set operations, so it doesn't matter if you include the same element multiple times: `[aab]` is the same character set as `[ab]`. \n\nThe second easiest one to talk about is negation. If you want to represent \"any character except the ones listed\", use `[^` to begin the set rather than `[`. For example, the set `[^femino ]` is comprised of all characters except those seven (six letters plus the space). If I wanted to detect all instances where the Chappell Roan lyrics contain five or more consecutive characters that don't include these letters, I'd do this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"[^femino ]{5,}\")\n```\n\n<pre> [4] │ Sho<span style='color:#008080'>&lt;uld'v&gt;</span>e listened to your friends\n [6] │ You sent him pictures and <span style='color:#008080'>&lt;playl&gt;</span>ists and phone sex\n[24] │ <span style='color:#008080'>&lt;(It's&gt;</span> a fem) It's a femininomenon\n[28] │ <span style='color:#008080'>&lt;(It's&gt;</span> a fem) It's a femininomenon\n[35] │ <span style='color:#008080'>&lt;Stuck&gt;</span> in the <span style='color:#008080'>&lt;suburbs,&gt;</span> you're folding his laundry\n[53] │ <span style='color:#008080'>&lt;(It's&gt;</span> a fem) It's a femininomenon\n[57] │ <span style='color:#008080'>&lt;(It's&gt;</span> a fem) It's a femininomenon\n[66] │ (A <span style='color:#008080'>&lt;what?)&gt;</span> A femininomenon\n[72] │ <span style='color:#008080'>&lt;(It's&gt;</span> a fem) It's a femininomenon\n[82] │ <span style='color:#008080'>&lt;(It's&gt;</span> a fem) It's a femininomenon\n[86] │ <span style='color:#008080'>&lt;(It's&gt;</span> a fem) It's a femininomenon\n[88] │ <span style='color:#008080'>&lt;[Outr&gt;</span>o]\n[90] │ Make a bitch, it's a fem <span style='color:#008080'>&lt;(It's&gt;</span> a femininomenon)\n</pre>\n:::\n\n\n\nYeah, fair enough.\n\nBefore moving on to other kinds of set logic, it's worth being explicit about what the `[^` notation implies about including `^` in a character set. The short answer is that `^` only has the special meaning of \"negation operator\" if it follows immediately after the `[`. In other words, the sets `[ab^]` and `[a^b]` are identical and will match against any literal `a`, `b`, or `^` that appears in the text. However, `[^ab]` is a different set entirely, because in this context `^` is interpreted as the negation operator and this will match against anything that is not an `a` or a `b`. As an illustration, let's match against five or more repetitions of `[femino ^]`, and compare it to what we got last time:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"[femino ^]{5,}\")\n```\n\n<pre> [8] │ \"Let's get c<span style='color:#008080'>&lt;offee&gt;</span>, let's meet up\"\n [9] │ I'm so sick<span style='color:#008080'>&lt; of on&gt;</span>line love\n[23] │ (Make a bitch) Make a bitch g<span style='color:#008080'>&lt;o on &gt;</span>and on\n[24] │ (It's a fem) It's a<span style='color:#008080'>&lt; femininomenon&gt;</span>\n[27] │ (Make a bitch) Make a bitch g<span style='color:#008080'>&lt;o on &gt;</span>and on\n[28] │ (It's a fem) It's a<span style='color:#008080'>&lt; femininomenon&gt;</span>\n[38] │ I'm so sick<span style='color:#008080'>&lt; of on&gt;</span>line love\n[52] │ (Make a bitch) Make a bitch g<span style='color:#008080'>&lt;o on &gt;</span>and on\n[53] │ (It's a fem) It's a<span style='color:#008080'>&lt; femininomenon&gt;</span>\n[56] │ (Make a bitch) Make a bitch g<span style='color:#008080'>&lt;o on &gt;</span>and on\n[57] │ (It's a fem) It's a<span style='color:#008080'>&lt; femininomenon&gt;</span>\n[65] │ Well, what we really need is a<span style='color:#008080'>&lt; femininomenon&gt;</span>\n[66] │ (A what?) A<span style='color:#008080'>&lt; femininomenon&gt;</span>\n[71] │ (Make a bitch) Make a bitch g<span style='color:#008080'>&lt;o on &gt;</span>and on\n[72] │ (It's a fem) It's a<span style='color:#008080'>&lt; femininomenon&gt;</span>\n[75] │ (Make a bitch) Make a bitch g<span style='color:#008080'>&lt;o on &gt;</span>and on\n[81] │ (Make a bitch) Make a bitch g<span style='color:#008080'>&lt;o on &gt;</span>and on\n[82] │ (It's a fem) It's a<span style='color:#008080'>&lt; femininomenon&gt;</span>\n[85] │ (Make a bitch) Make a bitch g<span style='color:#008080'>&lt;o on &gt;</span>and on\n[86] │ (It's a fem) It's a<span style='color:#008080'>&lt; femininomenon&gt;</span>\n... and 1 more\n</pre>\n:::\n\n\n\nNot surprisingly, this is a very different result.\n\nFinally, I want to briefly talk about subtraction and intersection. This is where things get tricky in R because these *do* work in tidyverse regular expressions but do not work in base R regexes, due to the differences in the regular expression engines underneath. In some regex flavours (including the one used in tidyverse), you can use a minus sign `-` to denote set difference, so it would be entirely valid to use `[[a-z]-[aeiou]]` to represent lower case consonants. Similarly, you can use `&&` to represent intersection, so `[[a-z]]&&[Papa]` would be equivalent to `[pa]`. This notation works in tidyverse (more detail on this later), as illustrated below:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"[[a-z]-[femino]]{5,}\")\n```\n\n<pre> [6] │ You sent him pictures and <span style='color:#008080'>&lt;playl&gt;</span>ists and phone sex\n[35] │ Stuck in the <span style='color:#008080'>&lt;suburbs&gt;</span>, you're folding his laundry\n</pre>\n\n```{.r .cell-code}\nstr_view(femininomenon, \"[[a-z]&&[Papa]]{3,}\")\n```\n\n<pre> [7] │ He dis<span style='color:#008080'>&lt;app&gt;</span>eared from the second that you said\n[22] │ (Get it hot) Get it hot like P<span style='color:#008080'>&lt;apa&gt;</span> John\n[26] │ (Get it hot) Get it hot like P<span style='color:#008080'>&lt;apa&gt;</span> John\n[51] │ (Get it hot) Get it hot like P<span style='color:#008080'>&lt;apa&gt;</span> John\n[55] │ (Get it hot) Get it hot like P<span style='color:#008080'>&lt;apa&gt;</span> John\n[63] │ But does it h<span style='color:#008080'>&lt;app&gt;</span>en? (No)\n[64] │ But does it h<span style='color:#008080'>&lt;app&gt;</span>en? (No)\n[70] │ (Get it hot) Get it hot like P<span style='color:#008080'>&lt;apa&gt;</span> John\n[74] │ (Get it hot) Get it hot like P<span style='color:#008080'>&lt;apa&gt;</span> John\n[80] │ (Get it hot) Get it hot like P<span style='color:#008080'>&lt;apa&gt;</span> John\n[84] │ (Get it hot) Get it hot like P<span style='color:#008080'>&lt;apa&gt;</span> John\n</pre>\n:::\n\n\n\nBe warned, however: it does not work in base R. \n\n## Anchors and boundaries\n\nNext on Danielle's list of \"tedious regular expression concepts\" are **anchors**. There are two special characters that are used to represent \"start of string\" and \"end of string\":\n\n- When used outside of a character set, `^` denotes \"start of string\"\n- When used outside of a character set, `$` denotes \"end of string\"\n\nIn my little notes-to-self I always phrase it like this because when you use these characters inside square brackets they are *not* interpreted as anchors, and sometimes I forget this nuance.\n\nAs an example of how to use these anchors, let's say I want to detect the first word in every line in \"Femininomenon\", but only if that word starts with the capital letter `L`. The regular expression `^L` will match against any `L` that appears as the first character in the string, so a first-pass attempt at solving this problem might be to try something like `^L\\w*` (i.e., match a starting `L` followed by zero or more word characters). It's not the most robust way to solve the problem, but it works just fine in this case:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"^L\\\\w*\")\n```\n\n<pre>[33] │ <span style='color:#008080'>&lt;Lying&gt;</span> to your friends about\n[60] │ <span style='color:#008080'>&lt;Ladies&gt;</span>, you know what I mean\n</pre>\n:::\n\n\n\nThe same logic works for end of string. In the example below we have a regular expression that detects the final word in the line, but only if it starts with a lower-case `f`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"f\\\\w*$\")\n```\n\n<pre> [4] │ Should've listened to your <span style='color:#008080'>&lt;friends&gt;</span>\n[15] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>\n[24] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[28] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[44] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>\n[53] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[57] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[65] │ Well, what we really need is a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[66] │ (A what?) A <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[72] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[82] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[86] │ (It's a fem) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[92] │ Make a bitch, it's a fem, fem, fem, <span style='color:#008080'>&lt;fem&gt;</span>\n</pre>\n:::\n\n\n\nAbout 99% of my use of anchors is either `$` or `^` but there are other anchors. It varies across regex flavours, but generally you can use `\\A` the same way you use `^` to represent start of string, and `\\Z` to represent end of string. Personally I don't like these alternatives, because I keep incorrectly thinking that they have some meaningful relationship to alphabetic characters. The `^` and `$` notation is pretty arbitrary, but at least it's not actively misleading in the way that `\\A` and `\\Z` are. \n\nA closely related concept to anchors is the idea of a **boundary**. Anchors and boundaries are both examples of \"zero-length matches\", in the sense that they don't match against a specific character, they match against a position in the text. A word boundary `\\b` (the only kind of boundary I am aware of, though there might be others) matches against a position that is followed by a word character (i.e., anything that is matched by `\\w`), but is preceded by a non-word character *or vice versa*. Informally stated, `\\b` matches a start-of-word boundary and an end-of-word boundary.\n\nAs a simple example, suppose we want to match only those instances in \"Femininomenon\" where `\"fem\"` is used as a word. If we don't consider word boundaries, this doesn't quite work because it matches the first three characters in `\"femininomenon\"`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"fem\")\n```\n\n<pre>[15] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>\n[24] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[28] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[44] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>\n[53] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[57] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[65] │ Well, what we really need is a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[66] │ (A what?) A <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[72] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[82] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[86] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon\n[90] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span> (It's a <span style='color:#008080'>&lt;fem&gt;</span>ininomenon)\n[92] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>\n</pre>\n:::\n\n\n\nWe can tighten our regex by specifying that `\"fem\"` must have word boundaries on either side. The regular expression now becomes `\\bfem\\b`, so the command we type in R looks like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"\\\\bfem\\\\b\")\n```\n\n<pre>[15] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>\n[24] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a femininomenon\n[28] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a femininomenon\n[44] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>\n[53] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a femininomenon\n[57] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a femininomenon\n[72] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a femininomenon\n[82] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a femininomenon\n[86] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a femininomenon\n[90] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span> (It's a femininomenon)\n[92] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>\n</pre>\n:::\n\n\n\nMuch better! Notice also that \"end of string\" and \"start of string\" do count as a word boundaries. On lines 15, 44, and 92, the line ends in the word `\"fem\"` and our regular expression captures these cases.\n\n::: {.column-margin}\n\n![Pretend I made a boring regex pun about the femmes being \"so strung out\" here](femmes.jpg)\n\n:::\n\n\n## Groups\n\nThe next regular expression concept to talk about are **groups**. At it's most basic, a group is a sequence of characters that is treated as if it were a single character for the purposes of quantification etc.^[Yes I know it's more nuanced than that, hush, I'll get to that momentarily.] We can do this by enclosing the characters in parentheses, e.g., `(fem)` is a group that corresponds to the specific sequence `fem`. \nFor example, let's suppose I want to match against `\"fem\"` or `\"femininomenon\"`. There are lots of ways I could do this, but one of my favourite approaches to this would be to define `(ininomenon)` as a group, and then declare that this group is optional using the `?` quantifier:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(femininomenon, \"fem(ininomenon)?\")\n```\n\n<pre>[15] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>\n[24] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[28] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[44] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>\n[53] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[57] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[65] │ Well, what we really need is a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[66] │ (A what?) A <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[72] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[82] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[86] │ (It's a <span style='color:#008080'>&lt;fem&gt;</span>) It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>\n[90] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span> (It's a <span style='color:#008080'>&lt;femininomenon&gt;</span>)\n[92] │ Make a bitch, it's a <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>, <span style='color:#008080'>&lt;fem&gt;</span>\n</pre>\n:::\n\n\n\nThis can be handy if a particular sequence that you want to match might be repeated as a whole. Let's say I want to match `\"in\"`, `\"inin\"`, and `\"ininin\"` but not match `\"inn\"`. We could do this cleanly with a regular expression like `(in)+`, though if we want to prevent it from matching the `\"in\"` in `\"inn\"` we should also specify that the pattern should be preceded and followed by word boundaries. That is, this *almost* works:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(\"i in inin ininin inn out\", \"(in)+\")\n```\n\n<pre>[1] │ i <span style='color:#008080'>&lt;in&gt;</span> <span style='color:#008080'>&lt;inin&gt;</span> <span style='color:#008080'>&lt;ininin&gt;</span> <span style='color:#008080'>&lt;in&gt;</span>n out\n</pre>\n:::\n\n\n\nThis actually works:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(\"i in inin ininin inn out\", \"\\\\b(in)+\\\\b\")\n```\n\n<pre>[1] │ i <span style='color:#008080'>&lt;in&gt;</span> <span style='color:#008080'>&lt;inin&gt;</span> <span style='color:#008080'>&lt;ininin&gt;</span> inn out\n</pre>\n:::\n\n\n\n## Pipes as \"or\" operators\n\nOne of the more basic features in regular expressions is that when `|` is used outside of a category, it is interpreted as an \"or\" operator that is evaluated left to right. It's so basic that I feel weird about delaying discussion of `|` until this late in the post, but in practice I find that I use it most often in conjunction with groups and character sets, so I wanted to wait until I'd talked about those concepts first.\n\nThis time I'll use the lyrics to [Feather](https://www.youtube.com/watch?v=kLbn61Z4LDI) by Sabrina Carpenter as the source text, and I'll look for all instances where she sings the word \"feather\" or the phrase \"no duh\". No, I don't know why I chose those two, but let's run with it. A regular expression that does this, taking potential capitalisation into account, would be `([Ff]eather)|([Nn]o duh)`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(feather, \"([Ff]eather)|([Nn]o duh)\")\n```\n\n<pre>[19] │ I feel so much lighter like a <span style='color:#008080'>&lt;feather&gt;</span> with you off my mind (Ah)\n[23] │ I feel so much lighter like a <span style='color:#008080'>&lt;feather&gt;</span> with you out my life\n[29] │ Like a <span style='color:#008080'>&lt;feather&gt;</span>, like a <span style='color:#008080'>&lt;feather&gt;</span>, like a <span style='color:#008080'>&lt;feather&gt;</span>, yeah\n[44] │ I feel so much lighter like a <span style='color:#008080'>&lt;feather&gt;</span> with you off my mind (Ah)\n[48] │ I feel so much lighter like a <span style='color:#008080'>&lt;feather&gt;</span> with you out my life\n[55] │ Like a <span style='color:#008080'>&lt;feather&gt;</span>, like a <span style='color:#008080'>&lt;feather&gt;</span>, like a <span style='color:#008080'>&lt;feather&gt;</span>\n[59] │ You miss me? <span style='color:#008080'>&lt;No duh&gt;</span>\n[62] │ You miss me? <span style='color:#008080'>&lt;No duh&gt;</span> (<span style='color:#008080'>&lt;No duh&gt;</span>)\n[67] │ (I feel so much lighter like a <span style='color:#008080'>&lt;feather&gt;</span> with you off my mind)\n[68] │ You miss me? <span style='color:#008080'>&lt;No duh&gt;</span>\n[70] │ (Like a <span style='color:#008080'>&lt;feather&gt;</span>, like a <span style='color:#008080'>&lt;feather&gt;</span>, like a <span style='color:#008080'>&lt;feather&gt;</span>)\n[72] │ (I feel so much lighter like a <span style='color:#008080'>&lt;feather&gt;</span> with you off my mind)\n[73] │ You miss me? <span style='color:#008080'>&lt;No duh&gt;</span>\n[75] │ (Like a <span style='color:#008080'>&lt;feather&gt;</span>, like a <span style='color:#008080'>&lt;feather&gt;</span>, like a <span style='color:#008080'>&lt;feather&gt;</span>, yeah)\n</pre>\n:::\n\n\n\nIn this example, there's no possible way in which a string can match against both the left hand side and the right hand side, so in this case the order of the two groups doesn't matter. But that's not always the case. Let's suppose I want to match against the exact word \"feather\", *or* match against a substring inside a word that starts with the letter `f` and ends in the letter `t` (we can do this with `(f\\w*t)` as the regex). Should we match the entire word `\"feather\"` or only match the `\"feat\"` part of the word? It depends on the order in which the two groups are specified. \n\nTo see the difference compare this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(feather, \"(feather)|(f\\\\w*t)\")\n```\n\n<pre>[15] │ I got you blocked, a<span style='color:#008080'>&lt;ft&gt;</span>er this, an a<span style='color:#008080'>&lt;fterthought&gt;</span>\n[19] │ I feel so much lighter like a <span style='color:#008080'>&lt;feather&gt;</span> with you off my mind (Ah)\n[22] │ You <span style='color:#008080'>&lt;fit&gt;</span> every stereotype, \"Send a pic\"\n[23] │ I feel so much lighter like a <span style='color:#008080'>&lt;feather&gt;</span> with you out my life\n[29] │ Like a <span style='color:#008080'>&lt;feather&gt;</span>, like a <span style='color:#008080'>&lt;feather&gt;</span>, like a <span style='color:#008080'>&lt;feather&gt;</span>, yeah\n[44] │ I feel so much lighter like a <span style='color:#008080'>&lt;feather&gt;</span> with you off my mind (Ah)\n[47] │ You <span style='color:#008080'>&lt;fit&gt;</span> every stereotype, \"Send a pic\"\n[48] │ I feel so much lighter like a <span style='color:#008080'>&lt;feather&gt;</span> with you out my life\n[55] │ Like a <span style='color:#008080'>&lt;feather&gt;</span>, like a <span style='color:#008080'>&lt;feather&gt;</span>, like a <span style='color:#008080'>&lt;feather&gt;</span>\n[67] │ (I feel so much lighter like a <span style='color:#008080'>&lt;feather&gt;</span> with you off my mind)\n[70] │ (Like a <span style='color:#008080'>&lt;feather&gt;</span>, like a <span style='color:#008080'>&lt;feather&gt;</span>, like a <span style='color:#008080'>&lt;feather&gt;</span>)\n[72] │ (I feel so much lighter like a <span style='color:#008080'>&lt;feather&gt;</span> with you off my mind)\n[75] │ (Like a <span style='color:#008080'>&lt;feather&gt;</span>, like a <span style='color:#008080'>&lt;feather&gt;</span>, like a <span style='color:#008080'>&lt;feather&gt;</span>, yeah)\n</pre>\n:::\n\n\n\nto this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(feather, \"(f\\\\w*t)|(feather)\")\n```\n\n<pre>[15] │ I got you blocked, a<span style='color:#008080'>&lt;ft&gt;</span>er this, an a<span style='color:#008080'>&lt;fterthought&gt;</span>\n[19] │ I feel so much lighter like a <span style='color:#008080'>&lt;feat&gt;</span>her with you off my mind (Ah)\n[22] │ You <span style='color:#008080'>&lt;fit&gt;</span> every stereotype, \"Send a pic\"\n[23] │ I feel so much lighter like a <span style='color:#008080'>&lt;feat&gt;</span>her with you out my life\n[29] │ Like a <span style='color:#008080'>&lt;feat&gt;</span>her, like a <span style='color:#008080'>&lt;feat&gt;</span>her, like a <span style='color:#008080'>&lt;feat&gt;</span>her, yeah\n[44] │ I feel so much lighter like a <span style='color:#008080'>&lt;feat&gt;</span>her with you off my mind (Ah)\n[47] │ You <span style='color:#008080'>&lt;fit&gt;</span> every stereotype, \"Send a pic\"\n[48] │ I feel so much lighter like a <span style='color:#008080'>&lt;feat&gt;</span>her with you out my life\n[55] │ Like a <span style='color:#008080'>&lt;feat&gt;</span>her, like a <span style='color:#008080'>&lt;feat&gt;</span>her, like a <span style='color:#008080'>&lt;feat&gt;</span>her\n[67] │ (I feel so much lighter like a <span style='color:#008080'>&lt;feat&gt;</span>her with you off my mind)\n[70] │ (Like a <span style='color:#008080'>&lt;feat&gt;</span>her, like a <span style='color:#008080'>&lt;feat&gt;</span>her, like a <span style='color:#008080'>&lt;feat&gt;</span>her)\n[72] │ (I feel so much lighter like a <span style='color:#008080'>&lt;feat&gt;</span>her with you off my mind)\n[75] │ (Like a <span style='color:#008080'>&lt;feat&gt;</span>her, like a <span style='color:#008080'>&lt;feat&gt;</span>her, like a <span style='color:#008080'>&lt;feat&gt;</span>her, yeah)\n</pre>\n:::\n\n\n\nAs this illustrates, if a match is detected on the left hand side of the `|` the regular expression engine uses that match. It won't use the right hand side if there's already a match on the left. Admittedly, I've been a bit lazy in this by not taking word boundaries or capitalisation into account. You'd probably want something a little more elaborate in real life, but it's such a silly example that I've erred on the side of simplicity here so that you can see the difference that order makes.\n\n## Dots as \"any\" character\n\nIt may surprise the reader (it surprised the author) that I've managed to get this far into the post without ever talking about the `.` metacharacter. This is partly accidental, partly deliberate. The `.` is a powerful and easily-misused tool: it matches *any* character except line breaks. There's a whole article on [the dot](https://www.regular-expressions.info/dot.html) that cautious novice regex users to be careful when using it... so I am trying to teach myself to be careful and not use it so often!\n\nAn example of why it's sometimes counterintuitive. Suppose I want to match the text in each line of \"Feather\" up to the point that `\"ignore\"` appears, and then terminate the match. It's very tempting to use `.*ignore` as the regular expression, but that doesn't quite do what we expect:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(feather, \".*ignore\")\n```\n\n<pre>[13] │ <span style='color:#008080'>&lt;I slam the door, I hit ignore&gt;</span>\n[38] │ <span style='color:#008080'>&lt;I slam the door (Slam the door), I hit ignore (Hit ignore&gt;</span>)\n</pre>\n:::\n\n\n\nBecause the `*` operator is greedy, it \"consumes\" every instance of `\"ignore\"` except the last one, which is then matched by the explicitly stated `\"ignore\"` in the regex. As a consequence, the regex I've written here matches all the text up to and including the last `\"ignore\"` that appears in the line, so it matches incorrectly on line 38. \n\nWe can fix this by tightening the quantification. Instead of using a greedy operator `*` that matches as much text as possible, we can use the lazy version `*?` that matches as little as possible:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(feather, \".*?ignore\")\n```\n\n<pre>[13] │ <span style='color:#008080'>&lt;I slam the door, I hit ignore&gt;</span>\n[38] │ <span style='color:#008080'>&lt;I slam the door (Slam the door), I hit ignore&gt;</span><span style='color:#008080'>&lt; (Hit ignore&gt;</span>)\n</pre>\n:::\n\n\n\nNow we get the right answer.\n\n::: {layout-ncol=2}\n\n![When I use `.*` in my regex](feather1.jpg)\n\n![When I check what `.*` matches](feather2.jpg)\n\n:::\n\n\n## Intermission: Very important applied regex\n\nThis post is getting long. We need a little break. Well, I need a little break. As it happens, we've now introduced enough regular expression concepts that we can detect all the hissed words in the \"Midnight Pals\" dialog hissed by the JK Rowling character. Here they are:\n\n<br>\n\n\n\n::: {.cell .column-page}\n\n```{.r .cell-code}\nstr_view(midnight, \"\\\\b((\\\\w|')*s{3,}(\\\\w|')*)|(yess)\\\\b\") \n```\n\n<pre> [3] │ Rowling: what <span style='color:#008080'>&lt;newsss&gt;</span>, wormtongue?\n [4] │ Rowling: how goes the infiltration of <span style='color:#008080'>&lt;bluesssky&gt;</span>?\n[17] │ Rowling: <span style='color:#008080'>&lt;door'sss&gt;</span> open, <span style='color:#008080'>&lt;boysss&gt;</span>!\n[20] │ Rowling: i know you did, <span style='color:#008080'>&lt;jesssse&gt;</span>\n[22] │ Rowling: <span style='color:#008080'>&lt;yess&gt;</span> you did great <span style='color:#008080'>&lt;jessse&gt;</span>\n[43] │ Rowling: patience, <span style='color:#008080'>&lt;ssssisster&gt;</span>, we must bide our time\n[54] │ Rowling: sure, <span style='color:#008080'>&lt;jessse&gt;</span> might look like a sniveling worm, a nasty crawling slithering little shit, a spineless craven buffoon\n</pre>\n:::\n\n\n\n<br>\n\nFor a variety of reasons this makes me happy. But let's move on, shall we?\n\n## Backreferences\n\nAt this point we're starting to get into the weeds. I've talked about most of the core features of regular expressions, and to be honest I'd guess that 95% of my regex usage can be accounted for using only the tools described so far. But there are many more fancy tricks you can do with regexes, and the one I use most often is **backreferencing**. \n\nHere's an example. Suppose we are listening to [classical music](https://www.youtube.com/watch?v=wlfE_IplWAU), and we decide we want to detect every instance of a word in [Baby Got Back](https://www.youtube.com/watch?v=X53ZSxkQ3Ho) that begins and ends with the letter `a`. We can do this using the tools we already know. The regular expression `a\\w+a` will match against strings of characters start and end with `a`, so we can extend that to require a *word* starts and end with `a` by placing a word boundary on either side, giving us `\\ba\\w+a\\b` as the regular expression:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(babygotback, \"\\\\ba\\\\w+a\\\\b\")\n```\n\n<pre>[85] │ My <span style='color:#008080'>&lt;anaconda&gt;</span> don't want none\n</pre>\n:::\n\n\n\nBut now suppose that we want to relax this slightly and find all words that start and end with the same (case-matched) letter, regardless of what that letter actually is. For that to work, we need to have the ability to *capture* one part of the regular expression, and then *refer* back to the captured contents elsewhere in the regular expression. The capturing part is straightforward, actually. Earlier when I introduced the `()` notation for groups, I was a little imprecise in my language. By default, anything enclosed in parentheses is treated as a **capture group**, and you can refer back to them numerically: `\\1` is a backreference to the first capture group, `\\2` refers to the second one, and so one.^[There's also a mechanism for naming groups and name-based referencing, but I never use it.] \n\nTo give a simple example, imagine a markup language in which footnotes are specified using markers like `%a%`, `%b%` and so on, and the marker would need to appear on either side of the footnote text itself. Some example strings that you might see:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncomments <- c(\n  \"some text %a%footnote%a% some text\",\n  \"%a% none of this %b% is a footnote\",\n  \"some more text %b%another footnote%b%\"\n)\n```\n:::\n\n\n\nNow consider the regular expression `%[a-z]%`. This will match against `%a%`, `%b%` and so on. Let's have a look at what it detects:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(comments, \"%[a-z]%\")\n```\n\n<pre>[1] │ some text <span style='color:#008080'>&lt;%a%&gt;</span>footnote<span style='color:#008080'>&lt;%a%&gt;</span> some text\n[2] │ <span style='color:#008080'>&lt;%a%&gt;</span> none of this <span style='color:#008080'>&lt;%b%&gt;</span> is a footnote\n[3] │ some more text <span style='color:#008080'>&lt;%b%&gt;</span>another footnote<span style='color:#008080'>&lt;%b%&gt;</span>\n</pre>\n:::\n\n\n\nNext we need to specify this as a capture group, which we do by wrapping it in parentheses. That gives us `(%[a-z]%)` as our regular expression. Because the content of this group is captured, I can insert a `\\1` to refer to the specific text matched by that group. So we could build a regular expression like `(%[a-z]%).*+\\1`, which looks for a footnote marker like `%a%` or `%b%`, followed by some arbitrary text, and then followed by a *matching* footnote marker:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(comments, \"(%[a-z]%).*\\\\1\")\n```\n\n<pre>[1] │ some text <span style='color:#008080'>&lt;%a%footnote%a%&gt;</span> some text\n[3] │ some more text <span style='color:#008080'>&lt;%b%another footnote%b%&gt;</span>\n</pre>\n:::\n\n\n\nIt's a little bit risky to use the `.*` (as I discussed earlier), but it works for this particular problem, and hopefully you get the basic idea.\n\nArmed with this newfound knowledge, we can return to the *Baby Got Backreferences* problem. Earlier on I used the expression `\\ba\\w+a\\b` to detect words that start and end with the letter `a`. To generalise this to \"words that start and end with the same letter\", I can replace the first `a` in this expression with a capture group that will match against any word character (i.e., `(\\w)`), and then replace the second `a` with a backreference `\\1` to that captured group. In other words, we started out with `\\ba\\w+a\\b`, and we modify it to `\\b(\\w)\\w+\\1\\b`. When specified as an R string, we need to add the extra backslashes as usual, and that gives us this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(babygotback, \"\\\\b(\\\\w)\\\\w+\\\\1\\\\b\")\n```\n\n<pre> [15] │ Wanna pull up tough 'cause you notice <span style='color:#008080'>&lt;that&gt;</span> butt was stuffed\n [21] │ But <span style='color:#008080'>&lt;that&gt;</span> butt you got makes (Me-me so horny)\n [24] │ Well, use me, use me 'cause you ain't <span style='color:#008080'>&lt;that&gt;</span> average groupie\n [28] │ Take the average black man and ask him <span style='color:#008080'>&lt;that&gt;</span>\n [33] │ Shake <span style='color:#008080'>&lt;that&gt;</span> healthy butt, baby got back\n [43] │ And when I'm throwin' a <span style='color:#008080'>&lt;gig&gt;</span>\n [51] │ So find <span style='color:#008080'>&lt;that&gt;</span> juicy double\n [53] │ Beggin' for a piece of <span style='color:#008080'>&lt;that&gt;</span> bubble\n [58] │ A word to the thick soul <span style='color:#008080'>&lt;sisters&gt;</span>, I wanna get with ya\n [63] │ A lot of <span style='color:#008080'>&lt;simps&gt;</span> won't like this song\n [65] │ And I'd <span style='color:#008080'>&lt;rather&gt;</span> stay and play\n [78] │ Cosmo ain't got <span style='color:#008080'>&lt;nothin&gt;</span>' to do with my selection\n [85] │ My <span style='color:#008080'>&lt;anaconda&gt;</span> don't want none\n [88] │ But please don't lose <span style='color:#008080'>&lt;that&gt;</span> butt\n [89] │ Some brothers wanna play <span style='color:#008080'>&lt;that&gt;</span> hard role\n [90] │ And tell you <span style='color:#008080'>&lt;that&gt;</span> the butt ain't gold\n [93] │ So Cosmo <span style='color:#008080'>&lt;says&gt;</span> you're fat\n [94] │ Well I ain't down with <span style='color:#008080'>&lt;that&gt;</span>\n[108] │ And <span style='color:#008080'>&lt;kick&gt;</span> them nasty thoughts\n</pre>\n:::\n\n\n\nVictory! Those nasty thoughts have indeed been kicked. \n\n![When the backreference actually works](babygotback1.jpg)\n\n\n## Lookahead/lookbehind\n\nContinuing with the all-important task of matching patterns in the immortal words of Sir Mix-a-Lot, it's time to talk about **lookahead** and **lookbehind**. Suppose I want to find words that begin and end with the letter `\"a\"`, but I don't actually want to include the letter `a` at the end. In other words, I need to \"look ahead\" to check if the `d` in `anaconda` is followed by an `a\\b` (i.e., `a` at the end of the word), but not include the `a\\b` in the match. We can do this by creating a special \"lookahead group\" that encloses the `a\\b`. However, instead of writing `(a\\b)` like we would for a capturing group, we use `(?=` at the start to indicate that it's a lookahead group. In other words, a lookahead group that detects (but does not match) the `a` at the end of `anaconda` is `(?=a\\b)`, and the full regex is `\\ba\\w+(?=a\\b)`. Here's what that looks like when we put it into practice:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(babygotback, \"\\\\ba\\\\w+(?=a\\\\b)\")\n```\n\n<pre>[85] │ My <span style='color:#008080'>&lt;anacond&gt;</span>a don't want none\n</pre>\n:::\n\n\n\nBy analogy to lookahead groups, regular expressions also support lookbehind groups. They're exactly the same concept as a lookahead group, but this time we're looking at the text *preceding* the match rather than the text *following* it. The syntax for a lookbehind group is very similar, but we open the group with `(?<=` to specify that it's lookbehind not lookahead. So, for instance, if we want to detect but not match the first `a` in `anaconda`, we use `(?=a\\b)` to do so. The full regex to exclude both terminal `a` characters is therefore `(?<=\\ba)\\w+(?=a\\b)` and we end up with this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(babygotback, \"(?<=\\\\ba)\\\\w+(?=a\\\\b)\")\n```\n\n<pre>[85] │ My a<span style='color:#008080'>&lt;nacond&gt;</span>a don't want none\n</pre>\n:::\n\n\n\nA slightly more realistic example would be to detect all the text inside a parenthetical, but not including the parentheses themselves. We can do this with a completely unintelligible regex like `(?<=\\()[^)]+(?=\\))`. It's a crime against humanity, but it works:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(babygotback, \"(?<=\\\\()[^)]+(?=\\\\))\")\n```\n\n<pre>[21] │ But that butt you got makes (<span style='color:#008080'>&lt;Me-me so horny&gt;</span>)\n[30] │ So, fellas (<span style='color:#008080'>&lt;Yeah&gt;</span>), Fellas (<span style='color:#008080'>&lt;Yeah&gt;</span>)\n[31] │ Has your girlfriend got the butt? (<span style='color:#008080'>&lt;Hell yeah&gt;</span>)\n[32] │ Tell 'em to shake it (<span style='color:#008080'>&lt;Shake it&gt;</span>) Shake it (<span style='color:#008080'>&lt;Shake it&gt;</span>)\n[36] │ (<span style='color:#008080'>&lt;L.A. face with a Oakland booty&gt;</span>)\n[38] │ (<span style='color:#008080'>&lt;L.A. face with a Oakland booty&gt;</span>)\n[39] │ (<span style='color:#008080'>&lt;L.A. face with a Oakland booty&gt;</span>)\n[60] │ But I gotta be straight when I say I wanna— (<span style='color:#008080'>&lt;Uh&gt;</span>)\n[68] │ So, ladies (<span style='color:#008080'>&lt;Yeah&gt;</span>), Ladies (<span style='color:#008080'>&lt;Yeah&gt;</span>)\n[69] │ If you wanna roll in my Mercedes (<span style='color:#008080'>&lt;Yeah&gt;</span>)\n</pre>\n:::\n\n\n\nAwesome. \n\nOh... by the way? This trick works in tidyverse, but it won't work in base R unless you set `perl = TRUE`, because the default regular expression engine in base R doesn't support lookahead and lookbehind groups.^[That's another one of those fun things where there are in fact three separate flavours of regex in widespread usage in R. ICU (used by stringi and stringr) and PCRE (base R with `perl = TRUE`) both support lookahead and lookbehind assertions, as well as negative lookahead `(?!blah)` and negative lookbehind `(?<!blah)`, but the ERE engine (base R with `perl = FALSE`) does not.] Which seems like a good time to discuss...\n\n\n## Three regex flavours\n\nA persistent headache I have when writing regular expressions, besides the fact that they suck, is that there are so many slight variations on the same idea. At [regular-expressions.info](https://regular-expressions.info), for instance, you can find quick lookup tables for a wide variety of different regular expression engines. It lists [regular expressions in R](https://www.regular-expressions.info/rlanguage.html) as one of those systems, but it's important to remember that this refers to the syntax used by base R tools like `grep()`, `gsub()`, `gregexpr()` and so on. Or, more precisely, it refers to the default POSIX standard for extended regular expressions (ERE). Base R actually supports two different engines, so if you set `perl = TRUE` when calling base R functions then you would need to look at the [rules for PCRE](https://www.regular-expressions.info/pcre.html) (perl compatible regular expressions). In tidyverse, regular expressions are usually handled with the [stringr](https://stringr.tidyverse.org/) package that is built on top of [stringi](https://stringi.gagolewski.com/), which in turn uses the [ICU](https://icu.unicode.org/) engine that conforms to Unicode standards and as such provides comprehensive Unicode support. The [stringi regular expressions](https://stringi.gagolewski.com/weave/regular_expressions.html) page has a nice discussion. \n\nLike an idiot, I forget this on a semi-regular basis, and I try to debug something by looking up the wrong regex syntax and yes, this sometimes matters. For example, when I discussed pre-specified character classes like digits (`\\d`) and word characters (`\\w`), or character ranges like `[0-9]` and `[a-z]`, I made a deliberate decision not to discuss the predefined POSIX classes. These include things like `[[:alpha:]]` that matches alphabetic characters, and `[[:digit:]]` matches numeric digits. The digit and alphabetic character classes are fairly unproblematic, but there's also a `[[:punct:]]` class that is intended to match punctuation characters. I find myself very tempted to use this class because, honestly, who wants to be bothered listing all the punctuation characters by hand? However, it's a *very* bad idea to do this because not only do the results depend on system locale (which is to be expected for anything that involves text), there is absolutely no consistency at all in how this class is implemented in different regex engines. \n\nTo illustrate this I'll use an example that I have shamelessly stolen directly from the [stringi documentation](https://stringi.gagolewski.com/weave/regular_expressions.html#avoiding-posix-classes). But first, because I cannot even with the base R regular expression syntax,^[I mean, wtf. I am genuinely sympathetic to R core, and deeply appreciate their willingness to maintain backward compatibility even for the bits of R that are just bizarre. But oh my god.] I'll define a `base_extract_all()` function that is roughly analogous to `stringr::str_extract_all()`, but uses the base R functions to do the work:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_extract_all <- function(string, pattern, perl = FALSE) {\n  matches <- gregexpr(pattern = pattern, text = string, perl = perl)\n  regmatches(x = string, m = matches)\n}\n```\n:::\n\n\n\nNext I'll define a string `punct`, which contains an assortment of different characters that one might be inclined to call \"punctuation\":\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npunct <- \",./|\\\\><?;:'\\\"[]{}-=_+()*&^%$€#@!`~×‒„”\"\n```\n:::\n\n\n\nSo, what happens when we match `punct` to `\"[[:punct:]]\"`? Well, it depends heavily on which engine you're using. If you're using ERE (i.e., base R with `perl = FALSE`), you get this as the result:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npunct |> \n  base_extract_all(\"[[:punct:]]\") |> \n  unlist() |> \n  cat()\n```\n\n<pre>, . / | \\ > < ? ; : ' \" [ ] { } - = _ + ( ) * & ^ % $ € # @ ! ` ~ × ‒ „ ”\n</pre>\n:::\n\n\n\nWhat about PCRE? Let's set `perl = TRUE` and have a look:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npunct |> \n  base_extract_all(\"[[:punct:]]\", perl = TRUE) |> \n  unlist() |> \n  cat()\n```\n\n<pre>, . / | \\ > < ? ; : ' \" [ ] { } - = _ + ( ) * & ^ % $ # @ ! ` ~\n</pre>\n:::\n\n\n\nOkay yeah that is not even close to being the same thing. But what about the ICU engine? If you're working in tidyverse, internally you're probably relying on this engine and, well...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npunct |> \n  str_extract_all(\"[[:punct:]]\") |> \n  unlist() |> \n  cat()\n```\n\n<pre>, . / \\ ? ; : ' \" [ ] { } - _ ( ) * & % # @ ! ‒ „ ”\n</pre>\n:::\n\n\n\nLe sigh. Of course. Totally different again. \n\nLittle discrepancies like this are the reason why at various different points in the text, I've had to pause and mention things that work differently across the three regex engines used in R. While the differences between the engines are not large, it only takes one tiny difference to mess up an otherwise perfectly crafted regex. Something that looks like it works when you use `stringr::str_detect()` will suddenly break when you use the same regex in `grep()`. \n\nIt is annoying.\n\n![Three rings for the regex kings, under th.. okay yeah that's a bit of a reach](threerings.jpg)\n\n## Backslashes (part II)\n\nWe are getting very close to the end of the post (I promise!), but before I wrap up I want to return to the vexed topic of using the backslash to escape special characters. I talked about this at the beginning of the post, yes, but at that stage we hadn't dived very deep into regular expressions. Since then we've covered a lot more territory, and in the process we've encountered more special characters and more syntax. With that in mind, I'll revisit that subject now and provide a more comprehensive discussion. Additionally, because -- as I've hinted -- the rules *inside* a character set are different to the rules that apply *outside* a character set, I'll handle those two cases separately.\n\n### Special characters outside a character set\n\nOutside of a character set, the characters `+`, `.`, `?`, `*`, and must all be escaped because otherwise they will be interpreted as quantifiers:\n\n- write `\"\\\\+\"` in R to mean `\\+` in the regex, and match a literal `+`\n- write `\"\\\\?\"` in R to mean `\\?` in the regex, and match a literal `?`\n- write `\"\\\\*\"` in R to mean `\\*` in the regex, and match a literal `*`\n\nIt obviously follows that since `\\` is used as the escape character it too must be escaped if you want to treat it as a literal. Moreover, since we've used `|` to represent the \"or\" operator and `.` to represent the \"any\" character, you will not be at all surprised to learn that these also must be escaped if you want to represent them as literal characters:\n\n- write `\"\\\\\\\\\"` in R to mean `\\\\` in the regex, and match a literal `\\`\n- write `\"\\\\|\"` in R to mean `\\|` in the regex, and match a literal `|`\n- write `\"\\\\.\"` in R to mean `\\.` in the regex, and match a literal `.`\n\nTo help make this concrete, here's a minimal example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(string = \"+ . ? * \\\\ |\", pattern = \"\\\\+\")\nstr_view(string = \"+ . ? * \\\\ |\", pattern = \"\\\\*\")\nstr_view(string = \"+ . ? * \\\\ |\", pattern = \"\\\\?\")\nstr_view(string = \"+ . ? * \\\\ |\", pattern = \"\\\\\\\\\")\nstr_view(string = \"+ . ? * \\\\ |\", pattern = \"\\\\|\")\nstr_view(string = \"+ . ? * \\\\ |\", pattern = \"\\\\.\")\n```\n\n<pre>[1] │ <span style='color:#008080'>&lt;+&gt;</span> . ? * \\ |\n[1] │ + . ? <span style='color:#008080'>&lt;*&gt;</span> \\ |\n[1] │ + . <span style='color:#008080'>&lt;?&gt;</span> * \\ |\n[1] │ + . ? * <span style='color:#008080'>&lt;\\&gt;</span> |\n[1] │ + . ? * \\ <span style='color:#008080'>&lt;|&gt;</span>\n[1] │ + <span style='color:#008080'>&lt;.&gt;</span> ? * \\ |\n</pre>\n:::\n\n\n\nThe same logic applies to special characters like `\\n` (line feed) and `\\t` (tab), as well as regular expressions like `\\b` (boundary), `\\w` (word character), and `\\s` (whitespace). This also applies to `\\u`, if we wish to specify a unicode character in the regex. For these characters we need to escape the `\\` in R, in order to match the corresponding literal in the regex: \n\n- write `\"\\\\n\"` in R to mean `\\n` in the regex, and match a line feed\n- write `\"\\\\t\"` in R to mean `\\t` in the regex, and match a tab\n- write `\"\\\\u2300\"` in R to mean `\\u2300` in the regex,  and match a literal `⌀`\n- write `\"\\\\b\"` in R to mean `\\b` in the regex, and match a word boundary\n- write `\"\\\\w\"` in R to mean `\\w` in the regex, and match a word character\n- write `\"\\\\s\"` in R to mean `\\s` in the regex, and match a whitespace character\n\nIt also applies for the anchor characters `^` and `$`:\n\n- write `\"\\\\^\"` in R to mean `\\^` in the regex, and match a literal `^`\n- write `\"\\\\$\"` in R to mean `\\$` in the regex, and match a literal `$`\n\nOn top of this, we have several other characters that need to be escaped within the regex, because brackets, braces, and parentheses have syntactic meaning. However, the rules here are subtle. For the *opening* brace/bracket/parenthesis, you always have to escape:\n\n- write `\"\\\\[\"` in R to mean `\\[` in the regex and match a literal `]`\n- write `\"\\\\(\"` in R to mean `\\(` in the regex and match a literal `]`\n- write `\"\\\\{\"` in R to mean `\\{` in the regex and match a literal `]`\n\nBut for *closing*, the story is different. Specifically, you don't have to escape the closing bracket `]`:\n\n- write `\"]\"` in R to mean `]` in the regex and match a literal `]`\n- write `\"\\\\)\"` in R to mean `\\)` in the regex and match a literal `)`\n- write `\"\\\\}\"` in R to mean `\\}` in the regex and match a literal `}`\n\nTo make this a little clearer, this is how you do it for the opening bracket/parenthesis/brace:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(string = \"[blah] (blah) {blah}\", pattern = \"\\\\[\")\nstr_view(string = \"[blah] (blah) {blah}\", pattern = \"\\\\(\")\nstr_view(string = \"[blah] (blah) {blah}\", pattern = \"\\\\{\")\n```\n\n<pre>[1] │ <span style='color:#008080'>&lt;[&gt;</span>blah] (blah) {blah}\n[1] │ [blah] <span style='color:#008080'>&lt;(&gt;</span>blah) {blah}\n[1] │ [blah] (blah) <span style='color:#008080'>&lt;{&gt;</span>blah}\n</pre>\n:::\n\n\n\nThis is how you do it for the closing ones:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(string = \"[blah] (blah) {blah}\", pattern = \"]\")\nstr_view(string = \"[blah] (blah) {blah}\", pattern = \"\\\\)\")\nstr_view(string = \"[blah] (blah) {blah}\", pattern = \"\\\\}\")\n```\n\n<pre>[1] │ [blah<span style='color:#008080'>&lt;]&gt;</span> (blah) {blah}\n[1] │ [blah] (blah<span style='color:#008080'>&lt;)&gt;</span> {blah}\n[1] │ [blah] (blah) {blah<span style='color:#008080'>&lt;}&gt;</span>\n</pre>\n:::\n\n\n\n\n### Special characters inside a character set\n\nInside a character set (i.e., within a square bracketed expression), the rules are different and inconsistent across regex flavours. For tidyverse (ICU engine) and base R with `perl = TRUE` (PCRE engine), there are four special characters you need to worry about: `]`, `^`, `\\`, and `-`. Everything else can be added to a character set without needing any form of escaping. Here's an example where the character set is comprised of various characters that would normally need to be escaped, but don't need to be escaped inside a character set:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchars <- c(\n  \"+\", \".\", \"?\", \"*\", \"\\\\\", \"|\", \n  \"(\", \")\", \"[\", \"]\", \"{\", \"}\",\n  \"^\", \"$\", \"-\"\n)\nstr_view(chars, \"[a+.?*$|(){}]\")\n```\n\n<pre> [1] │ <span style='color:#008080'>&lt;+&gt;</span>\n [2] │ <span style='color:#008080'>&lt;.&gt;</span>\n [3] │ <span style='color:#008080'>&lt;?&gt;</span>\n [4] │ <span style='color:#008080'>&lt;*&gt;</span>\n [6] │ <span style='color:#008080'>&lt;|&gt;</span>\n [7] │ <span style='color:#008080'>&lt;(&gt;</span>\n [8] │ <span style='color:#008080'>&lt;)&gt;</span>\n[11] │ <span style='color:#008080'>&lt;{&gt;</span>\n[12] │ <span style='color:#008080'>&lt;}&gt;</span>\n[14] │ <span style='color:#008080'>&lt;$&gt;</span>\n</pre>\n:::\n\n\n\nHere's an example where each of the other four special characters *are* escaped. For the sake of my sanity I'll include spaces in the character set. This allows me to write it like this, `[ \\] \\^ \\\\ \\- ]`, and when specified as an R string it looks like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(chars, \"[ \\\\] \\\\\\\\ \\\\^ \\\\- ]\")\n```\n\n<pre> [5] │ <span style='color:#008080'>&lt;\\&gt;</span>\n[10] │ <span style='color:#008080'>&lt;]&gt;</span>\n[13] │ <span style='color:#008080'>&lt;^&gt;</span>\n[15] │ <span style='color:#008080'>&lt;-&gt;</span>\n</pre>\n:::\n\n\n\nIn addition to this, there are a few other handy tricks you can use to make the character set simpler:\n\n- if an unescaped `]` appears as the first element of the character set, it is a literal\n- if an unescaped `^` appears in anything other than the first element, it is also a literal\n- if an unescaped `-` appears as the first or last element, it is a literal:\n\nSo this actually works for detecting right brackets, carets, and hyphens:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(chars, \"[]^-]\")\n```\n\n<pre>[10] │ <span style='color:#008080'>&lt;]&gt;</span>\n[13] │ <span style='color:#008080'>&lt;^&gt;</span>\n[15] │ <span style='color:#008080'>&lt;-&gt;</span>\n</pre>\n:::\n\n\n\nIn all these examples I'm using `str_view()`, so we're using the \"tidyverse style\" regular expressions here based on the ICU engine. If we switch over to base R and set `perl = TRUE` (and hence use the PCRE engine), the results would be the same. However, the rules for the POSIX ERE engine are slightly different. If you're using base R with the default `perl = FALSE` setting, the only character that you can escape within a character set is the backslash itself, so if you want to match `]`, `^`, or `-` then you have to rely on the positional tricks shown above. Here's how you'd do it using the ERE engine:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(grep(\"[]^\\\\\\\\-]\", chars, value = TRUE))\n```\n\n<pre>\\ ] ^ -\n</pre>\n:::\n\n\n\nGod this is exhausting.\n\n\n::: {.column-margin}\n\n![Very much like the show in question, this post is running a little longer than anyone could reasonably have expected](cats.jpg)\n\n:::\n\n## Substitution\n\nThere's one last topic to talk about: substitution. Throughout the post I've focused almost entirely on detecting patterns in text. In base R you might use `grep()` to accomplish this task, whereas in stringr you'd probably use `str_detect()`.^[I know I know. I've mostly used `str_view()` rather than `str_detect()` because it's convenient for visually illustrating the regex match. But you wouldn't work with this in a script] The other main thing I use regular expressions for is making **substitutions**, in which the matched text is replaced by something new. In base R you'd probably use `gsub()` for this, whereas in stringr you'd most likely use `str_replace()` or `str_replace_all()`. \n\nIn most cases where I've had to use it substitution doesn't introduce any new concepts: the \"replacement\" text is usually a fixed string that is inserted wherever a match is found. For example, if I want to replace the word `\"cat\"` with the emoji `\"🐈\"`, I would do something like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(str_replace_all(\n  string = \"if you concatenate two cats you get a catcat\",\n  pattern = \"\\\\bcats?\\\\b\",\n  replacement = \"🐈\"\n))\n```\n\n<pre>if you concatenate two 🐈 you get a catcat\n</pre>\n:::\n\n\n\nOkay yes, in this example I had to do a little bit of work in the `pattern` argument to come up with the regex that I wanted to use to define matches, but the `replacement` argument is very simple. Nothing new here really. \n \nHowever, there are some fancy things that you can do with replacement text. In particular, all three regular expression engines used in R support backreferences within the replacement text. Here it is in all three engines:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na_vile_lie <- \"dogs are better than cats\"\n\n# tidyverse + ICU\ncat(str_replace_all(\n  string = a_vile_lie,\n  pattern = \"(dogs)(.*)(cats)\",\n  replacement = \"\\\\3\\\\2\\\\1\"\n), sep = \"\\n\")\n\n# base R + ERE\ncat(gsub(\n  pattern = \"(dogs)(.*)(cats)\",\n  replacement = \"\\\\3\\\\2\\\\1\",\n  x = a_vile_lie\n), sep = \"\\n\")\n\n# base R + PCRE\ncat(gsub(\n  pattern = \"(dogs)(.*)(cats)\",\n  replacement = \"\\\\3\\\\2\\\\1\",\n  x = a_vile_lie,\n  perl = TRUE\n), sep = \"\\n\")\n```\n\n<pre>cats are better than dogs\ncats are better than dogs\ncats are better than dogs\n</pre>\n:::\n\n\n \nAs an aside, this last example is very closely related to the problem I was trying to solve when I finally broke down and decided to write the post. The thing I actually wanted to do was manipulate text inside parentheses using backreferences in the replacement string, without matching the parentheses themselves. To solve that you need to use backreferences, but you also need to use lookahead and lookbehind functionality:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# tidyverse + ICU\ncat(str_replace_all(\n  string = \"ab(cd)efg[hi]j\",\n  pattern = \"(?<=[\\\\[(])(\\\\w+)(?=[)\\\\]])\",\n  replacement = \"\\\\1,\\\\1\"\n), sep = \"\\n\")\n\n# base R + PCRE\ncat(gsub(\n  pattern = \"(?<=[\\\\[(])(\\\\w+)(?=[)\\\\]])\",\n  replacement = \"\\\\1,\\\\1\",\n  x = \"ab(cd)efg[hi]j\",\n  perl = TRUE\n), sep = \"\\n\")\n```\n\n<pre>ab(cd,cd)efg[hi,hi]j\nab(cd,cd)efg[hi,hi]j\n</pre>\n:::\n\n\n\nIt would be trickier to do this with the ERE engine because it doesn't support lookahead/lookbehind behaviour, but somehow I was convinced it could be done. I ended up reading far too much and... well, this is where we ended up.\n\n## I'm so sorry for my loss\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrules <- tibble::tribble(\n                 ~pattern, ~replacement,\n       \"([Dd]o)(-[Dd]o)+\",         \"🎶\", # do-do, do-do-do -> musical note\n                \"feather\",         \"🪶\", # feather -> emoji feather\n                   \"wine\",         \"🍷\", # wine -> emoji wine\n   \"(?<=\\\\()[Aa]h(?=\\\\))\",         \"😌\", # (ah) -> emoji relief\n     \"\\\\[([^\\\\[\\\\]]+)\\\\]\",         \"🎙️\"  # replace square bracketed text\n)\n\nstr_rewrite <- function(string, rules) {\n  purrr::reduce2(\n    .x = rules$pattern, \n    .y = rules$replacement, \n    .f = str_replace_all, \n    .init = string\n  )\n}\n\nfeather |> \n  str_rewrite(rules) |> \n  cat(sep = \"\\n\")\n```\n\n<pre>🎙️\n(🎶, 🎶, 🎶, 🎶)\n(🎶, 🎶, 🎶, 🎶)\nOh, not another take\n\n🎙️\nOh, it's like that, I'm your dream come true\nWhen it's on a platter for you\nThen you pull back when I try to make plans\nMore than two hours in advance, mm\n\n🎙️\nI slam the door, I hit ignore\nI'm saying, \"No, no, no, no more\"\nI got you blocked, after this, an afterthought\nI finally cut you off\n\n🎙️\nI feel so much lighter like a 🪶 with you off my mind (😌)\nFloatin' through the memories like whatever, you're a waste of time (😌)\nYour signals are mixed, you act like a bitch\nYou fit every stereotype, \"Send a pic\"\nI feel so much lighter like a 🪶 with you out my life\nWith you out my life\n\n🎙️\n(🎶, 🎶, 🎶, 🎶)\n(🎶, 🎶, 🎶, 🎶)\nLike a 🪶, like a 🪶, like a 🪶, yeah\n\n🎙️\nIt feels so good\nNot carin' where you are tonight\nAnd it feels so good\nNot pretendin' to like the 🍷 you like\n\n🎙️\nI slam the door (Slam the door), I hit ignore (Hit ignore)\nI'm saying, \"No, no, no, no more\"\nI got you blocked, excited to never talk, I\nI'm so sorry for your loss\n\n🎙️\nI feel so much lighter like a 🪶 with you off my mind (😌)\nFloatin' through the memories like whatever, you're a waste of time (😌)\nYour signals are mixed, you act like a bitch (A bitch)\nYou fit every stereotype, \"Send a pic\"\nI feel so much lighter like a 🪶 with you out my life\nWith you out my life\n\n🎙️\n(🎶, 🎶, 🎶, 🎶)\nAh, mm\n(🎶, 🎶, 🎶, 🎶)\nLike a 🪶, like a 🪶, like a 🪶\n\n🎙️\nYou want me? I'm done\nYou miss me? No duh\nWhere I'm at, I'm up where I'm at\nYou want me? I'm done (I'm done)\nYou miss me? No duh (No duh)\nWhere I'm at, I'm up (I'm up) where I'm at\n\n🎙️\nYou want me? I'm done\n(I feel so much lighter like a 🪶 with you off my mind)\nYou miss me? No duh\nWhere I'm at, I'm up where I'm at\n(Like a 🪶, like a 🪶, like a 🪶)\nYou want me? I'm done\n(I feel so much lighter like a 🪶 with you off my mind)\nYou miss me? No duh\nWhere I'm at, I'm up where I'm at\n(Like a 🪶, like a 🪶, like a 🪶, yeah)\n</pre>\n:::\n\n\n\n\n<!--\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmidnight |> \n  str_replace_all(\"(JK )?Rowling\", \"🧛‍♀️\") |> \n  str_replace_all(\"(Jesse )?Singal\", \"🪱️\") |> \n  str_replace_all(\"(Helen )?Joyce\", \"🧟‍♀️\") |> \n  str_wrap() |> \n  cat(sep = \"\\n\")\n```\n\n<pre>[mysterious circle of robed figures]\n🧛‍♀️: hello children\n🧛‍♀️: what newsss, wormtongue?\n🧛‍♀️: how goes the infiltration of bluesssky?\n🪱️: mommy mommy\n🪱️: it was SO HARD\n🪱️: the trans were SO MEAN\n🪱️: they all blocked me!\n🪱️: i was almost ignored to death!\n\n🧛‍♀️: you poor child\n🪱️: but i did it mommy\n🪱️: every single person on the site told them to ban me\n🪱️: but i'm way more important than any of them!\n🪱️: so i can stay!\n🧛‍♀️: excellent!\n🧛‍♀️: door'sss open, boysss!\n\n🪱️: mommy i fought so hard for you\n🧛‍♀️: i know you did, jesssse\n🪱️: i did it all for you mommy\n🧛‍♀️: yess you did great jessse\n🪱️: i asked all those questions just for you mommy\n🧛‍♀️: yeah thats great\n🪱️: i had all those reasonable concerns just for you mommy\n\n🪱️: mommy mommy the trans were so mean, they said mean things about me on the\ninternet\n🪱️: i don't know how they could do that!\n🪱️: they just don't understand how much it hurts to have people say mean things\nabout you on the internet!\n🪱️: they just can't relate!\n\n🪱️: it hurts when people say mean things about me on the internet!\n🪱️: the trans don't understand\n🪱️: they have their hard reptilian hides to protect them\n🪱️: but i'm not a monster like them, i'm a person!\n🪱️: i have feelings!\n\n🪱️: mommy they were so mean\n🪱️: my feelings are so hurt\n🪱️: kiss it and make it better mommy\n🧟‍♀️: do we\n🧟‍♀️: do we really need to keep this guy around?\n🧛‍♀️: patience, ssssisster, we must bide our time\n🧟‍♀️: you don't have ANYONE else who could do this?\n🪱️: mommy mommy\n\n🧟‍♀️: i mean, we don't have anyone else who could launder transphobia into\nrespectable liberal discourse?\n🧟‍♀️: anyone at all\n🧛‍♀️: well i really thought tatsuya ishida was going to be ready for prime time by\nnow\n🧛‍♀️: but we missed that window\n🧛‍♀️: now he's overripe\n\n🧛‍♀️: oh helen you don't understand\n🧛‍♀️: sure, jessse might look like a sniveling worm, a nasty crawling slithering\nlittle shit, a spineless craven buffoon\n🧛‍♀️: but damn if he isn't the best reasonable concern haver in the business\n\n🪱️: mommy mommy they were so mean to me\n🪱️: i was unfairly judged, just like a child molester is unfairly judged!\n🧛‍♀️:\n🧛‍♀️:\n🧛‍♀️:\n🧛‍♀️:\n</pre>\n:::\n\n\n\n-->\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}