{
  "hash": "e59bbd00340c5a22317875c1f17a7067",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Scatterplot matrices with pairwise pivoting\"\ndescription: \"As with so many things in life, something that I used to think was infuriatingly difficult and cumbersome turns out to be really easy if you just format the data properly\"\ncategories: [\"R\", \"Data Visualisation\", \"Data Wrangling\"]\ndate: \"2025-06-03\"\nimage: \"absurdity.png\"\nimage-alt: \"An unlabelled scatterplot matrix with convex hull annotations\"\n--- \n\n\n\n<!--------------- my typical setup ----------------->\n\n\n\n\n\n\n\n<!--------------- post begins here ----------------->\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\nEverybody loves a good data visualisation. I love plots as much as the next weirdo, and I love tinkering with ggplot2 and other tools that let me design them the way I want them to look. It's fun, and it makes me attractive, and popular, and scientific. Yay for plots.\n\nThe dirty truth about plotting data though, is that a distressingly large proportion of the work that goes into making a data visualisation happens before you even get to the fun plotting part. So often all the hard work is done at the data wrangling stage: getting the *data* into the form that it needs to be in order to create the pretty pictures all the boys love me for.^[Shut up it's my fantasy, let a girl dream okay?]\n\nI've written about this before. When I talked about [how to visualise a billion rows of data in R](/posts/2022-08-23_visualising-a-billion-rows/), I spent waaaaaaay more time talking about the data wrangling than about the data visualisation itself. That's where all the hard work is done.\n\nAnd so it is with considerable displeasure that I come to the vexing topic of drawing scatterplot matrices in ggplot2. As a mathematical psychologist this was a task I had to perform regularly and it annoyed me. As a data scientist, it was also a task I had to perform regularly, and it annoyed me. But now I am a pharmacometrician,^[Apparently.] and... yep, I still have to perform this task regularly, and it still annoys me.\n\nSomething about it feels *wrong*. It feels wrong because the data set that the analyst is using for other purposes is almost always mismatched to the format that the data needs to be in to make the plot effortless. Here's what I mean, let's say I'm working with our bestest friend, the Palmer penguins data. It looks like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins <- datasets::penguins |>\n    tibble::as_tibble()\n\npenguins\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 8\n   species island    bill_len bill_dep flipper_len body_mass sex     year\n   <fct>   <fct>        <dbl>    <dbl>       <int>     <int> <fct>  <int>\n 1 Adelie  Torgersen     39.1     18.7         181      3750 male    2007\n 2 Adelie  Torgersen     39.5     17.4         186      3800 female  2007\n 3 Adelie  Torgersen     40.3     18           195      3250 female  2007\n 4 Adelie  Torgersen     NA       NA            NA        NA <NA>    2007\n 5 Adelie  Torgersen     36.7     19.3         193      3450 female  2007\n 6 Adelie  Torgersen     39.3     20.6         190      3650 male    2007\n 7 Adelie  Torgersen     38.9     17.8         181      3625 female  2007\n 8 Adelie  Torgersen     39.2     19.6         195      4675 male    2007\n 9 Adelie  Torgersen     34.1     18.1         193      3475 <NA>    2007\n10 Adelie  Torgersen     42       20.2         190      4250 <NA>    2007\n# ℹ 334 more rows\n```\n\n\n:::\n:::\n\n\n\nThis data makes sense. It is *tidy*. There is one row per penguin, and one column per measurement. We love data in this format. But suppose I wanted to draw a scatterplot matrix, to visualise the relationships between bill length, bill depth, flipper length, etc, perhaps with each penguin species plotted in a different colour. Intuitively what I *want* to do in ggplot2 is treat each separate pairwise plot as a facet, and then use something like `facet_grid()` to give me a plot that looks like this:\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/demo-plot-1.png){width=672}\n:::\n:::\n\n\n\nHowever, you can't easily do this with ggplot2, not with the `penguins` data in its current form. So what people (including me) usually do, because life is short and scatterplot matrices suck, is fall back on a canned solution like `GGally::ggpairs()` to do the work. As much as I respect the amount of work that has gone into this function -- and I really do it's awesome -- it is essentially a canned plot, and it suffers from the inherent problem that attaches to all canned plots. Whenever you want something that isn't already catered to by one of the various customisation features supplied the plot function, you're forced to adopt horrible hacks.^[In fairness to the authors, if you do a deep dive on `ggpairs()` you might be surprised at how impressively customisable it is. I'm pretty sure that with some careful thought I could recreate and of the plots below purely with `ggpairs()`. It's just that... well, I don't want to. I already understand ggplot2, I don't want to have to learn a new thing.] On many occasions when I have used `ggpairs()` I've found myself diving into the source code to try to work out precisely what kind of plot object it produces, just so that I can tinker with one tiny little thing that is specific to my use case that (quite understandably) the authors of GGally were unable to predict in advance.\n\nIt is very frustrating, and for years I have thought that there must be a better way. It turns out that there is, and it's not very hard. All you have to do is stop thinking of this as a visualisation problem and instead think of it as a data wrangling problem. As is so often the case in life, once you think about the problem in the right terms, it becomes sooooooo much easier to solve. \n\n## The desired functionality\n\nLet us imagine, for the moment, that we had a function called `pivot_pairwise()` with arguments similar to those in the lovely `tidyr::pivot_longer()` function. It would have arguments like these:\n\n- `pivot_cols` provides a [tidy selection](https://tidyr.tidyverse.org/reference/tidyr_tidy_select.html) of columns. These columns are the ones that we need in \"pairwise\" format. That is, for each penguin we want one row for each pair of measurements: there would be one row for the combination of `bill_len` and `bill_dep`, another row for the combination of `bill_leng` and `flipper_len`, and so on. \n- `other_cols` is also a tidy selection of columns, but this time for those variables that you will want to use in your plot but aren't actually part of the \"pairwise\" specification. In our example, `species` is the only one we need: later on we will want to colour each dot by species, but it's not one of the rows or columns in our scatterplot matrix\n- Because each penguin will now correspond to many rows there would be a `row_id` argument that specifies the name of a newly-inserted column that would be used as an identifier for each individual penguin\n- There would also be `names_to` and `values_to` arguments, which work much the same way the same arguments in `pivot_longer()` work. We would use `names_to` to specify the name of the column that stores the variable names, and `values_to` would be a string specifying the name of the column storing the measured values for each variable.\n\nIf we did in fact have access to wonderful magical fabulous function like this, we could effortly pivot the `penguins` data into a new pairwise format like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguin_paired_measurements <- penguins |>\n    pivot_pairwise(\n        pivot_cols = bill_len:body_mass,\n        other_cols = species,\n        row_id = \"penguin\",\n        names_to = \"var\",\n        values_to = \"val\"\n    )\n\npenguin_paired_measurements\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5,504 × 6\n   penguin x_var       y_var       x_val  y_val species\n     <int> <chr>       <chr>       <dbl>  <dbl> <fct>  \n 1       1 bill_len    bill_len     39.1   39.1 Adelie \n 2       1 bill_len    bill_dep     39.1   18.7 Adelie \n 3       1 bill_len    flipper_len  39.1  181   Adelie \n 4       1 bill_len    body_mass    39.1 3750   Adelie \n 5       1 bill_dep    bill_len     18.7   39.1 Adelie \n 6       1 bill_dep    bill_dep     18.7   18.7 Adelie \n 7       1 bill_dep    flipper_len  18.7  181   Adelie \n 8       1 bill_dep    body_mass    18.7 3750   Adelie \n 9       1 flipper_len bill_len    181     39.1 Adelie \n10       1 flipper_len bill_dep    181     18.7 Adelie \n# ℹ 5,494 more rows\n```\n\n\n:::\n:::\n\n\n\nOnce you have the data in this format you can tackle it with ggplot2 in exactly the same way you would any other data visualisation problem:^[Normally this would throw a ggplot2 warning about missing values. I've suppressed those here because they're ugly and somewhat irrelevant to the point of this post.]\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\npenguin_paired_measurements |>\n    ggplot(aes(x_val, y_val, colour = species)) +\n    geom_point() +\n    facet_grid(y_var ~ x_var, scales = \"free\") + \n    theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\nClearly not perfect, and some tinkering will be needed so that we can get the actual plot we're looking for but... it now feels like a normal ggplot2 exercise. Because we have the data in the format that is natural for the plot, writing the code for the visualisation no longer seems like an exercise in smashing your head agains a wall or trying to explain to people why there is not and should not be a \"straight pride\" month.^[Some personal recollections on this topic [here](https://etc.djnavarro.net/007/straight-pride/). Be warned, it ain't pretty.]\n\n\n\n## The code\n\nTo my everlasting embarrassment, the moment I realised that this was a data formatting issue and not a data visualisation issue, it took me less than an hour to write a basic version of the `pivot_pairwise()` function. I'm writing this post on a very strict time budget because I have actual client work that needs to be attended to, so let's cut to the chase and present the code:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npivot_pairwise <- function(data, \n                           pivot_cols, \n                           other_cols = !pivot_cols,\n                           names_to = \"name\",\n                           values_to = \"value\",\n                           pair_label = c(\"x\", \"y\"),\n                           pair_label_sep = \"_\",\n                           row_id = \"row_id\") {\n\n    # construct variable names\n    x_value <- paste(pair_label[1], values_to, sep = pair_label_sep)\n    y_value <- paste(pair_label[2], values_to, sep = pair_label_sep)\n    x_name  <- paste(pair_label[1], names_to, sep = pair_label_sep)\n    y_name  <- paste(pair_label[2], names_to, sep = pair_label_sep)\n\n    # create an id column\n    base <- data |> \n        dplyr::mutate({{row_id}} := dplyr::row_number())\n  \n    # variables to be retained but not pairwise-pivoted\n    fixed_data <- base |> \n        dplyr::select(\n            {{other_cols}}, \n            tidyselect::all_of(row_id)\n        )\n    \n    # select pivoting columns, pivot to long, and relabel as x-var \n    long_x <- base |>\n        dplyr::select(\n            {{pivot_cols}},            \n            tidyselect::all_of(row_id)\n        ) |>\n        tidyr::pivot_longer(\n            cols = {{pivot_cols}},\n            names_to = {{x_name}},\n            values_to = {{x_value}}\n        )\n\n    # same data frame, but with new variable names for pivoted vars\n    long_y <- long_x |> \n        dplyr::rename(\n            {{y_name}} := {{x_name}}, \n            {{y_value}} := {{x_value}}\n        )\n\n    # full join with many-to-many gives all pairs; then restore other columns\n    pairs <- dplyr::full_join(\n        x = long_x,\n        y = long_y,\n        by = row_id,\n        relationship = \"many-to-many\"\n    ) |>\n    dplyr::relocate({{y_name}}, .after = {{x_name}}) |>\n    dplyr::left_join(fixed_data, by = row_id)\n    \n    return(pairs)\n}\n```\n:::\n\n\n\nIt looks a little fancy because I wanted to properly support tidy selection, and I wanted the usage to feel similar to `pivot_longer()` but in truth it's very simple. I'm just doing a pivot and a couple of dplyr joins. It's really simple, so much so that a part of me is wondering if I missed something shockingly obvious? Like, doesn't this already exist as a function somewhere? If not, it ought to.^[I later learned that there are indeed similar approaches elsewhere. The `tidybayes::gather_pairs()` function provides much the same functionality by operating directly on the data the same way that `pivot_pairwise()` does, but it predates both `pivot_longer()` and the tidy selection framework so the syntax is a bit different and you can't pass a tidy selection. Alternatively, I've been told that `ggforce::facet_matrix()` allows you to accomplish some of the same results entirely within ggplot2. I can imagine either of those being useful in different situations.]\n\n## Plotting the pivoted data\n\nAs I hinted at previously the nice thing about having the data in the `penguin_paired_measurements` format is that we can now tinker with the plot in all sorts of fun and exciting ways. To do this, I'll quietly replace the `ggplot2::facet_grid()` function with the `ggh4x::facet_grid2()` function. It does roughly the same thing but has some extra functionality that comes in handy here. For example, if I use `dplyr::filter()` to remove the pointless data on the main diagonal of the scatterplot matrix, `facet_grid2()` allows me to remove those facets entirely by setting `render_empty = FALSE`: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguin_paired_measurements |>\n    dplyr::filter(y_var != x_var) |>\n    ggplot(aes(x_val, y_val, colour = species)) +\n    geom_point() +\n    ggh4x::facet_grid2(\n        y_var ~ x_var,\n        scales = \"free\",\n        render_empty = FALSE\n    ) +\n    labs(x = NULL, y = NULL) +\n    theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/paired-plot-drop-diagonal-1.png){width=672}\n:::\n:::\n\n\n\nThat's neat, but of course I could take this further and choose to plot only the lower triangular panels, in a style similar to how `ggpairs()` works by default. That requires only very minor edits to the code:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguin_paired_measurements |>\n    dplyr::filter(y_var > x_var) |>\n    ggplot(aes(x_val, y_val, colour = species)) +\n    geom_point() +\n    ggh4x::facet_grid2(\n        y_var ~ x_var,\n        scales = \"free\",\n        switch = \"both\",\n        render_empty = FALSE\n    ) +\n    labs(x = NULL, y = NULL) +\n    theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/paired-plot-lower-triangular-1.png){width=672}\n:::\n:::\n\n\n\nRendering my scatterplots as upper triangular matrix is equally simple:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguin_paired_measurements |>\n    dplyr::filter(x_var > y_var) |>\n    ggplot(aes(x_val, y_val, colour = species)) +\n    geom_point() +\n    ggh4x::facet_grid2(\n        y_var ~ x_var,\n        scales = \"free\",\n        render_empty = FALSE\n    ) + \n    ggplot2::scale_x_continuous(position = \"top\") + \n    ggplot2::scale_y_continuous(position = \"right\") +\n    labs(x = NULL, y = NULL) +\n    theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/paired-plot-upper-triangular-1.png){width=672}\n:::\n:::\n\n\n\n\nI'm not sure why I would want to do this, but if for some reason I actually did, I could take it even further and use functionality like `ggforce::geom_mark_hull()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguin_paired_measurements |>\n    dplyr::filter(y_var > x_var) |>\n    ggplot(aes(x_val, y_val, colour = species)) +\n    ggforce::geom_mark_hull(aes(fill = species)) +\n    geom_point() +\n    ggh4x::facet_grid2(\n        y_var ~ x_var,\n        scales = \"free\",\n        switch = \"both\",\n        render_empty = FALSE\n    ) +\n    labs(x = NULL, y = NULL) +\n    theme_bw() + \n    theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/paired-plot-with-hulls-1.png){width=672}\n:::\n:::\n\n\n\n\nYou can do anything with [properly formatted data](https://zombo.com/). \n\nAnything at all. \n\nThe only limit is yourself.\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/absurdity-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}