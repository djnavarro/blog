{
  "hash": "756dfa39a5f5b7241d66895df49b3ff1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"The schools of magic\"\ndescription: \"Code and explanations for a Tidy Tuesday data visualisation exercise\"\ndate: \"2025-01-01\"\ncategories: [\"R\", \"Data Visualisation\", \"Tidy Tuesday\"]\nimage: \"basic.jpg\"\nimage-alt: \"Dragon picture on the cover of the D&D basic rules, a.k.a. 'The Red Box'\"\n--- \n\n\n\n<!--------------- my typical setup ----------------->\n\n\n\n\n\n\n\n<!--------------- post begins here ----------------->\n\n\nIn the dying days of 2024 I found myself doing [Tidy Tuesday](https://www.tidytuesday.com/) again. I really like playing around with data wrangling and visualisation in these exercises, and I wish I were able to find the time to do it more often. But life so often gets in the way, and I suppose I should simply be happy that I get to do it sometimes. Anyway, one of the recent Tidy Tuesday data sets is related to Dungeons & Dragons, which I used to play when I was a teenager, and my children are pestering me to play again now that they're old enough to get into it. So I decided to play around with this data set as part of a totally unrelated side project (for a different post!) and I ended up posting these two images to social media:\n\n::: {.column-page layout=\"[2,1]\"}\n\n![](dice.png)\n\n![](schools.png)\n\n:::\n\nA couple of people emailed me asking for the code for these, and I haven't gotten around to replying to them yet. Part of the reason I didn't reply initially was that the code was tangled up with the code for the other side project, which made it a little awkward to explain without going down a whole other rabbit hole. \n\nSo now I find myself rewriting the code in a slightly more palatable form and posting it to this blog. I mean, why not? It's the first day of a new year, and I have nothing better to do this morning.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(purrr)\nlibrary(readr)\nlibrary(tibble)\nlibrary(ggplot2)\nlibrary(stringr)\nlibrary(forcats)\nlibrary(ggrepel)\nlibrary(legendry)\n```\n:::\n\n\n\n## The spells data\n\nThe `spells` data that I'm using here comes from the [TidyTuesday D&D Spells](https://github.com/rfordatascience/tidytuesday/tree/main/data/2024/2024-12-17) data set. The data set was compiled by Jon Harmon, and originates in the recently released [Dungeons & Dragons Free Rules](https://www.dndbeyond.com/sources/dnd/free-rules). If you've played D&D before, this should be quite familiar:\n\n\n\n::: {.cell print='print_tinker'}\n\n```{.r .cell-code}\nspells <- read_csv(\"./spells.csv\", show_col_types = FALSE)\nprint(spells)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 314 × 27\n   name      level school bard  cleric druid paladin ranger sorcerer warlock\n   <chr>     <dbl> <chr>  <lgl> <lgl>  <lgl> <lgl>   <lgl>  <lgl>    <lgl>  \n 1 Acid Spl…     0 evoca… FALSE FALSE  FALSE FALSE   FALSE  TRUE     FALSE  \n 2 Aid           2 abjur… TRUE  TRUE   TRUE  TRUE    TRUE   FALSE    FALSE  \n 3 Alarm         1 abjur… FALSE FALSE  FALSE FALSE   TRUE   FALSE    FALSE  \n 4 Alter Se…     2 trans… FALSE FALSE  FALSE FALSE   FALSE  TRUE     FALSE  \n 5 Animal F…     1 encha… TRUE  FALSE  TRUE  FALSE   TRUE   FALSE    FALSE  \n 6 Animal M…     2 encha… TRUE  FALSE  TRUE  FALSE   TRUE   FALSE    FALSE  \n 7 Animal S…     8 trans… FALSE FALSE  TRUE  FALSE   FALSE  FALSE    FALSE  \n 8 Animate …     3 necro… FALSE TRUE   FALSE FALSE   FALSE  FALSE    FALSE  \n 9 Animate …     5 trans… TRUE  FALSE  FALSE FALSE   FALSE  TRUE     FALSE  \n10 Antilife…     5 abjur… FALSE FALSE  TRUE  FALSE   FALSE  FALSE    FALSE  \n# ℹ 304 more rows\n# ℹ 17 more variables: wizard <lgl>, casting_time <chr>, action <lgl>,\n#   bonus_action <lgl>, reaction <lgl>, ritual <lgl>,\n#   casting_time_long <chr>, trigger <chr>, range <chr>, range_type <chr>,\n#   verbal_component <lgl>, somatic_component <lgl>,\n#   material_component <lgl>, material_component_details <chr>,\n#   duration <chr>, concentration <lgl>, description <chr>\n```\n\n\n:::\n:::\n\n\n\nIf you don't already know what you're looking at, here's a quick summary of the columns that I'm actually using for these plots:\n\n- `name`: the name of the spell, obviously\n- `level`: the spell difficulty level, with level 0 spells (cantrips) being the easiest and level 9 being the most difficult\n- `school`: which of the nine schools of magic (e.g., enhantment, illusion, necromancy, etc) does this spell belong to?\n- `bard`, `cleric`, `druid`, etc: is this spell learnable by characters that belong to this class?\n- `description`: the text for the spell description\n\nThe values stored in most of these variables are pretty straightforward, but it's probably useful to look at the `description` variable in particular since that one is a long string. Here's a few spell descriptions:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndescribe_spell <- function(spell = NULL) {\n  if (is.null(spell)) spell <- sample(spells$name, 1L)\n  spells |> \n    filter(name == spell) |> \n    pull(description) |> \n    str_wrap(width = 70) |> \n    cat()\n}\n\ndescribe_spell(\"Acid Splash\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nYou create an acidic bubble at a point within range, where it explodes\nin a 5-foot-radius Sphere. Each creature in that Sphere must succeed\non a Dexterity saving throw or take 1d6 Acid damage. Cantrip Upgrade.\nThe damage increases by 1d6 when you reach levels 5 (2d6), 11 (3d6),\nand 17 (4d6).\n```\n\n\n:::\n\n```{.r .cell-code}\ndescribe_spell(\"Fireball\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nA bright streak flashes from you to a point you choose within range\nand then blossoms with a low roar into a fiery explosion. Each\ncreature in a 20-foot-radius Sphere centered on that point makes a\nDexterity saving throw, taking 8d6 Fire damage on a failed save or\nhalf as much damage on a successful one. Flammable objects in the area\nthat aren’t being worn or carried start burning. Using a Higher-Level\nSpell Slot. The damage increases by 1d6 for each spell slot level\nabove 3.\n```\n\n\n:::\n\n```{.r .cell-code}\ndescribe_spell(\"Prismatic Spray\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nEight rays of light flash from you in a 60-foot Cone. Each creature\nin the Cone makes a Dexterity saving throw. For each target, roll 1d8\nto determine which color ray affects it, consulting the Prismatic Rays\ntable. Prismatic Rays 1d8 Ray 1 Red. Failed Save: 12d6 Fire damage.\nSuccessful Save: Half as much damage. 2 Orange. Failed Save: 12d6 Acid\ndamage. Successful Save: Half as much damage. 3 Yellow. Failed Save:\n12d6 Lightning damage. Successful Save: Half as much damage. 4 Green.\nFailed Save: 12d6 Poison damage. Successful Save: Half as much damage.\n5 Blue. Failed Save: 12d6 Cold damage. Successful Save: Half as much\ndamage. 6 Indigo. Failed Save: The target has the Restrained condition\nand makes a Constitution saving throw at the end of each of its turns.\nIf it successfully saves three times, the condition ends. If it fails\nthree times, it has the Petrified condition until it is freed by an\neffect like the Greater Restoration spell. The successes and failures\nneedn’t be consecutive; keep track of both until the target collects\nthree of a kind. 7 Violet. Failed Save: The target has the Blinded\ncondition and makes a Wisdom saving throw at the start of your next\nturn. On a successful save, the condition ends. On a failed save,\nthe condition ends, and the creature teleports to another plane of\nexistence (DM’s choice). 8 Special. The target is struck by two rays.\nRoll twice, rerolling any 8.\n```\n\n\n:::\n:::\n\n\n\n::: {.column-margin}\n\n![D&D Boxed Set: Basic Rules](basic.jpg)\n\n:::\n\n## The spell dice plot\n\nReading these spell descriptions I had the thought that it would be interesting to explore the distribution of dice rolls mentioned in the spell descriptions. In the description for \"Acid Splash\", for example, it refers to a 1d6 roll, a 2d6 roll, a 3d6 roll, and a 4d6 roll. \"Fireball\" mentions 8d6 and 1d6 in the text. What does the distribution of these dice rolls look like.\n\n### Data wrangling\n\nTo start with let's think about what information we want to extract from the spell descriptions, and how we want to do it. Using `str_extract_all()` and a bit of [regular expression sorcery](/posts/2024-12-16_regex-backreferences/), we can pull this information out of a description. Here's what we get for the three spells I listed above:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspells |> \n  filter(name %in% c(\"Acid Splash\", \"Fireball\", \"Prismatic Spray\")) |> \n  pull(description) |> \n  str_extract_all(\"\\\\b\\\\d+d\\\\d+\\\\b\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"1d6\" \"1d6\" \"2d6\" \"3d6\" \"4d6\"\n\n[[2]]\n[1] \"8d6\" \"1d6\"\n\n[[3]]\n[1] \"1d8\"  \"1d8\"  \"12d6\" \"12d6\" \"12d6\" \"12d6\" \"12d6\"\n```\n\n\n:::\n:::\n\n\n\nThis list highlights a decision we need to make about counting tokens: in the \"Prismatic Spray\" description, there are five separate mentions of a 12d6 dice roll. Do we want to count all five of these, or to we want to consider unique mentions only? After a bit of thought I ended up going with the latter, so the extraction code would look like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspells |> \n  filter(name %in% c(\"Acid Splash\", \"Fireball\", \"Prismatic Spray\")) |> \n  pull(description) |> \n  str_extract_all(\"\\\\b\\\\d+d\\\\d+\\\\b\") |> \n  map(unique)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"1d6\" \"2d6\" \"3d6\" \"4d6\"\n\n[[2]]\n[1] \"8d6\" \"1d6\"\n\n[[3]]\n[1] \"1d8\"  \"12d6\"\n```\n\n\n:::\n:::\n\n\n\nDoing this within a data frame produces a `dice_txt` list column:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspells |>\n  select(name, level, description) |>\n  mutate(\n    dice_txt = description |> \n      str_extract_all(\"\\\\b\\\\d+d\\\\d+\\\\b\") |> \n      map(unique)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 314 × 4\n   name              level description                              dice_txt\n   <chr>             <dbl> <chr>                                    <list>  \n 1 Acid Splash           0 \"You create an acidic bubble at a point… <chr>   \n 2 Aid                   2 \"Choose up to three creatures within ra… <chr>   \n 3 Alarm                 1 \"You set an alarm against intrusion. Ch… <chr>   \n 4 Alter Self            2 \"You alter your physical form. Choose o… <chr>   \n 5 Animal Friendship     1 \"Target a Beast that you can see within… <chr>   \n 6 Animal Messenger      2 \"A Tiny Beast of your choice that you c… <chr>   \n 7 Animal Shapes         8 \"Choose any number of willing creatures… <chr>   \n 8 Animate Dead          3 \"Choose a pile of bones or a corpse of … <chr>   \n 9 Animate Objects       5 \"Objects animate at your command. Choos… <chr>   \n10 Antilife Shell        5 \"An aura extends from you in a 10-foot … <chr>   \n# ℹ 304 more rows\n```\n\n\n:::\n:::\n\n\n\nList columns aren't the easiest thing to visualise, so I'll use the `unnest_longer()` function to produce a tidy data set that has one row per unique dice roll mention:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspells |>\n  select(name, level, description) |>\n  mutate(\n    dice_txt = description |> \n      str_extract_all(\"\\\\b\\\\d+d\\\\d+\\\\b\") |> \n      map(unique)\n  ) |> \n  unnest_longer(\n    col = \"dice_txt\",\n    values_to = \"dice_txt\",\n    indices_to = \"position\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 236 × 5\n   name            level description                       dice_txt position\n   <chr>           <dbl> <chr>                             <chr>       <int>\n 1 Acid Splash         0 \"You create an acidic bubble at … 1d6             1\n 2 Acid Splash         0 \"You create an acidic bubble at … 2d6             2\n 3 Acid Splash         0 \"You create an acidic bubble at … 3d6             3\n 4 Acid Splash         0 \"You create an acidic bubble at … 4d6             4\n 5 Alter Self          2 \"You alter your physical form. C… 1d6             1\n 6 Animate Objects     5 \"Objects animate at your command… 1d4             1\n 7 Animate Objects     5 \"Objects animate at your command… 1d6             2\n 8 Animate Objects     5 \"Objects animate at your command… 1d12            3\n 9 Animate Objects     5 \"Objects animate at your command… 2d6             4\n10 Animate Objects     5 \"Objects animate at your command… 2d12            5\n# ℹ 226 more rows\n```\n\n\n:::\n:::\n\n\n\nWith a little more data wrangling, we can carve up a `dice_txt` value like \"3d6\" into the number of dice to be rolled (i.e. `die_num` is 3), the number of sides on the die to be rolled (i.e., `die_die` is 6), and the average value that you'd get from rolling these dice (i.e., `die_val` is 10.5). Here's the final processed data:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndice_dat <- spells |>\n  select(name, level, description) |>\n  mutate(\n    dice_txt = description |> \n      str_extract_all(\"\\\\b\\\\d+d\\\\d+\\\\b\") |> \n      map(unique)\n  ) |> \n  unnest_longer(\n    col = \"dice_txt\",\n    values_to = \"dice_txt\",\n    indices_to = \"position\"\n  ) |>\n  mutate(\n    dice_num = dice_txt |> str_extract(\"\\\\d+(?=d)\") |> as.numeric(),\n    dice_die = dice_txt |> str_extract(\"(?<=d)\\\\d+\") |> as.numeric(),\n    dice_val = dice_num * (dice_die + 1)/2,\n    dice_txt = factor(dice_txt) |> fct_reorder(dice_val)\n  )\n\nprint(dice_dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 236 × 8\n   name       level description dice_txt position dice_num dice_die dice_val\n   <chr>      <dbl> <chr>       <fct>       <int>    <dbl>    <dbl>    <dbl>\n 1 Acid Spla…     0 \"You creat… 1d6             1        1        6      3.5\n 2 Acid Spla…     0 \"You creat… 2d6             2        2        6      7  \n 3 Acid Spla…     0 \"You creat… 3d6             3        3        6     10.5\n 4 Acid Spla…     0 \"You creat… 4d6             4        4        6     14  \n 5 Alter Self     2 \"You alter… 1d6             1        1        6      3.5\n 6 Animate O…     5 \"Objects a… 1d4             1        1        4      2.5\n 7 Animate O…     5 \"Objects a… 1d6             2        1        6      3.5\n 8 Animate O…     5 \"Objects a… 1d12            3        1       12      6.5\n 9 Animate O…     5 \"Objects a… 2d6             4        2        6      7  \n10 Animate O…     5 \"Objects a… 2d12            5        2       12     13  \n# ℹ 226 more rows\n```\n\n\n:::\n:::\n\n\n\nNotice that this processed version of the data codes `dice_txt` as a factor, and the levels are arranged by increasing `dice_val`. That's the mechanism by which the die rolls will be ordered sensibly in the plot. \n\n::: {.column-margin}\n\n![D&D Boxed Set: Expert Rules](expert.jpg)\n\n:::\n\n### Making the plot\n\nA basic version of the plot we want to create looks like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(dice_dat, aes(dice_txt, fill = factor(level))) + geom_bar()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\nThere's a lot of tinkering required to make it look pretty, but this is essentially the data we want to display and the format we want it to be displayed in. The full code for the visualisation looks like this:    \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npalette <- hcl.colors(n = 10, palette = \"PuOr\")\n\nlabs <- dice_dat |>\n  summarise(\n    dice_txt = first(dice_txt),\n    count = n(),\n    .by = dice_txt\n  )\n\npic <- ggplot(\n  data = dice_dat,\n  mapping = aes(\n    x = dice_txt,\n    fill = factor(level)\n  )\n) +\n  geom_bar(color = \"#222\") +\n  geom_label_repel(\n    data = labs,\n    mapping = aes(\n      x = dice_txt,\n      y = count,\n      label = dice_txt\n    ),\n    size = 3,\n    direction = \"y\",\n    seed = 1,\n    nudge_y = 4,\n    color = \"#ccc\",\n    fill = \"#222\",\n    arrow = NULL,\n    inherit.aes = FALSE\n  ) +\n  scale_fill_manual(\n    name = \"Spell level\",\n    values = palette\n  ) +\n  scale_x_discrete(\n    name = \"Increasing average outcome \\u27a1\",\n    breaks = NULL,\n    expand = expansion(.05)\n  ) +\n  scale_y_continuous(name = NULL) +\n  labs(title = \"Dice rolls in D&D spell descriptions by spell level\") +\n  theme_void() +\n  theme(\n    plot.background = element_rect(fill = \"#222\"),\n    text = element_text(color = \"#ccc\"),\n    axis.text = element_text(color = \"#ccc\"),\n    axis.title = element_text(color = \"#ccc\"),\n    plot.margin = unit(c(1, 1, 1, 1), units = \"cm\"),\n    legend.position = \"inside\",\n    legend.position.inside = c(.3, .825),\n    legend.direction = \"horizontal\",\n    legend.title.position = \"top\",\n    legend.byrow = TRUE\n  )\n\nplot(pic)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/make-plot-1.png){width=1152}\n:::\n:::\n\n\n\nVery pretty.\n\nThere's a small mystery that this plot leads to. As a general pattern, the low-level spells tend to mention die rolls with lower average value when compared to higher-level spells (i.e., there's lots of brown and orange bars on the left, and mostly blueish/purple bars on the right). That makes sense, especially because the dice rolls mentioned in spell descriptions are usually describing the amount of damage the spell does. \n\nSo what's the story with this one weird outlier, the level 0 spell that mentions a 12d6 roll? To answer this we need to work out which spell it is:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndice_dat |> \n  filter(level == 0 & dice_txt == \"12d6\") |> \n  pull(name)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Druidcraft\"\n```\n\n\n:::\n:::\n\n\n\nNow let's look at the description:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndescribe_spell(\"Druidcraft\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nWhispering to the spirits of nature, you create one of the following\neffects within range. Weather Sensor. You create a Tiny, harmless\nsensory effect that predicts what the weather will be at your location\nfor the next 24 hours. The effect might manifest as a golden orb for\nclear skies, a cloud for rain, falling snowflakes for snow, and so on.\nThis effect persists for 1 round. Bloom. You instantly make a flower\nblossom, a seed pod open, or a leaf bud bloom. Sensory Effect. You\ncreate a harmless sensory effect, such as falling leaves, spectral\ndancing fairies, a gentle breeze, the sound of an animal, or the\nfaint odor of skunk. The effect must fit in a 5-foot Cube. Fire Play.\nYou light or snuff out a candle, a torch, or a campfire. Spells (E)\nEarthquake Level 8 Transmutation (Cleric, Druid, Sorcerer) Casting\nTime: Action Range: 500 feet Components: V, S, M (a fractured rock)\nDuration: Concentration, up to 1 minute Choose a point on the ground\nthat you can see within range. For the duration, an intense tremor\nrips through the ground in a 100-foot-radius circle centered on that\npoint. The ground there is Difficult Terrain. When you cast this spell\nand at the end of each of your turns for the duration, each creature\non the ground in the area makes a Dexterity saving throw. On a failed\nsave, a creature has the Prone condition, and its Concentration is\nbroken. You can also cause the effects below. Fissures. A total of 1d6\nfissures open in the spell’s area at the end of the turn you cast it.\nYou choose the fissures’ locations, which can’t be under structures.\nEach fissure is 1d10 × 10 feet deep and 10 feet wide, and it extends\nfrom one edge of the spell’s area to another edge. A creature in the\nsame space as a fissure must succeed on a Dexterity saving throw or\nfall in. A creature that successfully saves moves with the fissure’s\nedge as it opens. Structures. The tremor deals 50 Bludgeoning damage\nto any structure in contact with the ground in the area when you cast\nthe spell and at the end of each of your turns until the spell ends.\nIf a structure drops to 0 Hit Points, it collapses. A creature within\na distance from a collapsing structure equal to half the structure’s\nheight makes a Dexterity saving throw. On a failed save, the creature\ntakes 12d6 Bludgeoning damage, has the Prone condition, and is buried\nin the rubble, requiring a DC 20 Strength (Athletics) check as an\naction to escape. On a successful save, the creature takes half as\nmuch damage only.\n```\n\n\n:::\n:::\n\n\n\nAh... now it makes more sense: it's a parsing error from when the data set was constructed. The stats and description for \"Earthquake\" (an 8th level spell) has been appended to the description for \"Druidcraft\", and the 12d6 roll in question isn't for \"Druidcraft\" it's for \"Earthquake\".\n\nMystery solved. \n\n::: {.column-margin}\n\n![D&D Boxed Set: Companion Rules](companions.jpg)\n\n:::\n\n\n## The schools of magic\n\nOkay, so that's the story behind the first plot. What about the second one, the one that looks like a heatmap with some dendrograms? The data wrangling for that one one is a little more elaborate, because we have to construct data for the heatmap and data for the dendrograms. \n\n### Data for the heatmap\n\nTo produce data for the heatmap, we select the relevant columns: i.e., those corresponding to the character classes, the `school` variable that denotes the school of magic for the spell, and the `name` variable because I like having an id column in my data. We then use `pivot_longer()` to arrange this data set in long form:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspells_long <- spells |>\n  select(name, school, bard:wizard) |>\n  pivot_longer(\n    cols = bard:wizard,\n    names_to = \"class\",\n    values_to = \"castable\"\n  ) \n\nprint(spells_long)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2,512 × 4\n   name        school     class    castable\n   <chr>       <chr>      <chr>    <lgl>   \n 1 Acid Splash evocation  bard     FALSE   \n 2 Acid Splash evocation  cleric   FALSE   \n 3 Acid Splash evocation  druid    FALSE   \n 4 Acid Splash evocation  paladin  FALSE   \n 5 Acid Splash evocation  ranger   FALSE   \n 6 Acid Splash evocation  sorcerer TRUE    \n 7 Acid Splash evocation  warlock  FALSE   \n 8 Acid Splash evocation  wizard   TRUE    \n 9 Aid         abjuration bard     TRUE    \n10 Aid         abjuration cleric   TRUE    \n# ℹ 2,502 more rows\n```\n\n\n:::\n:::\n\n\n\nNow we have a tidy data set with one row per \"observation\", in the sense that it specifies whether a spell of a specific `name` (which belongs to a specific `school`), is in fact `castable` by members of a particular character `class`. We can summarise this by aggregating over the specific spells, and count the number of castable spells for each combination of magic school and character class: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- spells_long |>\n  summarise(\n    count = sum(castable),\n    .by = c(\"school\", \"class\")\n  ) |>\n  mutate(\n    school = str_to_title(school),\n    class  = str_to_title(class)\n  )\n\nprint(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 64 × 3\n   school     class    count\n   <chr>      <chr>    <int>\n 1 Evocation  Bard         7\n 2 Evocation  Cleric      12\n 3 Evocation  Druid       17\n 4 Evocation  Paladin      3\n 5 Evocation  Ranger       3\n 6 Evocation  Sorcerer    30\n 7 Evocation  Warlock      4\n 8 Evocation  Wizard      30\n 9 Abjuration Bard        16\n10 Abjuration Cleric      33\n# ℹ 54 more rows\n```\n\n\n:::\n:::\n\n\n\nThis `dat` data frame is suitable for plotting as a heat map with `geom_tile()`, so let's now move to stage two of the data wrangling.\n\n### Dissimilarity data for the dendrograms\n\nThe data structure that we need at this step is slightly more complicated, because what we want to display on each axis is a hierarchical clustering, of the sort typically produced by `hclust()`. In a distant, distant past I actually wrote my PhD thesis on clustering and scaling tools used to represent item (dis)similarities, and as such I'm acutely aware that these tools are extremely sensitive to the way you define similarity (or dissimilarity, or distance, or association, or whatever...). So I'll be a little careful here, because if you do this in a thoughtless way you get stupid answers.\n\nBefore I begin, I'll quickly define a boring function that I'll used when printing matrices. It's not a very good function, but it works for the purposes I need it for in this post:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint_truncated <- function(x) {\n  if (inherits(x, \"matrix\")) {\n    rownames(x) <- str_trunc(rownames(x), width = 6, ellipsis = \".\")\n    colnames(x) <- str_trunc(colnames(x), width = 6, ellipsis = \".\")\n  }\n  if (inherits(x, \"dist\")) {\n    attr(x, \"Labels\") <- str_trunc(attr(x, \"Labels\"), width = 6, ellipsis = \".\")\n  }\n  print(round(x, digits = 3))\n}\n```\n:::\n\n\n\nOkay, now let's get to work on the data wrangling. We'll start by reorganising the `dat` data frame into a matrix form. The `mat` matrix below contains the exact same information as the data frame: each cell in the matrix represents the number of castable spells for a specific combination of class and school.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- dat |>\n  pivot_wider(\n    names_from = \"school\",\n    values_from = \"count\"\n  ) |>\n  as.data.frame()\n\nrownames(mat) <- mat$class\nmat$class <- NULL\nmat <- as.matrix(mat)\n\nprint_truncated(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Evoca. Abjur. Trans. Encha. Necro. Divin. Illus. Conju.\nBard        7     16     18     28      5     18     22      8\nCleric     12     33     13      8     14     17      1     11\nDruid      17     17     33      9      7     14      2     21\nPalad.      3     16      3      5      3      5      0      2\nRanger      3     11     13      3      1      9      1      7\nSorce.     30      7     33     13      9      8     14     19\nWarlo.      4      8      6     12     10      9     11      9\nWizard     30     22     41     15     18     19     26     24\n```\n\n\n:::\n:::\n\n\n\nIn this matrix we have a measure of \"affinity\", in the sense that larger values indicate a higher affinity between a class and a school. The tricky part here is that some classes are simply better at spellwork than others: clerics and wizards can both cast lots of spells; paladins and rangers cannot cast many. The kind of similarity that I have in mind here is not the boring \"clerics and wizards are similar because they can both cast lots of spells\" kind. What I really want to say is something like \"paladins and clerics are  similar because abjuration is the strongest school for both classes\". The same applies when thinking about the schools of magic: there are lots of transmutation spells and lots of abjuration spells. That doesn't really make those schools similar, not in the sense I care about. \n\nWhat all this amounts to is an acknowledgement that we need to correct for overall prevalance, or -- to frame it in probabilistic terms -- to describe classes in terms of a \"distribution over schools\" and describe schools in terms of a \"distribution over classes\". That gives us the following two matrices:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass_distro  <- mat / replicate(ncol(mat), rowSums(mat))\nschool_distro <- t(mat) / (replicate(nrow(mat), colSums(mat)))\n```\n:::\n\n\n\nThe `class_distro` matrix is the one that describes classes as a distribution over schools, and you can see in the printout here that when described in this fashion the paladin row and the cleric row do look rather similar to each other:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint_truncated(class_distro)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Evoca. Abjur. Trans. Encha. Necro. Divin. Illus. Conju.\nBard    0.057  0.131  0.148  0.230  0.041  0.148  0.180  0.066\nCleric  0.110  0.303  0.119  0.073  0.128  0.156  0.009  0.101\nDruid   0.142  0.142  0.275  0.075  0.058  0.117  0.017  0.175\nPalad.  0.081  0.432  0.081  0.135  0.081  0.135  0.000  0.054\nRanger  0.062  0.229  0.271  0.062  0.021  0.188  0.021  0.146\nSorce.  0.226  0.053  0.248  0.098  0.068  0.060  0.105  0.143\nWarlo.  0.058  0.116  0.087  0.174  0.145  0.130  0.159  0.130\nWizard  0.154  0.113  0.210  0.077  0.092  0.097  0.133  0.123\n```\n\n\n:::\n:::\n\n\n\nA similar phenomenon is observed in the `school_distro` matrix, where you can see that the rows for abjuration and divination are quite similar despite the fact that there are a lot more abjuration spells than divination spells:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint_truncated(school_distro)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        Bard Cleric Druid Palad. Ranger Sorce. Warlo. Wizard\nEvoca. 0.066  0.113 0.160  0.028  0.028  0.283  0.038  0.283\nAbjur. 0.123  0.254 0.131  0.123  0.085  0.054  0.062  0.169\nTrans. 0.112  0.081 0.206  0.019  0.081  0.206  0.038  0.256\nEncha. 0.301  0.086 0.097  0.054  0.032  0.140  0.129  0.161\nNecro. 0.075  0.209 0.104  0.045  0.015  0.134  0.149  0.269\nDivin. 0.182  0.172 0.141  0.051  0.091  0.081  0.091  0.192\nIllus. 0.286  0.013 0.026  0.000  0.013  0.182  0.143  0.338\nConju. 0.079  0.109 0.208  0.020  0.069  0.188  0.089  0.238\n```\n\n\n:::\n:::\n\n\n\nWe are now in a position to convert both of these to distance/distance matrices. Notwithstanding the fact that it's probably not the ideal way to describe similarity between distributions, I'll call `dist()` using the default Euclidean distance measure. I mean, sure, I could probably do something fancy with [Jensen-Shannon divergence](https://en.wikipedia.org/wiki/Jensen%E2%80%93Shannon_divergence) here, but in my experience the metric you use to measure distributional similarity is *far* less important than the manner in which you construct the distributions from raw features in the first place, so I'm not going to sweat this one. Here's our measure of class dissimilarity:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass_dissim  <- dist(class_distro)\nprint_truncated(class_dissim)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        Bard Cleric Druid Palad. Ranger Sorce. Warlo.\nCleric 0.309                                         \nDruid  0.296  0.251                                  \nPalad. 0.373  0.167 0.381                            \nRanger 0.294  0.213 0.146  0.313                     \nSorce. 0.286  0.342 0.168  0.468  0.292              \nWarlo. 0.151  0.270 0.288  0.371  0.312  0.279       \nWizard 0.218  0.259 0.152  0.389  0.228  0.118  0.196\n```\n\n\n:::\n:::\n\n\n\nHere's our measure of school dissimilarity:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nschool_dissim <- dist(school_distro)\nprint_truncated(school_dissim)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Evoca. Abjur. Trans. Encha. Necro. Divin. Illus.\nAbjur.  0.320                                          \nTrans.  0.122  0.279                                   \nEncha.  0.323  0.284  0.270                            \nNecro.  0.218  0.200  0.226  0.281                     \nDivin.  0.271  0.133  0.203  0.181  0.179              \nIllus.  0.319  0.409  0.301  0.217  0.313  0.303       \nConju.  0.134  0.251  0.073  0.273  0.178  0.184  0.319\n```\n\n\n:::\n:::\n\n\n\n::: {.column-margin}\n\n![D&D Boxed Set: Master Rules](master.jpg)\n\n:::\n\n\n### Hierarchical clustering for the dendrograms\n\nAfter all that effort in constructing the dissimilarity matrices, the hierarchical clustering is something of an anticlimax. The only substantive choice we need to make here is whether to use single-link, complete-link, average-link, or some other method for agglomeration. This does matter somewhat, at least in my experience, but I'm also feeling lazy so I'm going to go with average-link because it feels appropriate to me in this context:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclusters <- list(\n  class = hclust(class_dissim, method = \"average\"),\n  school = hclust(school_dissim, method = \"average\")\n)\nprint(clusters)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$class\n\nCall:\nhclust(d = class_dissim, method = \"average\")\n\nCluster method   : average \nDistance         : euclidean \nNumber of objects: 8 \n\n\n$school\n\nCall:\nhclust(d = school_dissim, method = \"average\")\n\nCluster method   : average \nDistance         : euclidean \nNumber of objects: 8 \n```\n\n\n:::\n:::\n\n\n\n### Plotting the heatmap\n\nConstructing the plot can also be considered a two-part process. In the first stage, we constrict a `base` plot object that uses `geom_tile()` to display the class/school affinities data (i.e., `dat`), and add various stylistic features to make it look pretty:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase <- ggplot(dat, aes(school, class, fill = count)) +\n  geom_tile() +\n  scale_fill_distiller(palette = \"RdPu\") +\n  labs(\n    x = \"The Schools of Magic\",\n    y = \"The Classes of Character\",\n    fill = \"Number of Learnable Spells\"\n  ) +\n  coord_equal() +\n  theme(\n    plot.background = element_rect(\n      fill = \"#222\", \n      color = \"#222\"\n    ),\n    plot.margin = unit(c(2, 2, 2, 2), units = \"cm\"),\n    text = element_text(color = \"#ccc\", size = 14),\n    axis.text = element_text(color = \"#ccc\"),\n    axis.title = element_text(color = \"#ccc\"),\n    axis.ticks = element_line(color = \"#ccc\"),\n    legend.position = \"bottom\",\n    legend.background = element_rect(\n      fill = \"#222\", \n      color = \"#222\"\n    )\n  )\n\nplot(base)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/base-plot-1.png){width=960}\n:::\n:::\n\n\n\nIn this form, though, you can't really see which schools are similar to each other and nor can you see how the classes are related in terms of their spell-casting affinities. What we really want to do is reorder the rows and columns so that the most similar schools are placed in adjacent columns, and the most similar classes are placed in adjacent rows. \n\n### Adding the dendrograms\n\nUntil recently I'd never found a tool for doing this in R that I found satisfying, but with the release of the [legendry](https://teunbrand.github.io/legendry/) package by Teun van den Brand (which has a *lot* of tools for working with plot legends and axes that I'm slowly learning...) this has changed. If we pass a hierarchical clustering to the `scale_*_dendro()` functions, the rows/columns are reordered appropriately, and the dendrograms themselves are shown alongside the axes: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npic <- base +\n  scale_x_dendro(\n    clust = clusters$school,\n    guide = guide_axis_dendro(n.dodge = 2),\n    expand = expansion(0, 0),\n    position = \"top\"\n  ) +\n  scale_y_dendro(\n    clust = clusters$class,\n    expand = expansion(0, 0)\n  )\n\nplot(pic)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/final-plot-1.png){width=960}\n:::\n:::\n\n\n\nSo much nicer! \n\nTo any D&D player, the plot is immediately interpretable: wizards and sorcerers are very similar spellcasting classes, and the spellcasting abilities of paladins are basically \"clerics, but not very good at it\". The same dynamic is in play with regards to druids and rangers, in the sense that they're both nature focused spellcasters but rangers aren't very good at it. The grouping of bards and warlocks surprised me a little, until it was pointed out to me that they both rely heavily on charisma in their spellcasting, so there is a kind of connection there. \n\nOn the schools side, the plot is similarly interpretable: enchantment and illusion are closely related schools, as are abjuration and divination. Necromancy feels a little bit like the darker cousin of abjuration so yeah, that tracks too. Transmutation, conjuration, and evocation are all kinda related, so you get a clustering there too.\n\nThere are some limitations to hierarchical clustering, of course, and you can see a little bit of that coming through in the plot. By design, I constructed the dissimilarities so that they'd ignore the \"primary spellcaster vs secondary spellcaster\" distinction, so the overall brightness of adjacent rows and columns varies wildly. But to capture that in a clustering solution while also capturing the \"stylistic\" similarities I've plotted here, you'd need to use an overlapping clustering tool rather than a hierarchical one, and those are inherently trickier to work with, and I wouldn't be able to draw the pretty dendrograms either!\n\n::: {.column-margin}\n\n![D&D Boxed Set: Immortals Rules](immortals.jpg)\n\n:::\n\n\n## Epilogue\n\n\n\n\n\n\n\nOne weirdly enjoyable game I discovered when writing this post is calling the `describe_spell()` helper function without specifying the actual spell to describe, which produces the description of a randomly selected spell. Trying to identify the spell name from the description is kind of fun:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndescribe_spell()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nYou create a floating, spectral force that resembles a weapon of your\nchoice and lasts for the duration. The force appears within range in\na space of your choice, and you can immediately make one melee spell\nattack against one creature within 5 feet of the force. On a hit, the\ntarget takes Force damage equal to 1d8 plus your spellcasting ability\nmodifier. As a Bonus Action on your later turns, you can move the\nforce up to 20 feet and repeat the attack against a creature within 5\nfeet of it. Using a Higher-Level Spell Slot. The damage increases by\n1d8 for every slot level above 2.\n```\n\n\n:::\n:::\n\n\n\nThis one?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndescribe_spell()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nYou create an illusion of an object, a creature, or some other visible\nphenomenon within range that activates when a specific trigger occurs.\nThe illusion is imperceptible until then. It must be no larger than a\n30-foot Cube, and you decide when you cast the spell how the illusion\nbehaves and what sounds it makes. This scripted performance can last\nup to 5 minutes. When the trigger you specify occurs, the illusion\nsprings into existence and performs in the manner you described. Once\nthe illusion finishes performing, it disappears and remains dormant\nfor 10 minutes, after which the illusion can be activated again. The\ntrigger can be as general or as detailed as you like, though it must\nbe based on visual or audible phenomena that occur within 30 feet\nof the area. For example, you could create an illusion of yourself\nto appear and warn off others who attempt to open a trapped door.\nPhysical interaction with the image reveals it to be illusory, since\nthings can pass through it. A creature that takes the Study action\nto examine the image can determine that it is an illusion with a\nsuccessful Intelligence (Investigation) check against your spell save\nDC. If a creature discerns the illusion for what it is, the creature\ncan see through the image, and any noise it makes sounds hollow to the\ncreature.\n```\n\n\n:::\n:::\n\n\n\nOr this one?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndescribe_spell()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nYou receive an omen from an otherworldly entity about the results of a\ncourse of action that you plan to take within the next 30 minutes. The\nDM chooses the omen from the Omens table. Omens Omen For Results That\nWill Be... Weal Good Woe Bad Weal and woe Good and bad Indifference\nNeither good nor bad The spell doesn’t account for circumstances, such\nas other spells, that might change the results. If you cast the spell\nmore than once before finishing a Long Rest, there is a cumulative\n25 percent chance for each casting after the first that you get no\nanswer.\n```\n\n\n:::\n:::\n\n\n\nEnjoy!\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}