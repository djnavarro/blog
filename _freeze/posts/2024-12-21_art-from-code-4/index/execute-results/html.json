{
  "hash": "62d6278abe0ca89c2b18cb8fb2833114",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Art from code IV: Shading tricks\"\ndescription: \"Let's be honest, this entire post is a thinly-veiled excuse to play around and do terrible things with the rayshader package\"\ndate: \"2024-12-21\"\ncategories: [\"R\", \"Art\"]\nimage: \"ice-floe.png\"\nimage-alt: \"Unreal looking landscape in bright colours\"\n--- \n\n\n\n<!--------------- my typical setup ----------------->\n\n\n\n\n\n\n\n<!--------------- post begins here ----------------->\n\n*A couple of years ago I gave an invited workshop called [art from code](https://art-from-code.netlify.app) at the 2022 rstudio::conf (now posit::conf) conference. As part of the workshop I wrote a lengthy series of notes on how to make generative art using R, all of which were released under a CC-BY licence. For a while now I'd been thinking I should do something with these notes. I considered writing a book, but in all honesty I don't have the spare capacity for a side-project of that scale these days. I can barely keep up with the workload at my day job as it is. So instead, I've decided that I'd port them over to this site as a series of blog posts. In doing so I've made a deliberate decision not to modify the original content too much (nobody loves it when an artist tries to \"improve\" the original, after all). All I've done is update the code to accommodate package changes since 2022, and some minor edits so that the images are legible when embedded in this blog (which is light-themed, and the original was dark-theme). Other than that, I've left it alone. This is the fourth post in that series.*\n\n- [Prelude](/posts/2024-12-18_art-from-code-1/)\n- [Spatial tricks with ambient](/posts/2024-12-19_art-from-code-2/)\n- [Polygon tricks](/posts/2024-12-20_art-from-code-3/)\n- [Shading tricks](/posts/2024-12-21_art-from-code-4/)\n- [Iterated function systems](/posts/2024-12-22_art-from-code-5/)\n- [Tiles and tessellations](/posts/2024-12-23_art-from-code-6/)\n- [Pixel filters](/posts/2024-12-24_art-from-code-7/)\n- [Epilogue](/posts/2024-12-25_art-from-code-8/)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rayshader)\nlibrary(tibble)\nlibrary(ambient)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggthemes)\nlibrary(tictoc)\nlibrary(dplyr)\n```\n:::\n\n\n\n## Rayshader art\n\nThe [rayshader package](https://www.rayshader.com/) is a tool used to generate 2D and 3D visualisations in R. It is designed primarily to work with elevation data: you can use it to create beautiful shaded maps in two and three dimensions. You don't have to restrict yourself to mapping applications though. For example, you can use it to create 3D ggplot images if you want. More importantly for our purposes, generative artists in the R community have begun exploring the artistic possibilities inherent in the package. It's a relatively new addition to my repertoire: I've only built a few generative art systems this way, and I'm still a novice user of the package. However, it's too much fun *not* to talk about it here, so let's take `rayshader` for a spin. \n\nTo help get us started, I'll build a very simple generative art system. All it does is overlay a few circles on top of one another. To make this system work, I'll define a helper function `is_within_circle` that takes coordinate vectors `x_coord` and `y_coord` as inputs, and returns a logical vector that is `TRUE` whenever those coordinates fall within a circle specified by the `radius`, `x_center`, and `y_center` values. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_within_circle <- function(x_coord, y_coord, x_center, y_center, radius) {\n  (x_coord - x_center)^2 + (y_coord - y_center)^2 < radius^2\n}\n```\n:::\n\n\n\nThe `additive_circles()` function generates `n` circles at random (defaulting to 5 circles), and returns a long grid that defines a canvas with coordinate columns `x` and `y`, and a value column `paint` indicating the proportion of circles that each point falls in. If a particular point falls within every circle, the corresponding `paint` value is 1; if it falls within none of the circles the value is 0:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadditive_circles <- function(n = 5, pixels = 1000, seed = NULL) {\n  \n  if(!is.null(seed)) set.seed(seed)\n  \n  # setup canvas\n  art <- long_grid(\n    x = seq(0, 1, length.out = pixels),\n    y = seq(0, 1, length.out = pixels)\n  )\n  art$paint <- 0\n  \n  for(i in 1:n) {\n    \n    # sample a random circle\n    x_center <- runif(1, min = .3, max = .7)\n    y_center <- runif(1, min = .3, max = .7)\n    radius <- runif(1, min = .05, max = .25)\n    \n    # add +1 to all points inside the circle\n    art <- art |>\n      mutate(\n        paint = paint + is_within_circle(\n          x, y, x_center, y_center, radius\n        )\n      )\n  }\n  \n  # normalise paint to [0, 1] range and return\n  art$paint <- normalise(art$paint)\n  return(art)\n}\n```\n:::\n\n\n\nHere's what happens when we generate output from the system and then use `geom_raster()` to plot it:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncircle_art <- additive_circles(seed = 99)\ncircle_art\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,000,000 × 3\n       x       y paint\n   <dbl>   <dbl> <dbl>\n 1     0 0           0\n 2     0 0.00100     0\n 3     0 0.00200     0\n 4     0 0.00300     0\n 5     0 0.00400     0\n 6     0 0.00501     0\n 7     0 0.00601     0\n 8     0 0.00701     0\n 9     0 0.00801     0\n10     0 0.00901     0\n# ℹ 999,990 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot(circle_art, aes(x, y, fill = paint)) +\n  geom_raster(show.legend = FALSE) + \n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/circle-addition-1.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\nExperienced ggplot2 users might wonder why I'm generating art in this fashion. Why go to all the trouble of defining a raster when ggplot2 already has a `geom_polygon()` function that I could have used to draw the same image? The answer to this is that the rayshader package likes to deal with matrices (and other arrays). Instead of representing the data in a tibble with `x` and `y` coordinates that just happen to define a grid, it expects inputs in the form of a matrix where each row corresponds to a `y` coordinate and each column corresponds to an `x` coordinate, and the values in each cell correspond to (in our case) the `paint` values. Conveniently for us, the object we used to store our artwork isn't a regular tibble, it's a long grid provide by the ambient package. The ambient package knows how to convert this to an array quickly and painlessly:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncircle_array <- circle_art |>\n  as.array(value = paint) \n\ncircle_array[1:10, 1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       x\ny       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n   [1,]    0    0    0    0    0    0    0    0    0     0\n   [2,]    0    0    0    0    0    0    0    0    0     0\n   [3,]    0    0    0    0    0    0    0    0    0     0\n   [4,]    0    0    0    0    0    0    0    0    0     0\n   [5,]    0    0    0    0    0    0    0    0    0     0\n   [6,]    0    0    0    0    0    0    0    0    0     0\n   [7,]    0    0    0    0    0    0    0    0    0     0\n   [8,]    0    0    0    0    0    0    0    0    0     0\n   [9,]    0    0    0    0    0    0    0    0    0     0\n  [10,]    0    0    0    0    0    0    0    0    0     0\n```\n\n\n:::\n:::\n\n\n\nThe ability to flip back and forth between a tibble-like representation and a matrix-like representation is very handy! Anyway, the important point is that `circle_array` is now a matrix. I can plot this matrix directly using `image()`:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncircle_array |> \n  image(axes = FALSE, asp = 1, useRaster = TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/show-circle-array-1.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\n\nLet's imagine for a moment that this image is actually a terrain map, and the values stored in `circle_array` refer to the height of the terrain at each point on the grid. If that were true, and we placed an illumination source above the terrain, what pattern of shadows would be cast? We can solve this using ray shading algorithms, and unsurprisingly the rayshader package contains a function called `ray_shade()` that does this for us. We pass our data matrix as the `heightmap` argument, provide `sunaltitude` and `sunangle` arguments to specify the position of the illumination source, and use the `zscale` argument to specify the scale of the z-axis (the values) relative to the x- and y-axes. \n\nHere's what that looks like:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncircle_shadow <- ray_shade(\n  heightmap = circle_array,\n  sunaltitude = 15, \n  sunangle = 135,\n  zscale = .01,\n  multicore = TRUE\n)\n\nplot_map(circle_shadow, rotate = 270)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/circle-shadow-map-1.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\nThe results lack colour because this is only a map of the intensity of the shadow at each point. It's not a map of the terrain. If we want to construct that map we need something like a hill shading algorithm supplied by `sphere_shade()`, but that requires us to supply a texture. That's probably overkill for our initial application. Alternatively, if all we want is a height-to-colour mapping, we can use `height_shade()` to create the texture, and then use `add_shadow()` to add the shadow: \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncircle_scape <- circle_array |> \n  height_shade() |>\n  add_shadow(\n    shadowmap = circle_shadow,\n    max_darken = .1\n  )\n\nplot_map(circle_scape, rotate = 270)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/circle-render-1.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\nIn the final line I called `plot_map()` to draw the final image, using the `rotate` argument so that the final image has the same orientation as the image I created with `geom_raster()` at the beginning of this page. \n\n::: {.callout-important icon=false #exercise-circle-scape}\n## Exercise\n\nAt this point in the workshop, I hope that you're starting to get a sense for *how* to go about tweaking a generative system and how to create new things using it. So from this point the \"exercises\" are going to be a bit less structured. What I'll do is point you to the scripts that implement each system, and in each case the exercise is going to be the same: play with the system, see what it can do, modify it as you see fit, and see where your own intuitions take you!\n\nCode for this system is included in the `circle-scape.R` script in the [materials](#materials). Enjoy! Explore!\n\n:::\n\n\n## Shadowed noise fields\n\nNow that we have a general sense of how to use rayshader to create pretty images, let's see if we can use it to make something a little more interesting than a shaded map of a few circles laid on top of one another. One place to start is to return to the spatial noise patterns generated by `gen_perlin()`, `gen_simplex()` and so on. There's some potential for interesting art there right?\n\nBefore we get into that, we're going to -- yet again -- need a palette generating function. So once again I'll define a function to sample palettes using the `ggthemes::canva_palettes` list. However, this time around I'll be a little more elaborate. All the palettes in the original object contain exactly four colours. What I'll with the `sample_canva2()` function is include an `n` argument that specifies the number of colours desired, linearly interpolating between colours as necessary.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample_canva2 <- function(seed = NULL, n = 4) {\n  \n  if(!is.null(seed)) set.seed(seed)\n  sample(ggthemes::canva_palettes, 1)[[1]] |>\n    (\\(x) colorRampPalette(x)(n))()  \n}\n```\n:::\n\n\n\nHere's an example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample_canva2(seed = 1)\nsample_canva2(seed = 1, n = 7)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"#FCC875\" \"#BAA896\" \"#E6CCB5\" \"#E38B75\"\n[1] \"#FCC875\" \"#DBB885\" \"#BAA896\" \"#D0BAA5\" \"#E6CCB5\" \"#E4AB95\" \"#E38B75\"\n```\n\n\n:::\n:::\n\n\n\nThis functionality is handy in this context to ensure that we have enough different colours to produce nice gradients in our rayshader outputs. When working with ggplot2 the `scale_*_gradientn()` function took care of that for us, but we're not using ggplot2 here. \n\nIn any case, here's `ridge_art()`, a function that uses the spatial noise toolkit from the ambient package to produce patterns. The output comes in matrix form rather than as a long grid:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nridge_art <- function(seed = NULL, pixels = 2000) {\n  \n  if(!is.null(seed)) set.seed(seed)\n  long_grid(\n    x = seq(from = 0, to = 1, length.out = pixels),\n    y = seq(from = 0, to = 1, length.out = pixels)\n  ) |> \n    mutate(\n      paint = fracture(\n        x = x, \n        y = y,\n        noise = gen_simplex,\n        fractal = ridged,\n        octaves = 8,\n        frequency = 10,\n        seed = seed\n      ),\n      paint = normalise(paint)\n    ) |>\n    as.array(value = paint)\n}\n```\n:::\n\n\n\nAll the work in generating images is being done by the `gen_simplex()` generator, the `ridged()` fractal function, and the `fracture()` function that provides ambients API for fractal noise. To give you a sense of what kind of output this system produces natively, here's an `image()`:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nridge_art(1234) |> \n  image(\n    axes = FALSE, \n    asp = 1, \n    useRaster = TRUE, \n    col = sample_canva2(seed = 1234, n = 256)\n  ) \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/ridged-art-example-1.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\nThat's quite pretty in its own right, but we can give it a real feeling of depth by using rayshader. The idea is essentially identical to what we did when shading our circles art: compute a height map, a shadow map, and add them together before calling `plot_map()`. Here's the code for a `shaded_ridge_art()` function that does this:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nshaded_ridge_art <- function(seed = NULL) {\n  \n  art <- ridge_art(seed) \n  height_shade(\n    heightmap = art,\n    texture = sample_canva2(seed, 256)\n  ) |>\n    add_shadow(\n      shadowmap = ray_shade(\n        heightmap = art, \n        sunaltitude = 30, \n        sunangle = 90,\n        multicore = TRUE, \n        zscale = .05\n      ), \n      max_darken = .1\n    ) |>\n    plot_map()\n}\n```\n:::\n\n\n\nHere's our ridged art piece rendered as a shaded version:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntic()\nshaded_ridge_art(1234)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/rayshader-art-1.png){fig-align='center' width=1800}\n:::\n\n```{.r .cell-code}\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n18.801 sec elapsed\n```\n\n\n:::\n:::\n\n\n\nJust because they're pretty and it's not that hard to generate new pieces -- one of the joys of generative art is that the moment you make one piece you like you can immediately make many more in the same style -- here are a few more outputs from the system:\n\n\n\n::: {.cell .column-screen-inset layout-ncol=\"3\" layout-align=\"center\"}\n\n```{.r .cell-code}\nshaded_ridge_art(100)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/more-rayshade-art-1.png){fig-align='center' width=1800}\n:::\n\n```{.r .cell-code}\nshaded_ridge_art(101)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/more-rayshade-art-2.png){fig-align='center' width=1800}\n:::\n\n```{.r .cell-code}\nshaded_ridge_art(102) \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/more-rayshade-art-3.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\n::: {.callout-important icon=false #exercise-shaded-ridge}\n## Exercise\n\nCode for this system is included in the `shaded-ridge-art.R` script in the [materials](#materials).\n\n:::\n\n\n## Fractured terrain\n\nBack in the early days of the pandemic I made a series of generative art pieces called *Quarantine Moods* that was, well, pretty incoherent. Not very surprising: I was trapped indoors and stressed, so there's no theme or structure to the whole thing. Later on though I found the code for one of the pieces that I really liked and reworked it to create a new system that I called [Ice Floes](https://art.djnavarro.net/gallery/ice-floes/). Pieces from this system have a jagged, fractured geometric look to them. One of the first thoughts I had when exploring the rayshader package was that these images would generate some really interesting shadows, and it would be fun to see what happens when I applied rayshader methods to those outputs. So... that's what I did!\n\nThe first step in the process is to recreate the ice floes system, or at least something very similar to it. The trick behind this system is to generate spatial noise defined over a *different* space to the one I intend to plot at the end. I generate new coordinates by constructing a map from the original coordinates to the corresponding curl space. Or, to put it in less pretentious terms, I use `curl_noise()` to produce a new set of coordinates that I'm going to feed into other noise processes. Here's the function I'll use to that:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransform_to_curl_space <- function(x, y, frequency = 1, octaves = 10) {\n  curl_noise(\n    generator = fracture,\n    noise = gen_simplex,\n    fractal = fbm,\n    octaves = octaves,\n    frequency = frequency,\n    x = x,\n    y = y\n  )\n}\n```\n:::\n\n\n\nThe next step is to use Worley noise to construct a set of cells, in this transformed space. To do that I'll define a helper function that takes a set of coordinates (in whatever space) as input and outputs values associated with the cells:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndefine_worley_cells <- function(x, y, frequency = 3, octaves = 6) {\n  fracture(\n    noise = gen_worley,\n    fractal = billow,\n    octaves = octaves,\n    frequency = frequency,\n    value = \"cell\",\n    x = x,\n    y = y\n  ) |>\n    rank() |> \n    normalise()\n}\n```\n:::\n\n\n\nNow back in the original space, we'll use the cell values to (discontinuously) add offsets to the x- and y-coordinates, and then generate simplex noise using those offset coordinates. The net effect of this is that we have the simplex noise varies smoothly within cells (whose borders are quite peculiar because they're generated in the curl space) but discontinuous between cells. This is going to give us an image that is both smooth and jagged. \n\nAnyway, this means we need one more helper function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimplex_noise <- function(x, y, frequency = .1, octaves = 10) {\n  fracture(\n    noise = gen_simplex,\n    fractal = ridged,\n    octaves = octaves,\n    frequency = frequency,\n    x = x,\n    y = y\n  ) |>\n    normalise()\n}\n```\n:::\n\n\n\nNow we have all the pieces we need to construct an `ice_floe()` function that is more or less equivalent to my original system:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nice_floe <- function(seed) {\n  \n  set.seed(seed)\n  \n  grid <- long_grid(\n    x = seq(0, 1, length.out = 2000),\n    y = seq(0, 1, length.out = 2000)\n  )\n  \n  coords <- transform_to_curl_space(grid$x, grid$y)\n  \n  grid |>\n    mutate(\n      cells = define_worley_cells(coords$x, coords$y),\n      paint = simplex_noise(x + cells, y + cells),\n      paint = normalise(paint)\n    ) |>\n    as.array(value = paint)\n}\n```\n:::\n\n\n\nTo give you a sense of what images from the original system look like when coloured using one of the canva palettes, I'll again use `image()` to plot the output of the base system:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nice_floe(170) |> \n  image(\n    axes = FALSE, \n    asp = 1, \n    useRaster = TRUE, \n    col = sample_canva2(seed = 170, n = 256)\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/basic-ice-floe-1.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\nCreating the shaded version of the system proceeds the same way it did when we created the `shaded_ridge_art()` function. We call `ice_floe()` to create a matrix of elevations, construct an appropriately shaded elevation map using `height_shade()`, and then call `add_shadow()` to add a shadow map generated using `ray_shade()`. Then we call `plot_map()` to create the output:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nshaded_ice_floe <- function(seed) {\n  \n  art <- ice_floe(seed)\n  \n  height_shade(\n    heightmap = art,\n    texture = sample_canva2(seed, 256)\n  ) |>\n    add_shadow(\n      shadowmap = ray_shade(\n        heightmap = art, \n        sunaltitude = 30, \n        sunangle = 90,\n        multicore = TRUE, \n        zscale = .005\n      ), \n      max_darken = .05\n    ) |>\n    plot_map()\n}\n\nshaded_ice_floe(170)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/ice-floe-1.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\nTurns out it's quite pretty. Here are a few more outputs:\n\n\n\n::: {.cell .column-screen-inset layout-ncol=\"3\" layout-align=\"center\"}\n\n```{.r .cell-code}\nshaded_ice_floe(100)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/abstract-ice-floes-1.png){fig-align='center' width=1800}\n:::\n\n```{.r .cell-code}\nshaded_ice_floe(101)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/abstract-ice-floes-2.png){fig-align='center' width=1800}\n:::\n\n```{.r .cell-code}\nshaded_ice_floe(102)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/abstract-ice-floes-3.png){fig-align='center' width=1800}\n:::\n:::\n\n::: {.cell .column-screen-inset layout-ncol=\"3\" layout-align=\"center\"}\n\n```{.r .cell-code}\nshaded_ice_floe(106)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/even-more-abstract-ice-floes-1.png){fig-align='center' width=1800}\n:::\n\n```{.r .cell-code}\nshaded_ice_floe(107)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/even-more-abstract-ice-floes-2.png){fig-align='center' width=1800}\n:::\n\n```{.r .cell-code}\nshaded_ice_floe(108)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/even-more-abstract-ice-floes-3.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\n::: {.callout-important icon=false #exercise-icescape}\n## Exercise\n\nCode for this system is included in the `shaded-icescape.R` script in the [materials](#materials).\n\n:::\n\n\n## Three dimensional art\n\nThe examples I've shown so far all have a feeling of depth because of the way `ray_shade()` produces natural looking shadows. They're not truly 3D renderings though. You can't rotate them in 3D or display them from different perspectives. Happily, the rayshader package allows you to create 3D plots using the `plot_3d()` function. Under the hood, this function relies on the [rgl package](https://dmurdoch.github.io/rgl/), which in turn provides access to [OpenGL](https://www.opengl.org/). For this function to work, your installation of the rgl package needs to be built with access to OpenGL tools. On windows that should happen automatically, but it can be a little mmore tricky on other operating systems. To get it to work on my Ubuntu machine what I had to do was first install OpenGL. The command I used at the terminal was this:\n\n``` bash\nsudo apt-get install libgl1-mesa-dev libglu1-mesa-dev\n```\n\nOnce that was complete, I had to force a reinstall for the rgl package to ensure it had been built with the OpenGL libraries present. At the R console:\n\n``` r\ninstall.packages(\"rgl\", force = TRUE)\n```\n\nHaving done so, everything worked pretty smoothly for me.\n\nOkay, so what can we do with 3d rendering? To start with, let's keep things simple and use the \"circles\" example. I've already computed a height map (`circle_array`) and a shading map (`circle_scape`) that incorporates the shadows, so I can pass both of the to `plot_3d()`. It's a little fiddly, so I had to tinker with the angles and other settings to get a result that worked:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot_3d(\n  hillshade = circle_scape,\n  heightmap = circle_array,\n  theta = 230,\n  phi = 15,\n  zoom = .8,\n  zscale = .001,\n  baseshape = \"circle\",\n  background = \"#ffffff\",\n  shadow = FALSE,\n  soliddepth = 0,\n  solidcolor = \"#111111\",\n  windowsize = 1200\n)\n\nrender_snapshot(\n  filename = \"circles_3d.png\", \n  clear = TRUE\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nknitr::include_graphics(\"circles_3d.png\")\n```\n\n::: {.cell-output-display}\n![](circles_3d.png){width=600}\n:::\n:::\n\n\n\nIt kind of looks like a tower. It's kind of neat in its own right, but the output gets much more fun when you start feeding richer input to `plot_3d()`. Here's what happens when I adapt the \"ice floes\" system to produce truly three dimensional images:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nseed <- 170\n\nice_height <- matrix(0, 2500, 2500)\nice_height[251:2250, 251:2250] <- ice_floe(seed)\n\nice_scape <- height_shade(\n  heightmap = ice_height,\n  texture = sample_canva2(seed, 256)\n) |>\n  add_shadow(\n    shadowmap = ray_shade(\n      heightmap = ice_height, \n      sunaltitude = 30, \n      sunangle = 90,\n      multicore = TRUE, \n      zscale = .005\n    ), \n    max_darken = .05\n  )\n\nplot_3d(\n  hillshade = ice_scape,\n  heightmap = ice_height,\n  theta = 45,\n  phi = 30,\n  zoom = .75,\n  zscale = .001,\n  background = \"#ffffff\",\n  shadow = FALSE,\n  soliddepth = .5,\n  solidcolor = \"#222222\",\n  windowsize = c(2500, 1500)\n)\n\nrender_snapshot(\n  filename = \"ice_3d.png\", \n  clear = TRUE\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nknitr::include_graphics(\"ice_3d.png\")\n```\n\n::: {.cell-output-display}\n![](ice_3d.png){width=991}\n:::\n:::\n\n\n\nEven I have to admit I was impressed with myself this time. That worked way better than I was expecting it to, and I suspect it would look even nicer if I'd taken the time to learn more about hill shading algorithms and used `sphere_shade()` to create a proper terrain map rather rather than relying on `height_shade()`. Something to play around with in the future :)\n\n::: {.callout-important icon=false #exercise-icescape-3d}\n## Exercise\n\nCode for this system is included in the `icescape-3d.R` script.\n\n:::\n\n## Materials\n\nCode for each of the source files referred to in this section of the workshop is included here. Click on the callout box below to see the code for the file you want to look at. Please keep in mind that (unlike the code in the main text) I haven't modified these scripts since the original workshop, so you might need to play around with them to get them to work!\n\n\n\n\n::: {.callout-note collapse=\"true\" title=\"circle-scape.R\" icon=false appearance=\"minimal\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rayshader)\nlibrary(tibble)\nlibrary(ambient)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggthemes)\nlibrary(tictoc)\nlibrary(dplyr)\n\nis_within_circle <- function(x_coord, y_coord, x_center, y_center, radius) {\n  (x_coord - x_center)^2 + (y_coord - y_center)^2 < radius^2\n}\n\nadditive_circles <- function(n = 5, pixels = 1000, seed = NULL) {\n  \n  if(!is.null(seed)) set.seed(seed)\n  \n  # setup canvas\n  art <- long_grid(\n    x = seq(0, 1, length.out = pixels),\n    y = seq(0, 1, length.out = pixels)\n  )\n  art$paint <- 0\n  \n  for(i in 1:n) {\n    \n    # sample a random circle\n    x_center <- runif(1, min = .3, max = .7)\n    y_center <- runif(1, min = .3, max = .7)\n    radius <- runif(1, min = .05, max = .25)\n    \n    # add +1 to all points inside the circle\n    art <- art |>\n      mutate(\n        paint = paint + is_within_circle(\n          x, y, x_center, y_center, radius\n        )\n      )\n  }\n  \n  # normalise paint to [0, 1] range and return\n  art$paint <- normalise(art$paint)\n  return(art)\n}\n\ncircle_art <- additive_circles(seed = 99)\n\ncircle_array <- circle_art |>\n  as.array(value = paint) \n\ncircle_shadow <- ray_shade(\n  heightmap = circle_array,\n  sunaltitude = 15, \n  sunangle = 135,\n  zscale = .01,\n  multicore = TRUE\n)\n\ncircle_scape <- circle_array |> \n  height_shade() |>\n  add_shadow(\n    shadowmap = circle_shadow,\n    max_darken = .1\n  )\n\ntic()\nplot_map(circle_scape, rotate = 270)\ntoc()\n```\n:::\n\n:::\n\n::: {.callout-note collapse=\"true\" title=\"icescape-3d.R\" icon=false appearance=\"minimal\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rayshader)\nlibrary(tibble)\nlibrary(ambient)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggthemes)\nlibrary(dplyr)\nlibrary(tictoc)\nlibrary(here)\n\nsample_canva2 <- function(seed = NULL, n = 4) {\n  \n  if(!is.null(seed)) set.seed(seed)\n  sample(ggthemes::canva_palettes, 1)[[1]] |>\n    (\\(x) colorRampPalette(x)(n))()  \n}\n\ntransform_to_curl_space <- function(x, y, frequency = 1, octaves = 10) {\n  curl_noise(\n    generator = fracture,\n    noise = gen_simplex,\n    fractal = fbm,\n    octaves = octaves,\n    frequency = frequency,\n    x = x,\n    y = y\n  )\n}\n\n\ndefine_worley_cells <- function(x, y, frequency = 3, octaves = 6) {\n  fracture(\n    noise = gen_worley,\n    fractal = billow,\n    octaves = octaves,\n    frequency = frequency,\n    value = \"cell\",\n    x = x,\n    y = y\n  ) |>\n    rank() |> \n    normalise()\n}\n\n\nsimplex_noise <- function(x, y, frequency = .1, octaves = 10) {\n  fracture(\n    noise = gen_simplex,\n    fractal = ridged,\n    octaves = octaves,\n    frequency = frequency,\n    x = x,\n    y = y\n  ) |>\n    normalise()\n}\n\n\nice_floe <- function(seed) {\n  \n  set.seed(seed)\n  \n  grid <- long_grid(\n    x = seq(0, 1, length.out = 2000),\n    y = seq(0, 1, length.out = 2000)\n  )\n  \n  coords <- transform_to_curl_space(grid$x, grid$y)\n  \n  grid |>\n    mutate(\n      cells = define_worley_cells(coords$x, coords$y),\n      paint = simplex_noise(x + cells, y + cells),\n      paint = normalise(paint)\n    ) |>\n    as.array(value = paint)\n}\n\nicescape_3d <- function(seed) {\n  \n  ice_height <- matrix(0, 2500, 2500)\n  ice_height[251:2250, 251:2250] <- ice_floe(seed)\n  \n  ice_scape <- height_shade(\n    heightmap = ice_height,\n    texture = sample_canva2(seed, 256)\n  ) |>\n    add_shadow(\n      shadowmap = ray_shade(\n        heightmap = ice_height, \n        sunaltitude = 30, \n        sunangle = 90,\n        multicore = TRUE, \n        zscale = .005\n      ), \n      max_darken = .05\n    )\n  \n  plot_3d(\n    hillshade = ice_scape,\n    heightmap = ice_height,\n    theta = 45,\n    phi = 30,\n    zoom = .75,\n    zscale = .001,\n    background = \"#222222\",\n    shadow = FALSE,\n    soliddepth = .5,\n    solidcolor = \"#222222\",\n    windowsize = c(2500, 1500)\n  )\n  \n  render_snapshot(\n    filename = here(\"output\", paste0(\"icescape_3d_\", seed, \".png\")), \n    clear = TRUE\n  )\n}\n\ntic()\nicescape_3d(123)\ntoc()\n```\n:::\n\n:::\n\n::: {.callout-note collapse=\"true\" title=\"shaded-icescape.R\" icon=false appearance=\"minimal\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rayshader)\nlibrary(tibble)\nlibrary(ambient)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggthemes)\nlibrary(dplyr)\nlibrary(tictoc)\nlibrary(here)\n\nsample_canva2 <- function(seed = NULL, n = 4) {\n  \n  if(!is.null(seed)) set.seed(seed)\n  sample(ggthemes::canva_palettes, 1)[[1]] |>\n    (\\(x) colorRampPalette(x)(n))()  \n}\n\ntransform_to_curl_space <- function(x, y, frequency = 1, octaves = 10) {\n  curl_noise(\n    generator = fracture,\n    noise = gen_simplex,\n    fractal = fbm,\n    octaves = octaves,\n    frequency = frequency,\n    x = x,\n    y = y\n  )\n}\n\n\ndefine_worley_cells <- function(x, y, frequency = 3, octaves = 6) {\n  fracture(\n    noise = gen_worley,\n    fractal = billow,\n    octaves = octaves,\n    frequency = frequency,\n    value = \"cell\",\n    x = x,\n    y = y\n  ) |>\n    rank() |> \n    normalise()\n}\n\n\nsimplex_noise <- function(x, y, frequency = .1, octaves = 10) {\n  fracture(\n    noise = gen_simplex,\n    fractal = ridged,\n    octaves = octaves,\n    frequency = frequency,\n    x = x,\n    y = y\n  ) |>\n    normalise()\n}\n\n\nice_floe <- function(seed) {\n  \n  set.seed(seed)\n  \n  grid <- long_grid(\n    x = seq(0, 1, length.out = 2000),\n    y = seq(0, 1, length.out = 2000)\n  )\n  \n  coords <- transform_to_curl_space(grid$x, grid$y)\n  \n  grid |>\n    mutate(\n      cells = define_worley_cells(coords$x, coords$y),\n      paint = simplex_noise(x + cells, y + cells),\n      paint = normalise(paint)\n    ) |>\n    as.array(value = paint)\n}\n\nshaded_ice_floe <- function(seed) {\n  \n  art <- ice_floe(seed)\n  \n  height_shade(\n    heightmap = art,\n    texture = sample_canva2(seed, 256)\n  ) |>\n    add_shadow(\n      shadowmap = ray_shade(\n        heightmap = art, \n        sunaltitude = 30, \n        sunangle = 90,\n        multicore = TRUE, \n        zscale = .005\n      ), \n      max_darken = .05\n    ) |>\n    plot_map()\n}\n\ntic()\nshaded_ice_floe(123)\ntoc()\n```\n:::\n\n:::\n\n::: {.callout-note collapse=\"true\" title=\"shaded-ridge-art.R\" icon=false appearance=\"minimal\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rayshader)\nlibrary(tibble)\nlibrary(ambient)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggthemes)\nlibrary(tictoc)\nlibrary(dplyr)\n\nsample_canva2 <- function(seed = NULL, n = 4) {\n  if(!is.null(seed)) set.seed(seed)\n  sample(ggthemes::canva_palettes, 1)[[1]] |>\n    (\\(x) colorRampPalette(x)(n))()  \n}\n\nridge_art <- function(seed = NULL, pixels = 2000) {\n  \n  if(!is.null(seed)) set.seed(seed)\n  long_grid(\n    x = seq(from = 0, to = 1, length.out = pixels),\n    y = seq(from = 0, to = 1, length.out = pixels)\n  ) |> \n    mutate(\n      paint = fracture(\n        x = x, \n        y = y,\n        noise = gen_simplex,\n        fractal = ridged,\n        octaves = 8,\n        frequency = 10,\n        seed = seed\n      ),\n      paint = normalise(paint)\n    ) |>\n    as.array(value = paint)\n}\n\nshaded_ridge_art <- function(seed = NULL) {\n  \n  art <- ridge_art(seed) \n  height_shade(\n    heightmap = art,\n    texture = sample_canva2(seed, 256)\n  ) |>\n    add_shadow(\n      shadowmap = ray_shade(\n        heightmap = art, \n        sunaltitude = 30, \n        sunangle = 90,\n        multicore = TRUE, \n        zscale = .05\n      ), \n      max_darken = .1\n    ) |>\n    plot_map()\n}\n\ntic()\nshaded_ridge_art(100)\ntoc()\n```\n:::\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}