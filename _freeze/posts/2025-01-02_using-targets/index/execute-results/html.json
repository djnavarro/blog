{
  "hash": "4edb601bbeb52878060bea5c5cce4d61",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Three short stories about targets\"\ndescription: \"In which our intrepid adventurer turns a hacky data visualisation exercise into an analysis pipeline; builds an R blog with litedown and targets; and tries to wrap her head around the crews integration for multithreaded target building\"\ndate: \"2025-01-02\"\ncategories: [\"R\", \"Reproducibility\", \"Parallel Computing\"]\n--- \n\n\n\n<!--------------- my typical setup ----------------->\n\n\n\n\n\n\n\n<!--------------- post begins here ----------------->\n\nAbout 18 months ago I wrote a post about [balrogs and makefiles](/posts/2023-06-30_makefiles/). The post was long, strange, but also cathartic. It had bothered me for years that I didn't really understand [make](https://www.gnu.org/software/make/) as well as I wanted to, and it was really helpful to write up some notes about it as a way of teaching myself how to use it more effectively than I had done in the past.^[In all fairness, this is the *primary* purpose of this blog. Yes, it makes me very happy that other people find my posts useful and/or enjoyable, but that is actually a secondary goal. I write these posts for myself, because the act of writing is also an act of learning for me.] Buried at the very end of the post, somewhat sheepishly, is a reference to the [targets](https://docs.ropensci.org/targets/) R package by Will Landau. Even then I knew that I was going to need to learn how to use targets, but... life gets in the way. I have been preoccupied by other tasks, sadly, and it has taken me until now to (a) sit down and read through the [targets user manual](https://books.ropensci.org/targets/), and (b) come up with some [fun side projects](https://github.com/djnavarro/tartoys) that would give me the opportunity to try it out. \n\nRight then. Time to play around with targets...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(targets)\nlibrary(ggplot2)\nlibrary(legendry)\nlibrary(tidyselect)\nlibrary(dplyr)\nlibrary(fs)\n```\n:::\n\n\n\n## Project 1: An analysis pipeline\n\nThe first project is the fun [Tidy Tuesday](https://github.com/rfordatascience/tidytuesday/tree/main/data/2024/2024-12-17) project that I described in my [last post](/posts/2025-01-01_schools-of-magic/). In that post, I talked about two data visualisations I made using a data set about Dungeons & Dragons spells. When I wrote that post, I didn't talk about targets at all, and none of the code presented in that blog post is written in a \"targets-friendly\" way. However, all though that form of the code was the simplest way to write it up, it's not how I originally wrote it. The actual code was written for targets (it's included as the `spells` folder in [this github repo](https://github.com/djnavarro/tartoys)). \n\nAs it happens, I have a slightly-modified copy of the project in the `spells` directory within this blog post, so that I can play with this project within this post. This in turn brings us to the first point to make about targets: it's a *project-oriented* tool, in the sense that each project corresponds to a single folder (and its sub-folders), and not surprisingly it's easiest to use from within the project. To make my life easier I'll sometimes change that directory so that when I'm discussing a specific targets project, the code will execute from the root directory of that project. At the R console we would use `setwd()` to do so, but that's not the best approach within a knitr-based tool (quarto, rmarkdown, etc), and you will get warning messages if you try to do it that way. The preferred method for changing directories with an R markdown or quarto document is to set the `root.dir` knitr option. Because I'll be doing that several times in this post, I'll write a little convenience function to take care of this whenever I need to switch to a new project:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset_knitr_dir <- function(dir, post = \"2025-01-02_using-targets\") {\n  knitr::opts_knit$set(root.dir = here::here(\"posts\", post, dir))\n}\nset_knitr_dir(\"spells\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\nNext, let's take a look at the structure of this project. At the moment this is a clean project (i.e., no code has been run yet), so it contains only the source files. There are only three:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir_tree()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n├── _targets.R\n├── analysis.R\n└── spells.csv\n```\n\n\n:::\n:::\n\n\n\nHere's what each file does:\n\n- The `spells.csv` file is the data set I wish to analyse\n- The `analysis.R` script defines a collection of functions which, when called, will perform the required analyses and generate the outputs\n- The `_targets.R` script is (unsurprisingly) the build script\n\nIn a moment I'll talk about the `_targets.R` script, but first I'll quickly describe what the analysis itself does.\n\n### What does the analysis do?\n\nIf you read the [schools of magic](/posts/2025-01-01_schools-of-magic/) post that I wrote earlier this year, you've already seen the code underpinning the analysis. The only difference between the version in the previous post and the version I've used here is that the `analysis.R` script wraps each step of the analysis into a function. This is pretty crucial to constructing a targets pipeline, actually, and the targets user manual has a whole section discussing [function-oriented workflow](https://books.ropensci.org/targets/functions.html).\n\n> Functions are the building blocks of most computer code. They make code easier to think about, and they break down complicated ideas into small manageable pieces. Out of context, you can develop and test a function in isolation without mentally juggling the rest of the project. In the context of the whole workflow, functions are convenient shorthand to make your work easier to read.\n\nOne thing that continually surprises me about analysis scripts that I encounter in the wild is that *analysts don't write functions enough*. It's easily the most common trap I see people falling into, to be honest, and it leads to some very dangerous and hard-to-isolate bugs because the dependencies between different parts of the code become hard to see as the script gets longer. So I am a big fan of the design feature in targets that pushes the user to break a big analysis into a smaller number of functions that perform specific tasks. For example, once the `spells` data set has been loaded, the pipeline that constructs the \"spell dice\" plot is encapsulated by two key functions: \n\n- `dice_data()` takes the spells data as input, and performs all the data wrangling steps required to construct a tidied version of the data that is suitable for visualisation\n- `dice_plot()` takes the tidied dice data as input, specifies the \"spell dice\" plot, and writes it to an output file\n\n::: {.column-margin}\n\n![dice_pic.png](./spells-cache/dice_pic.png)\n\n:::\n\nThe \"schools of magic\" plot is slightly more elaborate, and uses three functions:\n\n- `scholastic_data()` takes the spells data as input, and performs the data wrangling steps required to create tidy data suitable for constructing the heatmap\n- `scholastic_clusters()` takes this tidy data as input, and the performs additional steps required to construct the hierarchical clustering used to draw dendrograms alongside the heatmap\n- `scholastic_plot()` takes the data set and the clustering as input, and uses them to build the \"schools of magic\" plot that is written to an output file\n\n::: {.column-margin}\n\n![scholastic_pic.png](./spells-cache/scholastic_pic.png)\n\n:::\n\nThe actual code for these functions isn't very important for the purposes of understanding the targets pipelinem, and in any case I've described the plots in detail before. But for what it's worth, the exact code is included below the fold here:\n\n\n\n::: {.cell filename='analysis.R'}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Click to show/hide the analysis.R code\" code-line-numbers=\"true\"}\n# spell dice plot ---------------------------------------------------------\n\ndice_data <- function(spells) {\n  dice_dat <- spells |>\n    select(name, level, description) |>\n    mutate(\n      dice_txt = str_extract_all(description, \"\\\\b\\\\d+d\\\\d+\\\\b\"),\n      dice_txt = purrr::map(dice_txt, unique)\n    ) |>\n    unnest_longer(\n      col = \"dice_txt\",\n      values_to = \"dice_txt\",\n      indices_to = \"position\"\n    ) |>\n    mutate(\n      dice_num = dice_txt |> str_extract(\"\\\\d+(?=d)\") |> as.numeric(),\n      dice_die = dice_txt |> str_extract(\"(?<=d)\\\\d+\") |> as.numeric(),\n      dice_val = dice_num * (dice_die + 1)/2,\n      dice_txt = factor(dice_txt) |> fct_reorder(dice_val)\n    )\n  return(dice_dat)\n}\n\ndice_plot <- function(dice_dat) {\n\n  palette <- hcl.colors(n = 10, palette = \"PuOr\")\n\n  labs <- dice_dat |>\n    summarise(\n      dice_txt = first(dice_txt),\n      count = n(),\n      .by = dice_txt\n    )\n\n  pic <- ggplot(\n    data = dice_dat,\n    mapping = aes(\n      x = dice_txt,\n      fill = factor(level)\n    )\n  ) +\n    geom_bar(color = \"#222\") +\n    geom_label_repel(\n      data = labs,\n      mapping = aes(\n        x = dice_txt,\n        y = count,\n        label = dice_txt\n      ),\n      size = 3,\n      direction = \"y\",\n      seed = 1,\n      nudge_y = 4,\n      color = \"#ccc\",\n      fill = \"#222\",\n      arrow = NULL,\n      inherit.aes = FALSE\n    ) +\n    scale_fill_manual(\n      name = \"Spell level\",\n      values = palette\n    ) +\n    scale_x_discrete(\n      name = \"Increasing average outcome \\u27a1\",\n      breaks = NULL,\n      expand = expansion(.05)\n    ) +\n    scale_y_continuous(name = NULL) +\n    labs(title = \"Dice rolls described in D&D spell descriptions\") +\n    theme_void() +\n    theme(\n      plot.background = element_rect(fill = \"#222\"),\n      text = element_text(color = \"#ccc\"),\n      axis.text = element_text(color = \"#ccc\"),\n      axis.title = element_text(color = \"#ccc\"),\n      plot.margin = unit(c(1, 1, 1, 1), units = \"cm\"),\n      legend.position = \"inside\",\n      legend.position.inside = c(.3, .825),\n      legend.direction = \"horizontal\",\n      legend.title.position = \"top\",\n      legend.byrow = TRUE\n    )\n\n  ggsave(\n    filename = \"dice_pic.png\",\n    plot = pic,\n    width = 2000,\n    height = 1000,\n    units = \"px\",\n    dpi = 150\n  )\n\n  return(\"dice_pic.png\")\n}\n\n\n# schools of magic plot ---------------------------------------------------\n\n# constructs the data frame used by geom_tile() later\nscholastic_data <- function(spells) {\n  spells |>\n    select(name, school, bard:wizard) |>\n    pivot_longer(\n      cols = bard:wizard,\n      names_to = \"class\",\n      values_to = \"castable\"\n    ) |>\n    summarise(\n      count = sum(castable),\n      .by = c(\"school\", \"class\")\n    ) |>\n    mutate(\n      school = str_to_title(school),\n      class  = str_to_title(class)\n    )\n}\n\n# hierarchical clustering for the schools and classes\nscholastic_clusters <- function(dat) {\n\n  # matrix of counts for each school/class combination\n  mat <- dat |>\n    pivot_wider(\n      names_from = \"school\",\n      values_from = \"count\"\n    ) |>\n    as.data.frame()\n  rownames(mat) <- mat$class\n  mat$class <- NULL\n  as.matrix(mat)\n\n  # each school is a distribution over classes,\n  # each class is a distribution over schools\n  class_distribution  <- mat / replicate(ncol(mat), rowSums(mat))\n  school_distribution <- t(mat) / (replicate(nrow(mat), colSums(mat)))\n\n  # pairwise distances\n  class_dissimilarity  <- dist(class_distribution)\n  school_dissimilarity <- dist(school_distribution)\n\n  # hierarchical clustering\n  clusters <- list(\n    class = hclust(class_dissimilarity, method = \"average\"),\n    school = hclust(school_dissimilarity, method = \"average\")\n  )\n\n  return(clusters)\n}\n\nscholastic_plot <- function(dat, clusters) {\n\n  pic <- ggplot(dat, aes(school, class, fill = count)) +\n    geom_tile() +\n    scale_x_dendro(\n      clust = clusters$school,\n      guide = guide_axis_dendro(n.dodge = 2),\n      expand = expansion(0, 0),\n      position = \"top\"\n    ) +\n    scale_y_dendro(\n      clust = clusters$class,\n      expand = expansion(0, 0)\n    ) +\n    scale_fill_distiller(palette = \"RdPu\") +\n    labs(\n      x = \"The Schools of Magic\",\n      y = \"The Classes of Character\",\n      fill = \"Number of Learnable Spells\"\n    ) +\n    coord_equal() +\n    theme(\n      plot.background = element_rect(fill = \"#222\", color = \"#222\"),\n      plot.margin = unit(c(2, 2, 2, 2), units = \"cm\"),\n      text = element_text(color = \"#ccc\"),\n      axis.text = element_text(color = \"#ccc\"),\n      axis.title = element_text(color = \"#ccc\"),\n      axis.ticks = element_line(color = \"#ccc\"),\n      legend.position = \"bottom\",\n      legend.background = element_rect(fill = \"#222\", color = \"#222\")\n    )\n\n  ggsave(\n    filename = \"scholastic_pic.png\",\n    plot = pic,\n    width = 1000,\n    height = 1000,\n    units = \"px\",\n    dpi = 150\n  )\n\n  return(\"scholastic_pic.png\")\n}\n```\n:::\n\n\n\n### Defining the pipeline\n\nNow that you've read the verbal description of what each function does, it's intuitively pretty clear how the analysis pipeline is supposed to work. Roughly speaking, you'd expect the analysis to be executed using a script like this:\n\n\n\n::: {.cell filename='run_analysis.R'}\n\n```{.r .cell-code  code-line-numbers=\"true\"}\n# load packages\nlibrary(tibble)\nlibrary(readr)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(tidyr)\nlibrary(forcats)\nlibrary(ggrepel)\nlibrary(legendry)\n\n# read analysis script\nsource(\"analysis.R\")\n\n# setup\ninput  <- \"spells.csv\"\nspells <- read_csv(input, show_col_types = FALSE)\n\n# make the spell dice plot & write to output\ndice_dat <- dice_data(spells)\ndice_pic <- dice_plot(dice_dat)\n\n# make the schools of magic plot & write to output\nscholastic_dat  <- scholastic_data(spells)\nscholastic_clus <- scholastic_clusters(scholastic_dat)\nscholastic_pic  <- scholastic_plot(scholastic_dat, scholastic_clus)\n```\n:::\n\n\n\nSo, how does it work with targets? Well, if we take a look at the `_targets.R` script, we can see it looks suspiciously similar to the code above:\n\n\n\n::: {.cell filename='_targets.R'}\n\n```{.r .cell-code  code-line-numbers=\"true\"}\nlibrary(targets)\n\n# specify required packages\ntar_option_set(packages = c(\n  \"tibble\", \"readr\", \"ggplot2\", \"dplyr\", \"stringr\", \n  \"tidyr\", \"forcats\", \"ggrepel\", \"legendry\"\n))\n\n# read analysis script\ntar_source(\"analysis.R\")\n\nlist(\n  # setup\n  tar_target(input, \"spells.csv\", format = \"file\"),\n  tar_target(spells, read_csv(input, show_col_types = FALSE)),\n\n  # dice plot\n  tar_target(dice_dat, dice_data(spells)),\n  tar_target(dice_pic, dice_plot(dice_dat)),\n\n  # scholastic plot\n  tar_target(scholastic_dat, scholastic_data(spells)),\n  tar_target(scholastic_clus, scholastic_clusters(scholastic_dat)),\n  tar_target(\n    scholastic_pic,\n    scholastic_plot(scholastic_dat, scholastic_clus)\n  )\n)\n```\n:::\n\n\n\nIn this pipeline, the set up involves two steps:\n\n- I've used [`tar_option_set()`](https://docs.ropensci.org/targets/reference/tar_option_set.html) to declare the required R packages, thereby making those packages available to the pipeline\n- I've used [`tar_source()`](https://docs.ropensci.org/targets/reference/tar_source.html) to read the analysis script, thereby making the functions in that file accessible to the pipeline\n\nHaving taken care of the preliminaries, the pipeline is specified via a list of targets, each of which is defined by a call to [`tar_target()`](https://docs.ropensci.org/targets/reference/tar_target.html). Each target has a `name`, and is associated with a `command` that is to be executed. If I'd named the arguments on line 18 in my `_targets.R` script, the code would look like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_target(\n  name = dice_dat, \n  command = dice_data(spells)\n)\n```\n:::\n\n\n\nNotice the similarity to line 20 of the `run_analysis.R` script:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndice_dat <- dice_data(spells)\n```\n:::\n\n\n\nIn essence, that's what I'm doing with the call to `tar_target()`. I'm specifying that the command `set_output_dir()` is to be executed, and the results should be stored as the variable `output`. However, instead of immediately executing this code in the current R environment, what `tar_target()` does is create the infrastructure so that this command can be incorporated into the pipeline when it actually gets built. With one exception, this is the recipe I followed for constructing all the targeta in my `_targets.R` script.\n\nThe one exception to this pattern occurs on line 14 of `_targets.R`, where my target is defined by this call to `tar_target()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_target(\n  name = input, \n  command = \"spells.csv\", \n  format = \"file\"\n)\n```\n:::\n\n\n\nIn one sense, this target is pretty much the same as the others: it defines a variable called `input` using the \"command\" `\"spells.csv\"`, and so in that respect it's much the same as line 16 of the `run_analysis.R` script. However, notice that I've also specified that `format = \"file\"`. This tells targets that `\"spells.csv\"` isn't *just* a string, it's also the name of a file that needs to be tracked. By declaring it as a file target, I'm ensuring that if the `spells.csv` file gets altered in some way, this target and any target that depends on it will need to be rebuilt.  \n\nThe [`tar_visnetwork()`](https://docs.ropensci.org/targets/reference/tar_visnetwork.html) function provides a handy way of visualising the structure of a pipeline as a little HTML widget. To keep things as simple as possible, at least for the moment, I'll set `targets_only = TRUE` so that the graph ignores the functions defined in `analysis.R`, and only focuses on the targets themselves:^[You can also call `tar_manifest()` to get a slightly more precise list of the targets and the commands with which they are associated, but I'm not going to bother with that here.]\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_visnetwork(targets_only = TRUE)\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"visNetwork html-widget html-fill-item\" id=\"htmlwidget-06484ed42468d86de4a4\" style=\"width:100%;height:464px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-06484ed42468d86de4a4\">{\"x\":{\"nodes\":{\"name\":[\"dice_dat\",\"dice_pic\",\"input\",\"scholastic_clus\",\"scholastic_dat\",\"scholastic_pic\",\"spells\"],\"type\":[\"stem\",\"stem\",\"stem\",\"stem\",\"stem\",\"stem\",\"stem\"],\"description\":[null,null,null,null,null,null,null],\"status\":[\"outdated\",\"outdated\",\"outdated\",\"outdated\",\"outdated\",\"outdated\",\"outdated\"],\"seconds\":[null,null,null,null,null,null,null],\"bytes\":[null,null,null,null,null,null,null],\"branches\":[null,null,null,null,null,null,null],\"label\":[\"dice_dat\",\"dice_pic\",\"input\",\"scholastic_clus\",\"scholastic_dat\",\"scholastic_pic\",\"spells\"],\"color\":[\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\"],\"id\":[\"dice_dat\",\"dice_pic\",\"input\",\"scholastic_clus\",\"scholastic_dat\",\"scholastic_pic\",\"spells\"],\"level\":[3,4,1,4,3,5,2],\"shape\":[\"dot\",\"dot\",\"dot\",\"dot\",\"dot\",\"dot\",\"dot\"]},\"edges\":{\"from\":[\"scholastic_dat\",\"spells\",\"input\",\"scholastic_clus\",\"scholastic_dat\",\"dice_dat\",\"spells\"],\"to\":[\"scholastic_clus\",\"scholastic_dat\",\"spells\",\"scholastic_pic\",\"scholastic_pic\",\"dice_pic\",\"dice_dat\"],\"arrows\":[\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\"]},\"nodesToDataframe\":true,\"edgesToDataframe\":true,\"options\":{\"width\":\"100%\",\"height\":\"100%\",\"nodes\":{\"shape\":\"dot\",\"physics\":false},\"manipulation\":{\"enabled\":false},\"edges\":{\"smooth\":{\"type\":\"cubicBezier\",\"forceDirection\":\"horizontal\"}},\"physics\":{\"stabilization\":false},\"interaction\":{\"zoomSpeed\":1},\"layout\":{\"hierarchical\":{\"enabled\":true,\"direction\":\"LR\"}}},\"groups\":null,\"width\":null,\"height\":null,\"idselection\":{\"enabled\":false,\"style\":\"width: 150px; height: 26px\",\"useLabels\":true,\"main\":\"Select by id\"},\"byselection\":{\"enabled\":false,\"style\":\"width: 150px; height: 26px\",\"multiple\":false,\"hideColor\":\"rgba(200,200,200,0.5)\",\"highlight\":false},\"main\":{\"text\":\"\",\"style\":\"font-family:Georgia, Times New Roman, Times, serif;font-weight:bold;font-size:20px;text-align:center;\"},\"submain\":null,\"footer\":null,\"background\":\"rgba(0, 0, 0, 0)\",\"highlight\":{\"enabled\":true,\"hoverNearest\":false,\"degree\":{\"from\":1,\"to\":1},\"algorithm\":\"hierarchical\",\"hideColor\":\"rgba(200,200,200,0.5)\",\"labelOnly\":true},\"collapse\":{\"enabled\":true,\"fit\":false,\"resetHighlight\":true,\"clusterOptions\":null,\"keepCoord\":true,\"labelSuffix\":\"(cluster)\"},\"legend\":{\"width\":0.2,\"useGroups\":false,\"position\":\"right\",\"ncol\":1,\"stepX\":100,\"stepY\":100,\"zoom\":true,\"nodes\":{\"label\":[\"Outdated\",\"Stem\"],\"color\":[\"#78B7C5\",\"#899DA4\"],\"shape\":[\"dot\",\"dot\"]},\"nodesToDataframe\":true},\"tooltipStay\":300,\"tooltipStyle\":\"position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;font-family: verdana;font-size:14px;font-color:#000000;background-color: #f5f4ed;-moz-border-radius: 3px;-webkit-border-radius: 3px;border-radius: 3px;border: 1px solid #808074;box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);\"},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\nAll these targets are shown in blue, indicating that they are \"outdated\". That's to be expected at this point, of course: I haven't actually run anything yet! I'll get to that momentarily, but before I do I'll call [`tar_outdated()`](https://docs.ropensci.org/targets/reference/tar_outdated.html) to confirm the obvious:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_outdated()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"scholastic_clus\" \"scholastic_dat\"  \"spells\"          \"scholastic_pic\" \n[5] \"dice_pic\"        \"input\"           \"dice_dat\"       \n```\n\n\n:::\n:::\n\n\n\nThese are the targets that need to be (re)run. \n\n### Running the pipeline\n\nOkay, it is now time to run the pipeline. We can do this by calling [`tar_make()`](https://docs.ropensci.org/targets/reference/tar_make.html). Here's what happens when we do that:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_make()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n▶ dispatched target input\n● completed target input [0.256 seconds, 302.514 kilobytes]\n▶ dispatched target spells\n● completed target spells [0.091 seconds, 73.966 kilobytes]\n▶ dispatched target scholastic_dat\n● completed target scholastic_dat [0.016 seconds, 401 bytes]\n▶ dispatched target dice_dat\n● completed target dice_dat [0.025 seconds, 33.486 kilobytes]\n▶ dispatched target scholastic_clus\n● completed target scholastic_clus [0.014 seconds, 634 bytes]\n▶ dispatched target dice_pic\n● completed target dice_pic [0.907 seconds, 65 bytes]\n▶ dispatched target scholastic_pic\n● completed target scholastic_pic [0.219 seconds, 71 bytes]\n▶ ended pipeline [1.619 seconds]\n```\n\n\n:::\n:::\n\n\n\nThe output here is pretty descriptive, but it's still worth expanding on it a little. For each target, there are two lines of output that look like this:\n\n```\n▶ dispatched target TARGETNAME\n● completed target TARGETNAME [blah seconds, blah kilobytes]\n```\n\nWhat these two lines mean is that, under the hood, targets \"dispatches\" the task to a separate R session using the [callr](https://github.com/r-lib/callr/) package, and the code is executed there. The target is deemed \"completed\" once that R session finishes running the code and returns the output. This approach has two advantages over simply running the code at the console. First, it is more reproducible, because each target is run in a clean R session. Second, this design makes it waaaaaaaay easier to parallelise the execution. More on that later. \n\nIn any case, now that we've finished running the pipeline, let's take a look at the state of our \"spells\" project folder:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir_tree(recurse = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n├── _targets\n├── _targets.R\n├── analysis.R\n├── dice_pic.png\n├── scholastic_pic.png\n└── spells.csv\n```\n\n\n:::\n:::\n\n\n\nThere are three new things here. First, as expected, we have two image files `dice_pic.png` and `scholastic_pic.png`. These are the outputs produced by our analysis script. Yay, it worked! There's also a `_targets` folder: this is the place where the targets package stashes all its metadata and stores copies of the built targets. I'll talk more about the contents of this folder later, but just to give a sense of it now, here's a sneak peek at what is stored in that folder:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir_tree(\"_targets\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n_targets\n├── meta\n│   ├── meta\n│   ├── process\n│   └── progress\n├── objects\n│   ├── dice_dat\n│   ├── dice_pic\n│   ├── scholastic_clus\n│   ├── scholastic_dat\n│   ├── scholastic_pic\n│   └── spells\n└── user\n```\n\n\n:::\n:::\n\n\n\n### When the project changes\n\nNow that we've run the pipeline, let's take another look at the network. The structure of it hasn't changed, but all the targets are showing as \"up to date\":\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_visnetwork(targets_only = TRUE)\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"visNetwork html-widget html-fill-item\" id=\"htmlwidget-21697d58abce2053a245\" style=\"width:100%;height:464px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-21697d58abce2053a245\">{\"x\":{\"nodes\":{\"name\":[\"dice_dat\",\"dice_pic\",\"input\",\"scholastic_clus\",\"scholastic_dat\",\"scholastic_pic\",\"spells\"],\"type\":[\"stem\",\"stem\",\"stem\",\"stem\",\"stem\",\"stem\",\"stem\"],\"description\":[null,null,null,null,null,null,null],\"status\":[\"uptodate\",\"uptodate\",\"uptodate\",\"uptodate\",\"uptodate\",\"uptodate\",\"uptodate\"],\"seconds\":[0.025,0.907,0.256,0.014,0.016,0.219,0.091],\"bytes\":[33486,65,302514,634,401,71,73966],\"branches\":[null,null,null,null,null,null,null],\"label\":[\"dice_dat\",\"dice_pic\",\"input\",\"scholastic_clus\",\"scholastic_dat\",\"scholastic_pic\",\"spells\"],\"color\":[\"#354823\",\"#354823\",\"#354823\",\"#354823\",\"#354823\",\"#354823\",\"#354823\"],\"id\":[\"dice_dat\",\"dice_pic\",\"input\",\"scholastic_clus\",\"scholastic_dat\",\"scholastic_pic\",\"spells\"],\"level\":[3,4,1,4,3,5,2],\"shape\":[\"dot\",\"dot\",\"dot\",\"dot\",\"dot\",\"dot\",\"dot\"]},\"edges\":{\"from\":[\"scholastic_dat\",\"spells\",\"input\",\"scholastic_clus\",\"scholastic_dat\",\"dice_dat\",\"spells\"],\"to\":[\"scholastic_clus\",\"scholastic_dat\",\"spells\",\"scholastic_pic\",\"scholastic_pic\",\"dice_pic\",\"dice_dat\"],\"arrows\":[\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\"]},\"nodesToDataframe\":true,\"edgesToDataframe\":true,\"options\":{\"width\":\"100%\",\"height\":\"100%\",\"nodes\":{\"shape\":\"dot\",\"physics\":false},\"manipulation\":{\"enabled\":false},\"edges\":{\"smooth\":{\"type\":\"cubicBezier\",\"forceDirection\":\"horizontal\"}},\"physics\":{\"stabilization\":false},\"interaction\":{\"zoomSpeed\":1},\"layout\":{\"hierarchical\":{\"enabled\":true,\"direction\":\"LR\"}}},\"groups\":null,\"width\":null,\"height\":null,\"idselection\":{\"enabled\":false,\"style\":\"width: 150px; height: 26px\",\"useLabels\":true,\"main\":\"Select by id\"},\"byselection\":{\"enabled\":false,\"style\":\"width: 150px; height: 26px\",\"multiple\":false,\"hideColor\":\"rgba(200,200,200,0.5)\",\"highlight\":false},\"main\":{\"text\":\"\",\"style\":\"font-family:Georgia, Times New Roman, Times, serif;font-weight:bold;font-size:20px;text-align:center;\"},\"submain\":null,\"footer\":null,\"background\":\"rgba(0, 0, 0, 0)\",\"highlight\":{\"enabled\":true,\"hoverNearest\":false,\"degree\":{\"from\":1,\"to\":1},\"algorithm\":\"hierarchical\",\"hideColor\":\"rgba(200,200,200,0.5)\",\"labelOnly\":true},\"collapse\":{\"enabled\":true,\"fit\":false,\"resetHighlight\":true,\"clusterOptions\":null,\"keepCoord\":true,\"labelSuffix\":\"(cluster)\"},\"legend\":{\"width\":0.2,\"useGroups\":false,\"position\":\"right\",\"ncol\":1,\"stepX\":100,\"stepY\":100,\"zoom\":true,\"nodes\":{\"label\":[\"Up to date\",\"Stem\"],\"color\":[\"#354823\",\"#899DA4\"],\"shape\":[\"dot\",\"dot\"]},\"nodesToDataframe\":true},\"tooltipStay\":300,\"tooltipStyle\":\"position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;font-family: verdana;font-size:14px;font-color:#000000;background-color: #f5f4ed;-moz-border-radius: 3px;-webkit-border-radius: 3px;border-radius: 3px;border: 1px solid #808074;box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);\"},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\nIf I call `tar_make()` again, essentially nothing happens. All the targets are up to date, so everything is skipped:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_make()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n✔ skipped target input\n✔ skipped target spells\n✔ skipped target scholastic_dat\n✔ skipped target dice_dat\n✔ skipped target scholastic_clus\n✔ skipped target dice_pic\n✔ skipped target scholastic_pic\n✔ skipped pipeline [0.07 seconds]\n```\n\n\n:::\n:::\n\n\n\nNice!\n\nActually, you know what? Now feels like a good time to show the full network, including all the functions that contribute to the pipeline...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_visnetwork()\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"visNetwork html-widget html-fill-item\" id=\"htmlwidget-4929a56e939b13f92b78\" style=\"width:100%;height:464px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-4929a56e939b13f92b78\">{\"x\":{\"nodes\":{\"name\":[\"dice_dat\",\"dice_pic\",\"input\",\"scholastic_clus\",\"scholastic_dat\",\"scholastic_pic\",\"spells\",\"scholastic_data\",\"scholastic_plot\",\"dice_data\",\"scholastic_clusters\",\"dice_plot\"],\"type\":[\"stem\",\"stem\",\"stem\",\"stem\",\"stem\",\"stem\",\"stem\",\"function\",\"function\",\"function\",\"function\",\"function\"],\"description\":[null,null,null,null,null,null,null,null,null,null,null,null],\"status\":[\"uptodate\",\"uptodate\",\"uptodate\",\"uptodate\",\"uptodate\",\"uptodate\",\"uptodate\",\"uptodate\",\"uptodate\",\"uptodate\",\"uptodate\",\"uptodate\"],\"seconds\":[0.025,0.907,0.256,0.014,0.016,0.219,0.091,null,null,null,null,null],\"bytes\":[33486,65,302514,634,401,71,73966,null,null,null,null,null],\"branches\":[null,null,null,null,null,null,null,null,null,null,null,null],\"label\":[\"dice_dat\",\"dice_pic\",\"input\",\"scholastic_clus\",\"scholastic_dat\",\"scholastic_pic\",\"spells\",\"scholastic_data\",\"scholastic_plot\",\"dice_data\",\"scholastic_clusters\",\"dice_plot\"],\"color\":[\"#354823\",\"#354823\",\"#354823\",\"#354823\",\"#354823\",\"#354823\",\"#354823\",\"#354823\",\"#354823\",\"#354823\",\"#354823\",\"#354823\"],\"id\":[\"dice_dat\",\"dice_pic\",\"input\",\"scholastic_clus\",\"scholastic_dat\",\"scholastic_pic\",\"spells\",\"scholastic_data\",\"scholastic_plot\",\"dice_data\",\"scholastic_clusters\",\"dice_plot\"],\"level\":[3,4,1,4,3,5,2,1,1,1,1,1],\"shape\":[\"dot\",\"dot\",\"dot\",\"dot\",\"dot\",\"dot\",\"dot\",\"triangle\",\"triangle\",\"triangle\",\"triangle\",\"triangle\"]},\"edges\":{\"from\":[\"scholastic_clusters\",\"scholastic_dat\",\"scholastic_data\",\"spells\",\"input\",\"scholastic_clus\",\"scholastic_dat\",\"scholastic_plot\",\"dice_dat\",\"dice_plot\",\"dice_data\",\"spells\"],\"to\":[\"scholastic_clus\",\"scholastic_clus\",\"scholastic_dat\",\"scholastic_dat\",\"spells\",\"scholastic_pic\",\"scholastic_pic\",\"scholastic_pic\",\"dice_pic\",\"dice_pic\",\"dice_dat\",\"dice_dat\"],\"arrows\":[\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\"]},\"nodesToDataframe\":true,\"edgesToDataframe\":true,\"options\":{\"width\":\"100%\",\"height\":\"100%\",\"nodes\":{\"shape\":\"dot\",\"physics\":false},\"manipulation\":{\"enabled\":false},\"edges\":{\"smooth\":{\"type\":\"cubicBezier\",\"forceDirection\":\"horizontal\"}},\"physics\":{\"stabilization\":false},\"interaction\":{\"zoomSpeed\":1},\"layout\":{\"hierarchical\":{\"enabled\":true,\"direction\":\"LR\"}}},\"groups\":null,\"width\":null,\"height\":null,\"idselection\":{\"enabled\":false,\"style\":\"width: 150px; height: 26px\",\"useLabels\":true,\"main\":\"Select by id\"},\"byselection\":{\"enabled\":false,\"style\":\"width: 150px; height: 26px\",\"multiple\":false,\"hideColor\":\"rgba(200,200,200,0.5)\",\"highlight\":false},\"main\":{\"text\":\"\",\"style\":\"font-family:Georgia, Times New Roman, Times, serif;font-weight:bold;font-size:20px;text-align:center;\"},\"submain\":null,\"footer\":null,\"background\":\"rgba(0, 0, 0, 0)\",\"highlight\":{\"enabled\":true,\"hoverNearest\":false,\"degree\":{\"from\":1,\"to\":1},\"algorithm\":\"hierarchical\",\"hideColor\":\"rgba(200,200,200,0.5)\",\"labelOnly\":true},\"collapse\":{\"enabled\":true,\"fit\":false,\"resetHighlight\":true,\"clusterOptions\":null,\"keepCoord\":true,\"labelSuffix\":\"(cluster)\"},\"legend\":{\"width\":0.2,\"useGroups\":false,\"position\":\"right\",\"ncol\":1,\"stepX\":100,\"stepY\":100,\"zoom\":true,\"nodes\":{\"label\":[\"Up to date\",\"Stem\",\"Function\"],\"color\":[\"#354823\",\"#899DA4\",\"#899DA4\"],\"shape\":[\"dot\",\"dot\",\"triangle\"]},\"nodesToDataframe\":true},\"tooltipStay\":300,\"tooltipStyle\":\"position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;font-family: verdana;font-size:14px;font-color:#000000;background-color: #f5f4ed;-moz-border-radius: 3px;-webkit-border-radius: 3px;border-radius: 3px;border: 1px solid #808074;box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);\"},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n\nNow let's suppose that, for whatever reason, I tinker with the plotting code for the \"schools of magic\" image. Perhaps I want to use a different colour scheme or something. So I go back into my code and change the code for the `scholastic_plot()` function, but *only* that function. Let's see what this does to the pipeline visualisation:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_visnetwork()\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"visNetwork html-widget html-fill-item\" id=\"htmlwidget-56457827ab1876f7c579\" style=\"width:100%;height:464px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-56457827ab1876f7c579\">{\"x\":{\"nodes\":{\"name\":[\"dice_dat\",\"dice_pic\",\"input\",\"scholastic_clus\",\"scholastic_dat\",\"scholastic_pic\",\"spells\",\"scholastic_data\",\"scholastic_plot\",\"dice_data\",\"scholastic_clusters\",\"dice_plot\"],\"type\":[\"stem\",\"stem\",\"stem\",\"stem\",\"stem\",\"stem\",\"stem\",\"function\",\"function\",\"function\",\"function\",\"function\"],\"description\":[null,null,null,null,null,null,null,null,null,null,null,null],\"status\":[\"uptodate\",\"uptodate\",\"uptodate\",\"uptodate\",\"uptodate\",\"outdated\",\"uptodate\",\"uptodate\",\"outdated\",\"uptodate\",\"uptodate\",\"uptodate\"],\"seconds\":[0.025,0.907,0.256,0.014,0.016,0.219,0.091,null,null,null,null,null],\"bytes\":[33486,65,302514,634,401,71,73966,null,null,null,null,null],\"branches\":[null,null,null,null,null,null,null,null,null,null,null,null],\"label\":[\"dice_dat\",\"dice_pic\",\"input\",\"scholastic_clus\",\"scholastic_dat\",\"scholastic_pic\",\"spells\",\"scholastic_data\",\"scholastic_plot\",\"dice_data\",\"scholastic_clusters\",\"dice_plot\"],\"color\":[\"#354823\",\"#354823\",\"#354823\",\"#354823\",\"#354823\",\"#78B7C5\",\"#354823\",\"#354823\",\"#78B7C5\",\"#354823\",\"#354823\",\"#354823\"],\"id\":[\"dice_dat\",\"dice_pic\",\"input\",\"scholastic_clus\",\"scholastic_dat\",\"scholastic_pic\",\"spells\",\"scholastic_data\",\"scholastic_plot\",\"dice_data\",\"scholastic_clusters\",\"dice_plot\"],\"level\":[3,4,1,4,3,5,2,1,1,1,1,1],\"shape\":[\"dot\",\"dot\",\"dot\",\"dot\",\"dot\",\"dot\",\"dot\",\"triangle\",\"triangle\",\"triangle\",\"triangle\",\"triangle\"]},\"edges\":{\"from\":[\"scholastic_clusters\",\"scholastic_dat\",\"scholastic_data\",\"spells\",\"input\",\"scholastic_clus\",\"scholastic_dat\",\"scholastic_plot\",\"dice_dat\",\"dice_plot\",\"dice_data\",\"spells\"],\"to\":[\"scholastic_clus\",\"scholastic_clus\",\"scholastic_dat\",\"scholastic_dat\",\"spells\",\"scholastic_pic\",\"scholastic_pic\",\"scholastic_pic\",\"dice_pic\",\"dice_pic\",\"dice_dat\",\"dice_dat\"],\"arrows\":[\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\"]},\"nodesToDataframe\":true,\"edgesToDataframe\":true,\"options\":{\"width\":\"100%\",\"height\":\"100%\",\"nodes\":{\"shape\":\"dot\",\"physics\":false},\"manipulation\":{\"enabled\":false},\"edges\":{\"smooth\":{\"type\":\"cubicBezier\",\"forceDirection\":\"horizontal\"}},\"physics\":{\"stabilization\":false},\"interaction\":{\"zoomSpeed\":1},\"layout\":{\"hierarchical\":{\"enabled\":true,\"direction\":\"LR\"}}},\"groups\":null,\"width\":null,\"height\":null,\"idselection\":{\"enabled\":false,\"style\":\"width: 150px; height: 26px\",\"useLabels\":true,\"main\":\"Select by id\"},\"byselection\":{\"enabled\":false,\"style\":\"width: 150px; height: 26px\",\"multiple\":false,\"hideColor\":\"rgba(200,200,200,0.5)\",\"highlight\":false},\"main\":{\"text\":\"\",\"style\":\"font-family:Georgia, Times New Roman, Times, serif;font-weight:bold;font-size:20px;text-align:center;\"},\"submain\":null,\"footer\":null,\"background\":\"rgba(0, 0, 0, 0)\",\"highlight\":{\"enabled\":true,\"hoverNearest\":false,\"degree\":{\"from\":1,\"to\":1},\"algorithm\":\"hierarchical\",\"hideColor\":\"rgba(200,200,200,0.5)\",\"labelOnly\":true},\"collapse\":{\"enabled\":true,\"fit\":false,\"resetHighlight\":true,\"clusterOptions\":null,\"keepCoord\":true,\"labelSuffix\":\"(cluster)\"},\"legend\":{\"width\":0.2,\"useGroups\":false,\"position\":\"right\",\"ncol\":1,\"stepX\":100,\"stepY\":100,\"zoom\":true,\"nodes\":{\"label\":[\"Up to date\",\"Outdated\",\"Stem\",\"Function\"],\"color\":[\"#354823\",\"#78B7C5\",\"#899DA4\",\"#899DA4\"],\"shape\":[\"dot\",\"dot\",\"dot\",\"triangle\"]},\"nodesToDataframe\":true},\"tooltipStay\":300,\"tooltipStyle\":\"position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;font-family: verdana;font-size:14px;font-color:#000000;background-color: #f5f4ed;-moz-border-radius: 3px;-webkit-border-radius: 3px;border-radius: 3px;border: 1px solid #808074;box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);\"},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\nNot only does targets detect that the function has been altered, it also recognises that the `scholastic_pic` target (and only that target) is now outdated:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_outdated()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"scholastic_pic\"\n```\n\n\n:::\n:::\n\n\n\nTaking this a little further, suppose I also decide to tinker with the `dice_data()` function. Perhaps I've decided that actually I would like the plot to count every *instance* of a dice roll description in each spell, not merely the unique instances. Let's see what it looks like now:\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_visnetwork()\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"visNetwork html-widget html-fill-item\" id=\"htmlwidget-26b22985179f0d812c91\" style=\"width:100%;height:464px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-26b22985179f0d812c91\">{\"x\":{\"nodes\":{\"name\":[\"dice_dat\",\"dice_pic\",\"input\",\"scholastic_clus\",\"scholastic_dat\",\"scholastic_pic\",\"spells\",\"scholastic_data\",\"scholastic_plot\",\"dice_data\",\"scholastic_clusters\",\"dice_plot\"],\"type\":[\"stem\",\"stem\",\"stem\",\"stem\",\"stem\",\"stem\",\"stem\",\"function\",\"function\",\"function\",\"function\",\"function\"],\"description\":[null,null,null,null,null,null,null,null,null,null,null,null],\"status\":[\"outdated\",\"outdated\",\"uptodate\",\"uptodate\",\"uptodate\",\"outdated\",\"uptodate\",\"uptodate\",\"outdated\",\"outdated\",\"uptodate\",\"uptodate\"],\"seconds\":[0.025,0.907,0.256,0.014,0.016,0.219,0.091,null,null,null,null,null],\"bytes\":[33486,65,302514,634,401,71,73966,null,null,null,null,null],\"branches\":[null,null,null,null,null,null,null,null,null,null,null,null],\"label\":[\"dice_dat\",\"dice_pic\",\"input\",\"scholastic_clus\",\"scholastic_dat\",\"scholastic_pic\",\"spells\",\"scholastic_data\",\"scholastic_plot\",\"dice_data\",\"scholastic_clusters\",\"dice_plot\"],\"color\":[\"#78B7C5\",\"#78B7C5\",\"#354823\",\"#354823\",\"#354823\",\"#78B7C5\",\"#354823\",\"#354823\",\"#78B7C5\",\"#78B7C5\",\"#354823\",\"#354823\"],\"id\":[\"dice_dat\",\"dice_pic\",\"input\",\"scholastic_clus\",\"scholastic_dat\",\"scholastic_pic\",\"spells\",\"scholastic_data\",\"scholastic_plot\",\"dice_data\",\"scholastic_clusters\",\"dice_plot\"],\"level\":[3,4,1,4,3,5,2,1,1,1,1,1],\"shape\":[\"dot\",\"dot\",\"dot\",\"dot\",\"dot\",\"dot\",\"dot\",\"triangle\",\"triangle\",\"triangle\",\"triangle\",\"triangle\"]},\"edges\":{\"from\":[\"scholastic_clusters\",\"scholastic_dat\",\"scholastic_data\",\"spells\",\"input\",\"scholastic_clus\",\"scholastic_dat\",\"scholastic_plot\",\"dice_dat\",\"dice_plot\",\"dice_data\",\"spells\"],\"to\":[\"scholastic_clus\",\"scholastic_clus\",\"scholastic_dat\",\"scholastic_dat\",\"spells\",\"scholastic_pic\",\"scholastic_pic\",\"scholastic_pic\",\"dice_pic\",\"dice_pic\",\"dice_dat\",\"dice_dat\"],\"arrows\":[\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\"]},\"nodesToDataframe\":true,\"edgesToDataframe\":true,\"options\":{\"width\":\"100%\",\"height\":\"100%\",\"nodes\":{\"shape\":\"dot\",\"physics\":false},\"manipulation\":{\"enabled\":false},\"edges\":{\"smooth\":{\"type\":\"cubicBezier\",\"forceDirection\":\"horizontal\"}},\"physics\":{\"stabilization\":false},\"interaction\":{\"zoomSpeed\":1},\"layout\":{\"hierarchical\":{\"enabled\":true,\"direction\":\"LR\"}}},\"groups\":null,\"width\":null,\"height\":null,\"idselection\":{\"enabled\":false,\"style\":\"width: 150px; height: 26px\",\"useLabels\":true,\"main\":\"Select by id\"},\"byselection\":{\"enabled\":false,\"style\":\"width: 150px; height: 26px\",\"multiple\":false,\"hideColor\":\"rgba(200,200,200,0.5)\",\"highlight\":false},\"main\":{\"text\":\"\",\"style\":\"font-family:Georgia, Times New Roman, Times, serif;font-weight:bold;font-size:20px;text-align:center;\"},\"submain\":null,\"footer\":null,\"background\":\"rgba(0, 0, 0, 0)\",\"highlight\":{\"enabled\":true,\"hoverNearest\":false,\"degree\":{\"from\":1,\"to\":1},\"algorithm\":\"hierarchical\",\"hideColor\":\"rgba(200,200,200,0.5)\",\"labelOnly\":true},\"collapse\":{\"enabled\":true,\"fit\":false,\"resetHighlight\":true,\"clusterOptions\":null,\"keepCoord\":true,\"labelSuffix\":\"(cluster)\"},\"legend\":{\"width\":0.2,\"useGroups\":false,\"position\":\"right\",\"ncol\":1,\"stepX\":100,\"stepY\":100,\"zoom\":true,\"nodes\":{\"label\":[\"Outdated\",\"Up to date\",\"Stem\",\"Function\"],\"color\":[\"#78B7C5\",\"#354823\",\"#899DA4\",\"#899DA4\"],\"shape\":[\"dot\",\"dot\",\"dot\",\"triangle\"]},\"nodesToDataframe\":true},\"tooltipStay\":300,\"tooltipStyle\":\"position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;font-family: verdana;font-size:14px;font-color:#000000;background-color: #f5f4ed;-moz-border-radius: 3px;-webkit-border-radius: 3px;border-radius: 3px;border: 1px solid #808074;box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);\"},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\nThat makes sense too: the `dice_data()` function affects the `dice_dat` target, but that also has implications for the `dice_pic` target because it depends on `dice_dat`. So now our list of outdated targets looks like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_outdated()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"scholastic_pic\" \"dice_pic\"       \"dice_dat\"      \n```\n\n\n:::\n:::\n\n\n\nWhen we re-run the pipeline this time, those three targets (and only those three targets) are rebuilt. The others are skipped:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_make()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n✔ skipped target input\n✔ skipped target spells\n✔ skipped target scholastic_dat\n▶ dispatched target dice_dat\n● completed target dice_dat [0.031 seconds, 35.004 kilobytes]\n✔ skipped target scholastic_clus\n▶ dispatched target dice_pic\n● completed target dice_pic [0.96 seconds, 65 bytes]\n▶ dispatched target scholastic_pic\n● completed target scholastic_pic [0.204 seconds, 71 bytes]\n▶ ended pipeline [1.547 seconds]\n```\n\n\n:::\n:::\n\n\n\nThis, as you might imagine, is extremely useful in situations where you have a project that involves hundreds of analyses and figures that take a really long time to execute if you re-run everything from the beginning... but all you actually want to do is change the fontsize on figure 312.\n\n::: {.column-margin}\n\n![dice_pic_2.png](./spells-cache/dice_pic_2.png)\n\n:::\n\n::: {.column-margin}\n\n![scholastic_pic_2.png](./spells-cache/scholastic_pic_2.png)\n\n:::\n\n### Postmortem\n\nFor a first attempt at using targets, I'm not unhappy with this. It did what I needed it to do, and I was able to understand the basic structure of the package.\n\nBut there are some limitations. One thing that really bothers me is the way I handled the ggplot code. My thinking at the time was based on the thinking that real life analysis pipelines often have some *very* slow ggplot2 code, but the slow part is not the construction of the object itself, but rather the build, render, and draw stages. It's not much of an issue in this specific example because everything is runs fast, but you can see why I had this worry by looking at what `benchplot()` has to say about the plots I created here:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_load(c(scholastic_dat, scholastic_clus))\n\nbenchplot(\n  ggplot(scholastic_dat, aes(school, class, fill = count)) +\n    geom_tile() +\n    scale_x_dendro(\n      clust = scholastic_clus$school,\n      guide = guide_axis_dendro(n.dodge = 2),\n      expand = expansion(0, 0),\n      position = \"top\"\n    ) +\n    scale_y_dendro(\n      clust = scholastic_clus$class,\n      expand = expansion(0, 0)\n    ) +\n    coord_equal()\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       step user.self sys.self elapsed\n1 construct     0.017    0.000   0.016\n2     build     0.035    0.000   0.035\n3    render     0.042    0.002   0.042\n4      draw     0.026    0.000   0.026\n5     TOTAL     0.120    0.002   0.119\n```\n\n\n:::\n:::\n\n\n\nEven in this example, where there isn't very much that needs to be drawn to the graphics device, constructing the plot isn't the step that takes the most time. So it makes very little sense to treat the plot specification (i.e., the `gg` plot object) as the terminal target of a plotting pipeline, because 90% of the compute time takes place *after* the `gg` object is specified (this is even more obvious when you have a scatterplot that needs to draw millions of dots to the canvas).\n\nHaving been burned by this in the past, I made the decision that my plotting target would encapsulate *all* stages in the plot rendering process. Only once the image has been written to a file would my plot target be deemed complete. As far as it goes, this is very sensible reasoning, but in retrospect I think it might have made a lot more sense to split the plotting target into stages. Saving the `gg` object as an intermediate target (and possibly other stages of the plot construction too) might have been sensible. It might seem like I'm being weirdly nitpicky, but my motivation here is very practical: I have a couple of projects where rerunning the analysis very time-consuming, and the biggest bottleneck (by far) is rendering and drawing some very unpleasant `gg` objects. I've been using a variety of tricks to work around this issue, none of which have been satisfying.^[I mean, if you've reached the point where you're *manually* invalidating parts of the R markdown cache to spare yourself 15 minutes of compute time every time you want to tinker with a figure, girl he's not the man for you and it's time to look for better options.] Targets offers a much cleaner solution to my problem, but it's clear to me just from this toy exercise that I will need to be careful about how I set up targets for these analysis pipelines.\n\nStill, it seems very clear to me that the problem can be solved with targets. My toy example is a kind of worst case solution... if all else fails, I can define the output image itself as the the target to be built. From that perspective, mission accomplished babes. \n\n## Project 2: Building a blog\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset_knitr_dir(\"liteblog\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\nOkay, so the first project went better than I'd hoped. Shall we try something different then? This time around I decided I'd be a little more ambitious, and attempted to write a lightweight blogging tool using [litedown](https://yihui.org/litedown/) as a drop-in replacement for R markdown or quarto, and using targets to manage the build process for the site as a whole. I had two reasons for picking this as my second attempt. First, personal preference: I seem to have developed a habit for rolling my own half-arsed blogging tools. A very long time ago I wrote a bad blogging package called [caladown](https://caladown.djnavarro.net/) that I would not recommend anyone use ever, and about a about a year ago I repeated the foolishness over my summer break when I got bored and built a very silly [blog based on knitr and eleventy](https://knitr-11ty.djnavarro.net/), for literally no reason. Neither exercise was particularly useful, but both were fun. \n\nThe second reason for choosing this project is a little more serious. Unlike a simple analysis pipeline, there are a lot of details about the blog you don't know in advance. You don't know what the files will be called, you don't know how many of them there will be, and so on. On top of that, even if you are able to write a target for \"build a blog post\", you will need to build dozens or hundreds of tiny variations of the same target. There is *no way in hell* anyone wants to hand-code a targets pipeline for this situation: instead, we'll need a mechanism for defining and building targets on the fly, rather than trying to specify all the targets in advance.\n\nIn other words, we'll need to think about [dynamic branching](https://books.ropensci.org/targets/dynamic.html).^[Okay fine, yes, if you've read the user manual you'd probably recognise that static branching would also work here if you were clever enough, and if I'm honest that was what I tried first. But then I realised that a blog is genuinely better suited to dynamic branching and the code was soooooo much simpler this way, so that's what I ran with in the end.]\n\n### Designing the blog\n\nJust like last time, before we talk about the targets pipeline, it's helpful to understand the rest of the project. After a bit of thought, I decided that a \"liteblog\" project would have a structure that looks something like this: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir_tree()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n├── _liteblog-footer.html\n├── _liteblog-header.html\n├── _liteblog.R\n├── _liteblog.css\n├── _targets.R\n└── source\n    ├── 404.rmd\n    ├── _001_hello-cruel-world.rmd\n    ├── _002_blog-object.rmd\n    └── index.rmd\n```\n\n\n:::\n:::\n\n\n\nThis is, of course, what a clean project looks like *before* the blog has been built. Inside the `source` folder there are four R markdown documents, each of which will become an HTML page in the blog. Of these four, two should be built into the site root directory:\n\n- the `index.rmd` document becomes the blog homepage `index.html`\n- the `404.rmd` document becomes the 404 page `404.html`\n\nThe other two documents both correspond to blog posts, and in both cases the underscore is intended to have syntactic meaning. However, unlike the \"usual\" behaviour that you might expect (e.g., from R markdown, blogdown, quarto, etc), the underscore doesn't mean \"do not build\".^[If this were a serious project, this would be a very bad idea: the underscore has an accepted meaning in the various R-based literate programming tools, and it is not good practice to violate user expectations the way I'm doing here. However, this is a silly side project that is not intended to be used for anything, so I feel no compunction at all about violating conventions.] Instead, it is a signifier used to describe the file path expected for the built file:\n\n- `_001_hello-cruel-world.rmd` becomes a post at `/001/hello-cruel-world/index.html`\n- `_002_blog-object.rmd` becomes a post at `/002/blog-object/index.html`\n\nThe other five files in the project folder define the structure and visual appearance of the blog itself. Three of these are grossly typical for any blogging tool:\n\n- `_liteblog-header.html` and `_liteblog-footer.html` are HTML document fragments that will be inserted above and below the content in the R markdown\n- `_liteblog.css`, unsurprisingly, provides the styling\n\nThe final two files are `_liteblog.R` and `_targets.R`. These do all the heavy lifting:\n\n- `_liteblog.R` supplies an [R6](https://r6.r-lib.org/) class called `Liteblog`. The intended usage is that any specific blog is an instance of the class, such that user-specified options (e.g., the name of the site folder, the url for the blog, etc) are supplied as arguments, and the resulting blog object provides all the core functionality (e.g., building pages to the correct folder) for the blog. \n- `_targets.R` provides the build tools: monitoring the source directory, building outdated pages, etc. \n\nBecause the `_liteblog.R` and `_targets.R` scripts are intended to work together, I'll discuss both of them. First, here's what the `_liteblog.R` script looks like:\n\n\n\n::: {.cell filename='_liteblog.R'}\n\n```{.r .cell-code  code-line-numbers=\"true\"}\nLiteblog <- R6::R6Class(\n  classname = \"Liteblog\",\n  public = list(\n\n    initialize = function(root, source, output, url) {\n      self$root <- root\n      self$source <- source\n      self$output <- output\n      self$url <- url\n    },\n\n    root = NULL,\n    source = NULL,\n    output = NULL,\n    url = NULL,\n    pattern = \"[.][rR]?md$\",\n\n    find_posts = function() {\n      files <- dir_ls(\n        path = fs::path(self$root, self$source),\n        recurse = TRUE,\n        regexp = self$pattern,\n        type = \"file\"\n      )\n      unname(unclass(files))\n    },\n\n    find_static = function() {\n      files <- fs::dir_ls(\n        path = fs::path(self$root, self$source),\n        recurse = TRUE,\n        regexp = self$pattern,\n        invert = TRUE,\n        all = TRUE,\n        type = \"file\"\n      )\n      unname(unclass(files))\n    },\n\n    fuse_post = function(file, ...) {\n      output_path <- litedown::fuse(file)\n      output_file <- fs::path_file(output_path)\n      if (stringr::str_detect(output_file, \"^_\")) {\n        destination <- output_file |>\n          stringr::str_replace_all(\"_\", \"/\") |>\n          stringr::str_replace(\"\\\\.html$\", \"/index.html\") |>\n          stringr::str_replace(\"^\", paste0(self$output, \"/\"))\n      } else {\n        destination <- paste0(self$output, \"/\", output_file)\n      }\n      destination <- fs::path(self$root, destination)\n      fs::dir_create(fs::path_dir(destination))\n      fs::file_move(output_path, destination)\n    },\n\n    copy_static = function(file) {\n      destination <- file |>\n        stringr::str_replace(\n          pattern = paste0(\"/\", self$source, \"/\"),\n          replacement = paste0(\"/\", self$output, \"/\")\n        )\n      fs::dir_create(fs::path_dir(destination))\n      fs::file_copy(\n        path = file,\n        new_path = destination,\n        overwrite = TRUE\n      )\n    }\n\n  )\n)\n```\n:::\n\n\n\nIt's not a very complicated R6 class as these things go, and to be honest it could use a lot more love than I've given it. But it works for my purposes so I'll run with it. To initialise a blog I call `Liteblog$new()`, indicating that the current directory is the project root, the `source` folder is the `\"source\"` folder, the `output` folder is called `\"site\"`, and the `url` for the blog is `\"liteblog.djnavarro.net\"`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblog <- Liteblog$new(\n  root = fs::path_abs(\".\"),\n  source = \"source\",\n  output = \"site\",\n  url = \"liteblog.djnavarro.net\"\n)\n```\n:::\n\n\n\nLooking at the code above, you can see that there are four methods:\n\n- `$find_posts()` looks in the source folder and detects the R markdown documents\n- `$find_static()` looks in the source folder and detects other files\n- `$fuse_post()` takes the path to one R markdown document as input, and will build it (called \"fusing\" in the litedown nomenclature) to an HTML file at the appropriate location\n- `$copy_static()` takes the path to a static file as input, and copies it to the output folder\n\nThis provides the core blogging toolkit that I'll now use when writing my target pipeline. It's *extremely* bare bones, and not very customisable, but of course my intention here isn't to build a proper blogging platform. It's just a toy that I can play with when building a more complex build pipeline. Speaking of which...\n\n### The build pipeline\n\nSo, without further tedious exposition, here's the `_targets.R` file:\n\n\n\n::: {.cell filename='_targets.R'}\n\n```{.r .cell-code  code-line-numbers=\"true\"}\nlibrary(targets)\ntar_source(\"_liteblog.R\")\n\nlist(\n\n  # define blog configuration\n  tar_target(\n    name = blog,\n    command = Liteblog$new(\n      root = rprojroot::find_root(\n        rprojroot::has_file(\"_liteblog.R\")\n      ),\n      source = \"source\",\n      output = \"site\",\n      url = \"liteblog.djnavarro.net\"\n    )\n  ),\n\n  # track configuration files\n  tar_target(\n    name = blog_rds, \n    command = saveRDS(blog, file = \"_liteblog.rds\"), \n    format = \"file\"\n  ),\n  tar_target(blog_css, \"_liteblog.css\", format = \"file\"),\n  tar_target(blog_hdr, \"_liteblog-header.html\", format = \"file\"),\n  tar_target(blog_ftr, \"_liteblog-footer.html\", format = \"file\"),\n\n  # detect file paths (always run)\n  tar_target(\n    name = post_paths, \n    command = blog$find_posts(), \n    cue = tar_cue(\"always\")\n  ),\n  tar_target(\n    name = static_paths, \n    command = blog$find_static(), \n    cue = tar_cue(\"always\")\n  ),\n\n  # specify file targets\n  tar_target(\n    name = post_files, \n    command = post_paths, \n    pattern = map(post_paths), \n    format = \"file\"\n  ),\n  tar_target(\n    name = static_files, \n    command = static_paths, \n    pattern = map(static_paths), \n    format = \"file\"\n  ),\n\n  # fuse targets depend on blog configuration files\n  # copy targets don't need dependencies\n  tar_target(\n    name = post_fuse,\n    command = blog$fuse_post(\n      post_files,\n      post_paths,\n      blog_css,\n      blog_hdr,\n      blog_ftr\n    ),\n    pattern = map(post_files)\n  ),\n  tar_target(\n    name = static_copy, \n    command = blog$copy_static(static_files), \n    pattern = map(static_files)\n  )\n)\n```\n:::\n\n\n\nThis is a bit more elaborate than the pipeline I built in my data visualisation process, and uses some fancier tools to work. To get an overall sense of how the pipeline works, I'll call `tar_visnetwork()` again. First, here's a version that only shows the \"core\" of the build pipeline:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_visnetwork(\n  allow = any_of(c(\n    \"static_paths\", \"post_paths\", \"post_files\", \n    \"static_files\", \"post_fuse\", \"static_copy\"\n  ))\n)\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"visNetwork html-widget html-fill-item\" id=\"htmlwidget-15cde5c072f26745d6fe\" style=\"width:100%;height:464px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-15cde5c072f26745d6fe\">{\"x\":{\"nodes\":{\"name\":[\"post_files\",\"post_fuse\",\"post_paths\",\"static_copy\",\"static_files\",\"static_paths\"],\"type\":[\"pattern\",\"pattern\",\"stem\",\"pattern\",\"pattern\",\"stem\"],\"description\":[null,null,null,null,null,null],\"status\":[\"outdated\",\"outdated\",\"outdated\",\"outdated\",\"outdated\",\"outdated\"],\"seconds\":[null,null,null,null,null,null],\"bytes\":[null,null,null,null,null,null],\"branches\":[null,null,null,null,null,null],\"label\":[\"post_files\",\"post_fuse\",\"post_paths\",\"static_copy\",\"static_files\",\"static_paths\"],\"color\":[\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\"],\"id\":[\"post_files\",\"post_fuse\",\"post_paths\",\"static_copy\",\"static_files\",\"static_paths\"],\"level\":[2,3,1,3,2,1],\"shape\":[\"square\",\"square\",\"dot\",\"square\",\"square\",\"dot\"]},\"edges\":{\"from\":[\"post_files\",\"post_paths\",\"static_paths\",\"post_paths\",\"static_files\"],\"to\":[\"post_fuse\",\"post_fuse\",\"static_files\",\"post_files\",\"static_copy\"],\"arrows\":[\"to\",\"to\",\"to\",\"to\",\"to\"]},\"nodesToDataframe\":true,\"edgesToDataframe\":true,\"options\":{\"width\":\"100%\",\"height\":\"100%\",\"nodes\":{\"shape\":\"dot\",\"physics\":false},\"manipulation\":{\"enabled\":false},\"edges\":{\"smooth\":{\"type\":\"cubicBezier\",\"forceDirection\":\"horizontal\"}},\"physics\":{\"stabilization\":false},\"interaction\":{\"zoomSpeed\":1},\"layout\":{\"hierarchical\":{\"enabled\":true,\"direction\":\"LR\"}}},\"groups\":null,\"width\":null,\"height\":null,\"idselection\":{\"enabled\":false,\"style\":\"width: 150px; height: 26px\",\"useLabels\":true,\"main\":\"Select by id\"},\"byselection\":{\"enabled\":false,\"style\":\"width: 150px; height: 26px\",\"multiple\":false,\"hideColor\":\"rgba(200,200,200,0.5)\",\"highlight\":false},\"main\":{\"text\":\"\",\"style\":\"font-family:Georgia, Times New Roman, Times, serif;font-weight:bold;font-size:20px;text-align:center;\"},\"submain\":null,\"footer\":null,\"background\":\"rgba(0, 0, 0, 0)\",\"highlight\":{\"enabled\":true,\"hoverNearest\":false,\"degree\":{\"from\":1,\"to\":1},\"algorithm\":\"hierarchical\",\"hideColor\":\"rgba(200,200,200,0.5)\",\"labelOnly\":true},\"collapse\":{\"enabled\":true,\"fit\":false,\"resetHighlight\":true,\"clusterOptions\":null,\"keepCoord\":true,\"labelSuffix\":\"(cluster)\"},\"legend\":{\"width\":0.2,\"useGroups\":false,\"position\":\"right\",\"ncol\":1,\"stepX\":100,\"stepY\":100,\"zoom\":true,\"nodes\":{\"label\":[\"Outdated\",\"Pattern\",\"Stem\"],\"color\":[\"#78B7C5\",\"#899DA4\",\"#899DA4\"],\"shape\":[\"dot\",\"square\",\"dot\"]},\"nodesToDataframe\":true},\"tooltipStay\":300,\"tooltipStyle\":\"position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;font-family: verdana;font-size:14px;font-color:#000000;background-color: #f5f4ed;-moz-border-radius: 3px;-webkit-border-radius: 3px;border-radius: 3px;border: 1px solid #808074;box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);\"},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\nReduced to this core, the build process is actually pretty simple. There are two separate pipelines. To build the blog posts, we use targets to:\n\n1. Search the source folder to find all the R markdown posts. This is a *single* build target, it consists of a character vector `post_paths` that lists the paths to the various R markdown files. If a post is deleted, or a new R markdown file is added, this vector will change.\n2. Next, we create a target called `post_files` that keeps track of the R markdown files themselves. Or, to be more precise, we create a *pattern* that defines a collection of targets, one per file. If any of those files change, the target will be outdated. I'll talk more about patterns later.\n3. Finally, we have a `post_fuse` target which is used primarily for the side-effect that occurs when the target is built. Specifically, this is the target that renders the blog posts to HTML files, and then copies them over to the blog output folder. \n\nThe second pipeline is analogous, but it operates on everything *other* than the markdown files:\n\n1. The `static_paths` target tracks the paths to the files\n2. The `static_files` target tracks the content of the files\n3. The `static_copy` target copies the static files to the output folder\n\nHere's the full network:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_visnetwork()\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"visNetwork html-widget html-fill-item\" id=\"htmlwidget-eb4567664ad0e30c27d8\" style=\"width:100%;height:464px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-eb4567664ad0e30c27d8\">{\"x\":{\"nodes\":{\"name\":[\"blog\",\"blog_css\",\"blog_ftr\",\"blog_hdr\",\"blog_rds\",\"post_files\",\"post_fuse\",\"post_paths\",\"static_copy\",\"static_files\",\"static_paths\",\"Liteblog\"],\"type\":[\"stem\",\"stem\",\"stem\",\"stem\",\"stem\",\"pattern\",\"pattern\",\"stem\",\"pattern\",\"pattern\",\"stem\",\"object\"],\"description\":[null,null,null,null,null,null,null,null,null,null,null,null],\"status\":[\"outdated\",\"outdated\",\"outdated\",\"outdated\",\"outdated\",\"outdated\",\"outdated\",\"outdated\",\"outdated\",\"outdated\",\"outdated\",\"outdated\"],\"seconds\":[null,null,null,null,null,null,null,null,null,null,null,null],\"bytes\":[null,null,null,null,null,null,null,null,null,null,null,null],\"branches\":[null,null,null,null,null,null,null,null,null,null,null,null],\"label\":[\"blog\",\"blog_css\",\"blog_ftr\",\"blog_hdr\",\"blog_rds\",\"post_files\",\"post_fuse\",\"post_paths\",\"static_copy\",\"static_files\",\"static_paths\",\"Liteblog\"],\"color\":[\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\"],\"id\":[\"blog\",\"blog_css\",\"blog_ftr\",\"blog_hdr\",\"blog_rds\",\"post_files\",\"post_fuse\",\"post_paths\",\"static_copy\",\"static_files\",\"static_paths\",\"Liteblog\"],\"level\":[2,1,1,1,3,4,5,3,5,4,3,1],\"shape\":[\"dot\",\"dot\",\"dot\",\"dot\",\"dot\",\"square\",\"square\",\"dot\",\"square\",\"square\",\"dot\",\"triangleDown\"]},\"edges\":{\"from\":[\"blog\",\"blog\",\"blog_css\",\"blog_ftr\",\"blog_hdr\",\"post_files\",\"post_paths\",\"static_paths\",\"post_paths\",\"blog\",\"static_files\",\"blog\",\"Liteblog\",\"blog\"],\"to\":[\"static_paths\",\"post_fuse\",\"post_fuse\",\"post_fuse\",\"post_fuse\",\"post_fuse\",\"post_fuse\",\"static_files\",\"post_files\",\"static_copy\",\"static_copy\",\"blog_rds\",\"blog\",\"post_paths\"],\"arrows\":[\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\"]},\"nodesToDataframe\":true,\"edgesToDataframe\":true,\"options\":{\"width\":\"100%\",\"height\":\"100%\",\"nodes\":{\"shape\":\"dot\",\"physics\":false},\"manipulation\":{\"enabled\":false},\"edges\":{\"smooth\":{\"type\":\"cubicBezier\",\"forceDirection\":\"horizontal\"}},\"physics\":{\"stabilization\":false},\"interaction\":{\"zoomSpeed\":1},\"layout\":{\"hierarchical\":{\"enabled\":true,\"direction\":\"LR\"}}},\"groups\":null,\"width\":null,\"height\":null,\"idselection\":{\"enabled\":false,\"style\":\"width: 150px; height: 26px\",\"useLabels\":true,\"main\":\"Select by id\"},\"byselection\":{\"enabled\":false,\"style\":\"width: 150px; height: 26px\",\"multiple\":false,\"hideColor\":\"rgba(200,200,200,0.5)\",\"highlight\":false},\"main\":{\"text\":\"\",\"style\":\"font-family:Georgia, Times New Roman, Times, serif;font-weight:bold;font-size:20px;text-align:center;\"},\"submain\":null,\"footer\":null,\"background\":\"rgba(0, 0, 0, 0)\",\"highlight\":{\"enabled\":true,\"hoverNearest\":false,\"degree\":{\"from\":1,\"to\":1},\"algorithm\":\"hierarchical\",\"hideColor\":\"rgba(200,200,200,0.5)\",\"labelOnly\":true},\"collapse\":{\"enabled\":true,\"fit\":false,\"resetHighlight\":true,\"clusterOptions\":null,\"keepCoord\":true,\"labelSuffix\":\"(cluster)\"},\"legend\":{\"width\":0.2,\"useGroups\":false,\"position\":\"right\",\"ncol\":1,\"stepX\":100,\"stepY\":100,\"zoom\":true,\"nodes\":{\"label\":[\"Outdated\",\"Stem\",\"Pattern\",\"Object\"],\"color\":[\"#78B7C5\",\"#899DA4\",\"#899DA4\",\"#899DA4\"],\"shape\":[\"dot\",\"dot\",\"square\",\"triangleDown\"]},\"nodesToDataframe\":true},\"tooltipStay\":300,\"tooltipStyle\":\"position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;font-family: verdana;font-size:14px;font-color:#000000;background-color: #f5f4ed;-moz-border-radius: 3px;-webkit-border-radius: 3px;border-radius: 3px;border: 1px solid #808074;box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);\"},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\nIn this version, you can see that most of the build pipeline depends on the `blog` object: that makes sense because this is the R6 object that defines methods such as `$find_posts()` and `$fuse_post()` that are called when the blog is built. Similarly, since `blog` is itself an instance of the `Liteblog` class, the class itself is an upstream dependency of `blog`.\n\nThe other four targets are less interesting. Three of them (`blog_css`, `blog_hdr`, and `blog_ftr`) are used to keep track of the style files (i.e. `_liteblog.css`, `_liteblog-header.html`, and `_liteblog-footer.html`), so that if any of those files are modified the it will trigger a rebuild of any target that uses those files. The fourth one, `blog_rds`, is a bit of an odd one and I'm not sure I like it: basically it's just a serialised version of the `blog` object itself written to an rds file. The only reason that one is there is to make `blog` visible *within* an R markdown post (i.e., a post can read the `_liteblog.rds` file and call any of the relevant methods if necessary). In general you wouldn't need that, but it's useful if you want to construct a listing page. \n \n### Building the blog\n\nHaving now walked through the structure of the pipeline, it's time to call `tar_make()` and build the blog:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_make()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n▶ dispatched target blog\n● completed target blog [0.002 seconds, 9.739 kilobytes]\n▶ dispatched target blog_css\n● completed target blog_css [0 seconds, 3.759 kilobytes]\n▶ dispatched target blog_ftr\n● completed target blog_ftr [0 seconds, 115 bytes]\n▶ dispatched target blog_hdr\n● completed target blog_hdr [0 seconds, 271 bytes]\n▶ dispatched target static_paths\n● completed target static_paths [0.034 seconds, 139 bytes]\n▶ dispatched target post_paths\n● completed target post_paths [0 seconds, 185 bytes]\n▶ dispatched target blog_rds\n● completed target blog_rds [0.002 seconds, 0 bytes]\n▶ dispatched branch static_files_1b8fcc933438b737\n● completed branch static_files_1b8fcc933438b737 [0 seconds, 0 bytes]\n● completed pattern static_files \n▶ dispatched branch post_files_bfe2f528519c0ff0\n● completed branch post_files_bfe2f528519c0ff0 [0 seconds, 320 bytes]\n▶ dispatched branch post_files_0d76c076472d293c\n● completed branch post_files_0d76c076472d293c [0 seconds, 4.667 kilobytes]\n▶ dispatched branch post_files_64b628c4152d280c\n● completed branch post_files_64b628c4152d280c [0 seconds, 2.451 kilobytes]\n▶ dispatched branch post_files_31d6f026c8bea126\n● completed branch post_files_31d6f026c8bea126 [0 seconds, 1.777 kilobytes]\n● completed pattern post_files \n▶ dispatched branch static_copy_8782d3d7b7b28f55\n● completed branch static_copy_8782d3d7b7b28f55 [0.015 seconds, 173 bytes]\n● completed pattern static_copy \n▶ dispatched branch post_fuse_76c67863243e7a55\n● completed branch post_fuse_76c67863243e7a55 [0.479 seconds, 170 bytes]\n▶ dispatched branch post_fuse_9597bb36619812f6\n● completed branch post_fuse_9597bb36619812f6 [0.321 seconds, 186 bytes]\n▶ dispatched branch post_fuse_95cfcfc8e4bf98af\n● completed branch post_fuse_95cfcfc8e4bf98af [0.092 seconds, 182 bytes]\n▶ dispatched branch post_fuse_84cb9cd7cf957481\n● completed branch post_fuse_84cb9cd7cf957481 [0.045 seconds, 173 bytes]\n● completed pattern post_fuse \n▶ ended pipeline [1.194 seconds]\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_visnetwork()\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"visNetwork html-widget html-fill-item\" id=\"htmlwidget-af58166d53661c8cfb95\" style=\"width:100%;height:464px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-af58166d53661c8cfb95\">{\"x\":{\"nodes\":{\"name\":[\"blog\",\"blog_css\",\"blog_ftr\",\"blog_hdr\",\"blog_rds\",\"post_files\",\"post_fuse\",\"post_paths\",\"static_copy\",\"static_files\",\"static_paths\",\"Liteblog\"],\"type\":[\"stem\",\"stem\",\"stem\",\"stem\",\"stem\",\"pattern\",\"pattern\",\"stem\",\"pattern\",\"pattern\",\"stem\",\"object\"],\"description\":[null,null,null,null,null,null,null,null,null,null,null,null],\"status\":[\"uptodate\",\"uptodate\",\"uptodate\",\"uptodate\",\"uptodate\",\"outdated\",\"outdated\",\"outdated\",\"outdated\",\"outdated\",\"outdated\",\"uptodate\"],\"seconds\":[0.002,0,0,0,0.002,0,0.9370000000000001,0,0.015,0,0.034,null],\"bytes\":[9739,3759,115,271,0,9215,711,185,173,0,139,null],\"branches\":[null,null,null,null,null,4,4,null,1,1,null,null],\"label\":[\"blog\",\"blog_css\",\"blog_ftr\",\"blog_hdr\",\"blog_rds\",\"post_files\",\"post_fuse\",\"post_paths\",\"static_copy\",\"static_files\",\"static_paths\",\"Liteblog\"],\"color\":[\"#354823\",\"#354823\",\"#354823\",\"#354823\",\"#354823\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#354823\"],\"id\":[\"blog\",\"blog_css\",\"blog_ftr\",\"blog_hdr\",\"blog_rds\",\"post_files\",\"post_fuse\",\"post_paths\",\"static_copy\",\"static_files\",\"static_paths\",\"Liteblog\"],\"level\":[2,1,1,1,3,4,5,3,5,4,3,1],\"shape\":[\"dot\",\"dot\",\"dot\",\"dot\",\"dot\",\"square\",\"square\",\"dot\",\"square\",\"square\",\"dot\",\"triangleDown\"]},\"edges\":{\"from\":[\"blog\",\"blog\",\"blog_css\",\"blog_ftr\",\"blog_hdr\",\"post_files\",\"post_paths\",\"static_paths\",\"post_paths\",\"blog\",\"static_files\",\"blog\",\"Liteblog\",\"blog\"],\"to\":[\"static_paths\",\"post_fuse\",\"post_fuse\",\"post_fuse\",\"post_fuse\",\"post_fuse\",\"post_fuse\",\"static_files\",\"post_files\",\"static_copy\",\"static_copy\",\"blog_rds\",\"blog\",\"post_paths\"],\"arrows\":[\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\"]},\"nodesToDataframe\":true,\"edgesToDataframe\":true,\"options\":{\"width\":\"100%\",\"height\":\"100%\",\"nodes\":{\"shape\":\"dot\",\"physics\":false},\"manipulation\":{\"enabled\":false},\"edges\":{\"smooth\":{\"type\":\"cubicBezier\",\"forceDirection\":\"horizontal\"}},\"physics\":{\"stabilization\":false},\"interaction\":{\"zoomSpeed\":1},\"layout\":{\"hierarchical\":{\"enabled\":true,\"direction\":\"LR\"}}},\"groups\":null,\"width\":null,\"height\":null,\"idselection\":{\"enabled\":false,\"style\":\"width: 150px; height: 26px\",\"useLabels\":true,\"main\":\"Select by id\"},\"byselection\":{\"enabled\":false,\"style\":\"width: 150px; height: 26px\",\"multiple\":false,\"hideColor\":\"rgba(200,200,200,0.5)\",\"highlight\":false},\"main\":{\"text\":\"\",\"style\":\"font-family:Georgia, Times New Roman, Times, serif;font-weight:bold;font-size:20px;text-align:center;\"},\"submain\":null,\"footer\":null,\"background\":\"rgba(0, 0, 0, 0)\",\"highlight\":{\"enabled\":true,\"hoverNearest\":false,\"degree\":{\"from\":1,\"to\":1},\"algorithm\":\"hierarchical\",\"hideColor\":\"rgba(200,200,200,0.5)\",\"labelOnly\":true},\"collapse\":{\"enabled\":true,\"fit\":false,\"resetHighlight\":true,\"clusterOptions\":null,\"keepCoord\":true,\"labelSuffix\":\"(cluster)\"},\"legend\":{\"width\":0.2,\"useGroups\":false,\"position\":\"right\",\"ncol\":1,\"stepX\":100,\"stepY\":100,\"zoom\":true,\"nodes\":{\"label\":[\"Up to date\",\"Outdated\",\"Stem\",\"Pattern\",\"Object\"],\"color\":[\"#354823\",\"#78B7C5\",\"#899DA4\",\"#899DA4\",\"#899DA4\"],\"shape\":[\"dot\",\"dot\",\"dot\",\"square\",\"triangleDown\"]},\"nodesToDataframe\":true},\"tooltipStay\":300,\"tooltipStyle\":\"position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;font-family: verdana;font-size:14px;font-color:#000000;background-color: #f5f4ed;-moz-border-radius: 3px;-webkit-border-radius: 3px;border-radius: 3px;border: 1px solid #808074;box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);\"},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\nWhy are some targets still showing as outdated? Because that's how I set them up with `tar_cue()`. By design, every time we rebuild, the blog will check the file paths to see if there are any new static files to be copied or new posts to be fused. Consequently, those two targets and everything downstream of those show up as outdated. But notice that when we call `tar_make()` again...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_make()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n✔ skipped target blog\n✔ skipped target blog_css\n✔ skipped target blog_ftr\n✔ skipped target blog_hdr\n▶ dispatched target static_paths\n● completed target static_paths [0.031 seconds, 139 bytes]\n▶ dispatched target post_paths\n● completed target post_paths [0 seconds, 185 bytes]\n✔ skipped target blog_rds\n✔ skipped branch static_files_1b8fcc933438b737\n✔ skipped pattern static_files\n✔ skipped branch post_files_bfe2f528519c0ff0\n✔ skipped branch post_files_0d76c076472d293c\n✔ skipped branch post_files_64b628c4152d280c\n✔ skipped branch post_files_31d6f026c8bea126\n✔ skipped pattern post_files\n✔ skipped branch static_copy_8782d3d7b7b28f55\n✔ skipped pattern static_copy\n✔ skipped branch post_fuse_76c67863243e7a55\n✔ skipped branch post_fuse_9597bb36619812f6\n✔ skipped branch post_fuse_95cfcfc8e4bf98af\n✔ skipped branch post_fuse_84cb9cd7cf957481\n✔ skipped pattern post_fuse\n▶ ended pipeline [0.114 seconds]\n```\n\n\n:::\n:::\n\n\n\n...only the `static_paths` and `post_paths` targets are rerun: nothing has actually changed in the `source` folder, so the fuse and copy targets are skipped.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir_tree()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n.\n├── _liteblog-footer.html\n├── _liteblog-header.html\n├── _liteblog.R\n├── _liteblog.css\n├── _liteblog.rds\n├── _targets\n│   ├── meta\n│   │   ├── meta\n│   │   ├── process\n│   │   └── progress\n│   ├── objects\n│   │   ├── blog\n│   │   ├── post_fuse_76c67863243e7a55\n│   │   ├── post_fuse_84cb9cd7cf957481\n│   │   ├── post_fuse_9597bb36619812f6\n│   │   ├── post_fuse_95cfcfc8e4bf98af\n│   │   ├── post_paths\n│   │   ├── static_copy_8782d3d7b7b28f55\n│   │   └── static_paths\n│   └── user\n├── _targets.R\n├── site\n│   ├── 001\n│   │   └── hello-cruel-world\n│   │       └── index.html\n│   ├── 002\n│   │   └── blog-object\n│   │       └── index.html\n│   ├── 404.html\n│   └── index.html\n└── source\n    ├── 404.rmd\n    ├── _001_hello-cruel-world.rmd\n    ├── _002_blog-object.rmd\n    └── index.rmd\n```\n\n\n:::\n:::\n\n\n\nNow suppose I were to add two new posts into the the `source` folder:\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nsource\n├── 404.rmd\n├── _001_hello-cruel-world.rmd\n├── _002_blog-object.rmd\n├── _003_schools-of-magic.rmd\n├── _004_spell-dice.rmd\n├── data\n│   └── spells.csv\n└── index.rmd\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_visnetwork()\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"visNetwork html-widget html-fill-item\" id=\"htmlwidget-dc9b6b2f202c941e6590\" style=\"width:100%;height:464px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-dc9b6b2f202c941e6590\">{\"x\":{\"nodes\":{\"name\":[\"blog\",\"blog_css\",\"blog_ftr\",\"blog_hdr\",\"blog_rds\",\"post_files\",\"post_fuse\",\"post_paths\",\"static_copy\",\"static_files\",\"static_paths\",\"Liteblog\"],\"type\":[\"stem\",\"stem\",\"stem\",\"stem\",\"stem\",\"pattern\",\"pattern\",\"stem\",\"pattern\",\"pattern\",\"stem\",\"object\"],\"description\":[null,null,null,null,null,null,null,null,null,null,null,null],\"status\":[\"uptodate\",\"uptodate\",\"uptodate\",\"uptodate\",\"uptodate\",\"outdated\",\"outdated\",\"outdated\",\"outdated\",\"outdated\",\"outdated\",\"uptodate\"],\"seconds\":[0.002,0,0,0,0.002,0,0.9370000000000001,0,0.015,0,0.031,null],\"bytes\":[9739,3759,115,271,0,9215,711,185,173,0,139,null],\"branches\":[null,null,null,null,null,4,4,null,1,1,null,null],\"label\":[\"blog\",\"blog_css\",\"blog_ftr\",\"blog_hdr\",\"blog_rds\",\"post_files\",\"post_fuse\",\"post_paths\",\"static_copy\",\"static_files\",\"static_paths\",\"Liteblog\"],\"color\":[\"#354823\",\"#354823\",\"#354823\",\"#354823\",\"#354823\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#354823\"],\"id\":[\"blog\",\"blog_css\",\"blog_ftr\",\"blog_hdr\",\"blog_rds\",\"post_files\",\"post_fuse\",\"post_paths\",\"static_copy\",\"static_files\",\"static_paths\",\"Liteblog\"],\"level\":[2,1,1,1,3,4,5,3,5,4,3,1],\"shape\":[\"dot\",\"dot\",\"dot\",\"dot\",\"dot\",\"square\",\"square\",\"dot\",\"square\",\"square\",\"dot\",\"triangleDown\"]},\"edges\":{\"from\":[\"blog\",\"blog\",\"blog_css\",\"blog_ftr\",\"blog_hdr\",\"post_files\",\"post_paths\",\"static_paths\",\"post_paths\",\"blog\",\"static_files\",\"blog\",\"Liteblog\",\"blog\"],\"to\":[\"static_paths\",\"post_fuse\",\"post_fuse\",\"post_fuse\",\"post_fuse\",\"post_fuse\",\"post_fuse\",\"static_files\",\"post_files\",\"static_copy\",\"static_copy\",\"blog_rds\",\"blog\",\"post_paths\"],\"arrows\":[\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\"]},\"nodesToDataframe\":true,\"edgesToDataframe\":true,\"options\":{\"width\":\"100%\",\"height\":\"100%\",\"nodes\":{\"shape\":\"dot\",\"physics\":false},\"manipulation\":{\"enabled\":false},\"edges\":{\"smooth\":{\"type\":\"cubicBezier\",\"forceDirection\":\"horizontal\"}},\"physics\":{\"stabilization\":false},\"interaction\":{\"zoomSpeed\":1},\"layout\":{\"hierarchical\":{\"enabled\":true,\"direction\":\"LR\"}}},\"groups\":null,\"width\":null,\"height\":null,\"idselection\":{\"enabled\":false,\"style\":\"width: 150px; height: 26px\",\"useLabels\":true,\"main\":\"Select by id\"},\"byselection\":{\"enabled\":false,\"style\":\"width: 150px; height: 26px\",\"multiple\":false,\"hideColor\":\"rgba(200,200,200,0.5)\",\"highlight\":false},\"main\":{\"text\":\"\",\"style\":\"font-family:Georgia, Times New Roman, Times, serif;font-weight:bold;font-size:20px;text-align:center;\"},\"submain\":null,\"footer\":null,\"background\":\"rgba(0, 0, 0, 0)\",\"highlight\":{\"enabled\":true,\"hoverNearest\":false,\"degree\":{\"from\":1,\"to\":1},\"algorithm\":\"hierarchical\",\"hideColor\":\"rgba(200,200,200,0.5)\",\"labelOnly\":true},\"collapse\":{\"enabled\":true,\"fit\":false,\"resetHighlight\":true,\"clusterOptions\":null,\"keepCoord\":true,\"labelSuffix\":\"(cluster)\"},\"legend\":{\"width\":0.2,\"useGroups\":false,\"position\":\"right\",\"ncol\":1,\"stepX\":100,\"stepY\":100,\"zoom\":true,\"nodes\":{\"label\":[\"Up to date\",\"Outdated\",\"Stem\",\"Pattern\",\"Object\"],\"color\":[\"#354823\",\"#78B7C5\",\"#899DA4\",\"#899DA4\",\"#899DA4\"],\"shape\":[\"dot\",\"dot\",\"dot\",\"square\",\"triangleDown\"]},\"nodesToDataframe\":true},\"tooltipStay\":300,\"tooltipStyle\":\"position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;font-family: verdana;font-size:14px;font-color:#000000;background-color: #f5f4ed;-moz-border-radius: 3px;-webkit-border-radius: 3px;border-radius: 3px;border: 1px solid #808074;box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);\"},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\nLooks the same. But this time when we call `tar_make()`, there will actually be some changes to the `source` folder, so the downstream targets run:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_make()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n✔ skipped target blog\n✔ skipped target blog_css\n✔ skipped target blog_ftr\n✔ skipped target blog_hdr\n▶ dispatched target static_paths\n● completed target static_paths [0.033 seconds, 159 bytes]\n▶ dispatched target post_paths\n● completed target post_paths [0 seconds, 218 bytes]\n✔ skipped target blog_rds\n✔ skipped branch static_files_1b8fcc933438b737\n▶ dispatched branch static_files_790cd5756211053f\n● completed branch static_files_790cd5756211053f [0.001 seconds, 302.514 kilobytes]\n● completed pattern static_files \n✔ skipped branch post_files_bfe2f528519c0ff0\n✔ skipped branch post_files_0d76c076472d293c\n✔ skipped branch post_files_64b628c4152d280c\n▶ dispatched branch post_files_8e7e3b0090f4b0d4\n● completed branch post_files_8e7e3b0090f4b0d4 [0.001 seconds, 11.136 kilobytes]\n▶ dispatched branch post_files_4f6c7b9ae1c233a4\n● completed branch post_files_4f6c7b9ae1c233a4 [0 seconds, 3.631 kilobytes]\n✔ skipped branch post_files_31d6f026c8bea126\n● completed pattern post_files \n✔ skipped branch static_copy_8782d3d7b7b28f55\n▶ dispatched branch static_copy_71bb77eeb0169883\n● completed branch static_copy_71bb77eeb0169883 [0.015 seconds, 173 bytes]\n● completed pattern static_copy \n▶ dispatched branch post_fuse_76c67863243e7a55\n● completed branch post_fuse_76c67863243e7a55 [0.396 seconds, 170 bytes]\n▶ dispatched branch post_fuse_9597bb36619812f6\n● completed branch post_fuse_9597bb36619812f6 [0.394 seconds, 186 bytes]\n▶ dispatched branch post_fuse_95cfcfc8e4bf98af\n● completed branch post_fuse_95cfcfc8e4bf98af [0.15 seconds, 182 bytes]\n▶ dispatched branch post_fuse_08c37253a0821d70\n● completed branch post_fuse_08c37253a0821d70 [0.681 seconds, 185 bytes]\n▶ dispatched branch post_fuse_f9dff6bed3af7eb2\n● completed branch post_fuse_f9dff6bed3af7eb2 [1.072 seconds, 183 bytes]\n▶ dispatched branch post_fuse_84cb9cd7cf957481\n● completed branch post_fuse_84cb9cd7cf957481 [0.048 seconds, 173 bytes]\n● completed pattern post_fuse \n▶ ended pipeline [2.911 seconds]\n```\n\n\n:::\n:::\n\n\n\nThis is clearly an inefficient design: whenever the source folder changes, all of the posts get rendered again. In an ideal world we wouldn't do this, and only those posts (or static files) that have been modified would get run again. However, it would take a little more effort than I'm willing to expend on this side-project to make this work properly: in order for it to behave the way we want it to, the build targets need to be able to inspect the internal contents of each blog post to determine which static files (or other posts!) are hidden dependencies. Discovering those dependencies reliably seems like hard work, so for the purposes of this toy project it just renders everything again.\n\nYou can browse the built website [here](./site/index.html)\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n### Postmortem\n\n\n## Project 3: Parallel computing\n\nFor my third foray into targets, I wanted to take a look at how a targets pipeline can be distributed across multiple parallel threads. Happily, parallel computing is supported out of the box in targets, using the [crew](https://wlandau.github.io/crew/) package to distribute the targets across multiple workers. There are a few slightly different variations on how I looked at this, and I'll go through them each in turn. \n\n### Minimal version\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset_knitr_dir(\"threading1\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\nAs a very minimal implementation, consider this pipeline:\n\n\n\n::: {.cell filename='_targets.R'}\n\n```{.r .cell-code  code-line-numbers=\"true\"}\nlibrary(targets)\nlibrary(crew)\n\ntar_option_set(controller = crew_controller_local(workers = 3))\n\nlist(\n  tar_target(wait1, Sys.sleep(1)),\n  tar_target(wait2, Sys.sleep(2)),\n  tar_target(wait3, Sys.sleep(3)),\n  tar_target(wait4, Sys.sleep(4))\n)\n```\n:::\n\n\n\nThere are four targets here, and all they do is pause execution. If these were run serially, you would expect this to take about 10 seconds to complete. But that's not what happens because I'm using `crew_controller_local()` to define a controller that will split the processing across three parallel workers. Here's what actually happens:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_make()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n▶ dispatched target wait1\n▶ dispatched target wait2\n▶ dispatched target wait3\n● completed target wait1 [1.01 seconds, 44 bytes]\n▶ dispatched target wait4\n● completed target wait2 [2.009 seconds, 44 bytes]\n● completed target wait3 [3.009 seconds, 44 bytes]\n● completed target wait4 [4.005 seconds, 44 bytes]\n▶ ended pipeline [6.912 seconds]\n```\n\n\n:::\n:::\n\n\n\nUpon starting the job, the first three targets (`wait1`, `wait2`, and `wait3`) are dispatched to the three workers and they all start running concurrently. The fourth job (`wait4`) is placed on hold, and doesn't start until the first of the three jobs finishes (`wait1`). Only then does the fourth job start. As the remaining jobs complete, the user is notified, and once they are all finalised targets reports that the pipeline is complete. You can get a high-level summary of the allocation of tasks across workers by calling `tar_crew()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_crew()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n  controller               worker seconds targets\n  <chr>                    <chr>    <dbl>   <int>\n1 ab711f872327111325223545 1         5.10       2\n2 ab711f872327111325223545 2         2.09       1\n3 ab711f872327111325223545 3         3.10       1\n```\n\n\n:::\n:::\n\n\n\nAs expected based on the intuitive description above, this output confirms that there's one worker process that handled two of the targets, and one each handled by the other two. \n\n### Slightly less minimal version\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset_knitr_dir(\"threading2\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\nThe previous example gives a general sense of how parallel execution works in a crew/targets pipeline, but -- possibly because once upon a time I used [callr](https://callr.r-lib.org/) to write my own R6 implementation of a multi-threaded [queue](/posts/2022-12-22_queue/),^[I hasten to add that nobody should be using the [queue](https://queue.djnavarro.net/) package. Like most of my side-projects it was something I wrote just to prove to myself that I could do it, but it's little more than a toy.] which piqued my curiosity about how these things play out -- I found myself wanting a finer-grained description of what each of the workers is doing at each point in time. \n\nAs far as I can tell, neither targets nor crew provides an easy way to do this (but if they do, I would love it if someone can point me in the right direction), so I wrote a slightly more elaborate version of the previous pipeline, in which the targets themselves keep track of the time at which execution starts and stops, as well as the pid of the R process in which they are being executed. In this version, there are three functions that do the work:\n\n- `startup()` is called to build the first target (`start`), and its primary job is to capture the system time at which execution of the first target begins\n- `sleeper()` is used to build the `wait1`, `wait2`, `wait3`, and `wait4` targets. These targets are analogous to the wait targets in the original version, but they also capture information about when execution of these targets started and stopped\n- `collate()` is called at the very end, and is used to construct the `trace` target. This target aggregates all the information from the other targets\n\nHere's the entire code:\n\n\n\n::: {.cell filename='_targets.R'}\n\n```{.r .cell-code  code-line-numbers=\"true\"}\nlibrary(targets)\nlibrary(crew)\n\ntar_option_set(controller = crew_controller_local(workers = 3))\n\nsleeper <- function(duration, pipeline_start, name) {\n  sleep_start <- Sys.time()\n  Sys.sleep(duration)\n  sleep_stop <- Sys.time()\n  tibble::tibble(\n    name           = name,\n    pipeline_start = pipeline_start,\n    worker_pid     = Sys.getpid(),\n    begins_at      = difftime(sleep_start, pipeline_start),\n    finishes_at    = difftime(sleep_stop, pipeline_start)\n  )\n}\n\nstartup <- function() {\n  tibble::tibble(\n    name = \"start\",\n    pipeline_start = Sys.time(),\n    worker_pid     = Sys.getpid(),\n    begins_at      = as.difftime(0, units = \"secs\"),\n    finishes_at    = difftime(Sys.time(), pipeline_start)\n  )\n}\n\ncollate <- function(...) {\n  start <- Sys.time()\n  na_difftime <- as.difftime(NA_real_, units = \"secs\")\n  out <- rbind(...)\n  pipeline_start <- out$pipeline_start[1]\n  out$pipeline_start <- NULL\n  out <- rbind(\n    out,\n    tibble::tibble(\n      name         = \"trace\",\n      worker_pid   = Sys.getpid(),\n      begins_at    = difftime(start, pipeline_start),\n      finishes_at  = difftime(Sys.time(), pipeline_start)\n    )\n  )\n  out$duration    <- out$finishes_at - out$begins_at\n  out$begins_at   <- round(as.numeric(out$begins_at), digits = 3)\n  out$finishes_at <- round(as.numeric(out$finishes_at), digits = 3)\n  out$duration    <- round(as.numeric(out$duration), digits = 3)\n  out\n}\n\nlist(\n  tar_target(start, startup(), cue = tar_cue(\"always\")),\n  tar_target(wait1, sleeper(1, start$pipeline_start, \"wait1\")),\n  tar_target(wait2, sleeper(2, start$pipeline_start, \"wait2\")),\n  tar_target(wait3, sleeper(3, start$pipeline_start, \"wait3\")),\n  tar_target(wait4, sleeper(4, start$pipeline_start, \"wait4\")),\n  tar_target(trace, collate(start, wait1, wait2, wait3, wait4))\n)\n```\n:::\n\n\n\nTo give you a sense of the dependencies, this is what the targets network looks like for this version of the pipeline. All four `wait` targets depend on the `start` target, and the `trace` target depends on everything:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_visnetwork(targets_only = TRUE)\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"visNetwork html-widget html-fill-item\" id=\"htmlwidget-48e6565275f1592f6a3f\" style=\"width:100%;height:464px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-48e6565275f1592f6a3f\">{\"x\":{\"nodes\":{\"name\":[\"start\",\"trace\",\"wait1\",\"wait2\",\"wait3\",\"wait4\"],\"type\":[\"stem\",\"stem\",\"stem\",\"stem\",\"stem\",\"stem\"],\"description\":[null,null,null,null,null,null],\"status\":[\"outdated\",\"outdated\",\"outdated\",\"outdated\",\"outdated\",\"outdated\"],\"seconds\":[null,null,null,null,null,null],\"bytes\":[null,null,null,null,null,null],\"branches\":[null,null,null,null,null,null],\"label\":[\"start\",\"trace\",\"wait1\",\"wait2\",\"wait3\",\"wait4\"],\"color\":[\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\",\"#78B7C5\"],\"id\":[\"start\",\"trace\",\"wait1\",\"wait2\",\"wait3\",\"wait4\"],\"level\":[1,3,2,2,2,2],\"shape\":[\"dot\",\"dot\",\"dot\",\"dot\",\"dot\",\"dot\"]},\"edges\":{\"from\":[\"start\",\"start\",\"start\",\"start\",\"start\",\"wait1\",\"wait2\",\"wait3\",\"wait4\"],\"to\":[\"wait1\",\"wait2\",\"wait3\",\"wait4\",\"trace\",\"trace\",\"trace\",\"trace\",\"trace\"],\"arrows\":[\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\",\"to\"]},\"nodesToDataframe\":true,\"edgesToDataframe\":true,\"options\":{\"width\":\"100%\",\"height\":\"100%\",\"nodes\":{\"shape\":\"dot\",\"physics\":false},\"manipulation\":{\"enabled\":false},\"edges\":{\"smooth\":{\"type\":\"cubicBezier\",\"forceDirection\":\"horizontal\"}},\"physics\":{\"stabilization\":false},\"interaction\":{\"zoomSpeed\":1},\"layout\":{\"hierarchical\":{\"enabled\":true,\"direction\":\"LR\"}}},\"groups\":null,\"width\":null,\"height\":null,\"idselection\":{\"enabled\":false,\"style\":\"width: 150px; height: 26px\",\"useLabels\":true,\"main\":\"Select by id\"},\"byselection\":{\"enabled\":false,\"style\":\"width: 150px; height: 26px\",\"multiple\":false,\"hideColor\":\"rgba(200,200,200,0.5)\",\"highlight\":false},\"main\":{\"text\":\"\",\"style\":\"font-family:Georgia, Times New Roman, Times, serif;font-weight:bold;font-size:20px;text-align:center;\"},\"submain\":null,\"footer\":null,\"background\":\"rgba(0, 0, 0, 0)\",\"highlight\":{\"enabled\":true,\"hoverNearest\":false,\"degree\":{\"from\":1,\"to\":1},\"algorithm\":\"hierarchical\",\"hideColor\":\"rgba(200,200,200,0.5)\",\"labelOnly\":true},\"collapse\":{\"enabled\":true,\"fit\":false,\"resetHighlight\":true,\"clusterOptions\":null,\"keepCoord\":true,\"labelSuffix\":\"(cluster)\"},\"legend\":{\"width\":0.2,\"useGroups\":false,\"position\":\"right\",\"ncol\":1,\"stepX\":100,\"stepY\":100,\"zoom\":true,\"nodes\":{\"label\":[\"Outdated\",\"Stem\"],\"color\":[\"#78B7C5\",\"#899DA4\"],\"shape\":[\"dot\",\"dot\"]},\"nodesToDataframe\":true},\"tooltipStay\":300,\"tooltipStyle\":\"position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;font-family: verdana;font-size:14px;font-color:#000000;background-color: #f5f4ed;-moz-border-radius: 3px;-webkit-border-radius: 3px;border-radius: 3px;border: 1px solid #808074;box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);\"},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\nIn hindsight, I realised that this could have been done more efficiently, but efficiency is not the primary goal here. I just want a pipeline in which all the targets report some detailed information about their execution. So let's run it and see what we get:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_make()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n▶ dispatched target start\n● completed target start [0.009 seconds, 274 bytes]\n▶ dispatched target wait1\n▶ dispatched target wait2\n▶ dispatched target wait3\n● completed target wait1 [1.003 seconds, 282 bytes]\n▶ dispatched target wait4\n● completed target wait2 [2.015 seconds, 282 bytes]\n● completed target wait3 [3.006 seconds, 283 bytes]\n● completed target wait4 [4.017 seconds, 284 bytes]\n▶ dispatched target trace\n● completed target trace [0.013 seconds, 335 bytes]\n▶ ended pipeline [7.144 seconds]\n```\n\n\n:::\n:::\n\n\n\nOkay yes this makes sense. Every other target is dependent on `start`, and by design this target is *always* treated as outdated. So when the pipeline begins, the first thing that happens is that the `start` target is dispatched to a worker; the other two workers do nothing. Once `start` completes, all four wait targets are eligible for dispatch, but we only have three workers and so `wait1`, `wait2`, and `wait4` are farmed out to workers while `wait4` remains in the queue. When `wait1` completes, one of the workers is freed up, thereby allowing `wait4` to be dispatched. Once all four of the wait targets are completed, the final `trace` target is built.\n\nIf we call `tar_crew()`, we get the same high-level overview that we got last time:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrew  <- tar_crew()\ncrew\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n  controller               worker seconds targets\n  <chr>                    <chr>    <dbl>   <int>\n1 c238988f57b39bd17c504a43 1         4.11       4\n2 c238988f57b39bd17c504a43 2         4.10       1\n3 c238988f57b39bd17c504a43 3         2.1        1\n```\n\n\n:::\n:::\n\n\n\nHowever, this time around we also have access to the `trace` target that provides a more detailed summary of which R process excecuted each target, and at what time that execution started and stopped:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrace <- tar_read(trace)\ntrace\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n  name  worker_pid begins_at finishes_at duration\n  <chr>      <int>     <dbl>       <dbl>    <dbl>\n1 start     860292      0           0       0    \n2 wait1     860292      0.04        1.04    1.00 \n3 wait2     860358      1.32        3.32    2.00 \n4 wait3     860292      1.05        4.05    3.00 \n5 wait4     860348      1.29        5.29    4.00 \n6 trace     860292      5.31        5.32    0.003\n```\n\n\n:::\n:::\n\n\n\nIn this data frame, the `begins_at` column records the amount of time that has passed between the time at which the pipeline started, and the time at which the current target begins execution. Similarly `finishes_at` records the time from pipeline start to the current target finishing. The `duration` column is the difference between the two. That being said, if you look at the code I used to calculate these, it's clearly an approximation. But it will suffice. \n\nThe nice thing about the `trace` data is that the `worker_pid` column associates each target with a specific pid for the R process used to build that target. This is slightly finer-grained information than what we got by calling `tar_crew()`. For example, I now know that `start` and `wait1` were both executed by the same R process (i.e., pid 860292). Admittedly this is not much of a revelation: I could have guessed that just by looking at the logs when I called `tar_make()` and a few reasonable assumptions about how the scheduler^[Scheduling in `crew` is handled with the [mirai](https://shikokuchuo.net/mirai/) package, which looks amazing and is now on my to-do list to learn.] works. \n\nOne minor irritation I have with the `trace` output is that it doesn't directly allow me to match the `worker_pid` column against the `worker` column produced by `tar_crew()`. You can see the issue most cleanly if I aggregate the `trace` data frame by `worker_pid` like so:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrace_sum <- trace |> \n  select(worker_pid, duration) |> \n  summarise(\n    seconds = sum(duration), \n    targets = n(), \n    .by = worker_pid\n  )\ntrace_sum\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  worker_pid seconds targets\n       <int>   <dbl>   <int>\n1     860292    4.01       4\n2     860358    2.00       1\n3     860348    4.00       1\n```\n\n\n:::\n:::\n\n\n\nLooking at this it's immediately apparent that worker 1 must corresponded to the R process with pid 860292, since `trace` and `crew` both agree that this is the only worker that executed four distinct targets. However, workers 2 and 3 both executed a single target, so we'll have to resolve the ambiguity by looking at the `seconds` column. This is a little awkward because `trace_sum$seconds` will necessarily be slightly lower than `crew$seconds` because the time estimate in the `trace` data is constructed from *within* the R process that builds the target, but `tar_crew()` would (I assume) estimate the time from outside that process. The differences will be small, but noticeable. So I'll use a rolling join:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworker_lookup <- crew |> \n  left_join(\n    trace_sum, \n    by = join_by(targets, closest(x$seconds > y$seconds))\n  ) |> \n  select(worker, worker_pid)\nworker_lookup\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  worker worker_pid\n  <chr>       <int>\n1 1          860292\n2 2          860348\n3 3          860358\n```\n\n\n:::\n:::\n\n\n\nIt's not ideal but it works: we now have a mapping between the numeric `worker` value returned by `tar_crew()` and the `worker_pid` value returned when `Sys.getpid()` is called from within the target function. Joining this gives us the following table:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntarget_trace <- trace |> \n  left_join(worker_lookup, by = \"worker_pid\") |> \n  mutate(id = row_number()) |> \n  relocate(worker, .before = \"worker_pid\")\ntarget_trace\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 7\n  name  worker worker_pid begins_at finishes_at duration    id\n  <chr> <chr>       <int>     <dbl>       <dbl>    <dbl> <int>\n1 start 1          860292      0           0       0         1\n2 wait1 1          860292      0.04        1.04    1.00      2\n3 wait2 3          860358      1.32        3.32    2.00      3\n4 wait3 1          860292      1.05        4.05    3.00      4\n5 wait4 2          860348      1.29        5.29    4.00      5\n6 trace 1          860292      5.31        5.32    0.003     6\n```\n\n\n:::\n:::\n\n\n\nOr, to adopt a slightly nicer way of looking at it, we can draw a picture:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(target_trace, aes(begins_at, worker, color = name)) + \n  geom_segment(aes(xend = finishes_at, yend = worker)) +\n  geom_point() +\n  geom_point(aes(x = finishes_at)) +\n  theme_bw() + \n  scale_x_continuous(breaks = 0:6) +\n  labs(x = \"time\", y = \"worker\", color = \"target\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/threading-2-trace-plot-1.png){width=768}\n:::\n:::\n\n\n\nOkay yes, this now gives a detailed sense of which targets are dispatched to which workers, and at what time, but it does leave one thing missing: the total elapsed time shown by `target_trace` is about 5-6 seconds, but when I called `tar_make()` the total elapsed time was reported to be a little over 7 seconds. The discrepancy between the two is that the timing information recorded by my code doesn't account for the time that the targets package spends setting up the pipeline, and recording metadata and target values in the `_targets` folder. \n\n### Postmortem\n\nOne thing that bothered me a *lot* about the second version, when I implemented it, was this nagging intuition that most of what I was doing felt unnecessary. Certainly, there's a limitation to the output of `tar_crew()` in the sense that it doesn't tell you the worker to which each target was assigned, nor does it report the pid for each worker. That seems a little odd to me, but I am very willing to believe there's a good reason for that.\n\nThe part that seemed utterly baffling to me was seeing that the on-screen output to `tar_make()` reports the execution time for each target, but (at the time) I couldn't work out how to extract that information programmatically. It beggars belief to think that a package as sophisticated as targets wouldn't record that information somewhere and...\n\n...yeah, of course it does. I was just looking in the wrong place. If you call `tar_meta()` it returns a tibble that stores a detailed listing of all targets -- including the \"secret\"^[Not very secret.] one that records the value of [`.Random.seed`](/posts/2023-12-27_seedcatcher/) -- that includes their execution time, any warnings or errors produced during their execution, and a great deal more besides:\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell .column-page}\n\n```{.r .cell-code}\ntar_meta()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 18\n   name         type     data             command          depend                  seed path      time                size             bytes format repository iteration parent children  seconds warnings error\n   <chr>        <chr>    <chr>            <chr>            <chr>                  <int> <list>    <dttm>              <chr>            <dbl> <chr>  <chr>      <chr>     <chr>  <list>      <dbl> <chr>    <chr>\n 1 startup      function 050b477467191bc8 <NA>             <NA>                      NA <chr [1]> NA                  <NA>                NA <NA>   <NA>       <NA>      <NA>   <chr [1]>  NA     <NA>     <NA> \n 2 collate      function e1dc164dfb76a1e6 <NA>             <NA>                      NA <chr [1]> NA                  <NA>                NA <NA>   <NA>       <NA>      <NA>   <chr [1]>  NA     <NA>     <NA> \n 3 .Random.seed object   0fc6ec0bb4128a3e <NA>             <NA>                      NA <chr [1]> NA                  <NA>                NA <NA>   <NA>       <NA>      <NA>   <chr [1]>  NA     <NA>     <NA> \n 4 sleeper      function 5ead800f7ec58068 <NA>             <NA>                      NA <chr [1]> NA                  <NA>                NA <NA>   <NA>       <NA>      <NA>   <chr [1]>  NA     <NA>     <NA> \n 5 start        stem     bef5e427f9ce8e17 2098fa32bc94d489 b151447ecf216509 -1013159115 <chr [1]> 2025-01-07 12:57:15 7588b18ac8276279   274 rds    local      vector    <NA>   <chr [1]>   0.009 <NA>     <NA> \n 6 wait1        stem     dd34379067cda1cd 8900681d4f1181ad 285bb4dd3e35c533  1208061404 <chr [1]> 2025-01-07 12:57:16 aad6b6763da02644   282 rds    local      vector    <NA>   <chr [1]>   1.00  <NA>     <NA> \n 7 wait2        stem     22c1b1f4a9dd7e68 adfb6c7b6993720a 285bb4dd3e35c533 -2106940369 <chr [1]> 2025-01-07 12:57:18 aad6b6763da02644   282 rds    local      vector    <NA>   <chr [1]>   2.02  <NA>     <NA> \n 8 wait3        stem     692b5dca1dae1472 71bbae8135d59048 285bb4dd3e35c533   216419040 <chr [1]> 2025-01-07 12:57:19 c93e8ca8fd5bc737   283 rds    local      vector    <NA>   <chr [1]>   3.01  <NA>     <NA> \n 9 wait4        stem     b8a62761648c137d 709dbf0fe45e36da 285bb4dd3e35c533 -1433985599 <chr [1]> 2025-01-07 12:57:20 38b61ce0f7e2cdb4   284 rds    local      vector    <NA>   <chr [1]>   4.02  <NA>     <NA> \n10 trace        stem     5cd52802f39daf6c e0601f48904584d2 efab6ed7d1ed73e8   -31475585 <chr [1]> 2025-01-07 12:57:20 d135c5cb0b7ba5c6   335 rds    local      vector    <NA>   <chr [1]>   0.013 <NA>     <NA> \n```\n\n\n:::\n:::\n\n\n\nTrue, it doesn't contain information about the system pid that executes the target, so I'd still have some work to do, but at least now I have the correct timing information for each target.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir_tree(\"_targets\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n_targets\n├── meta\n│   ├── crew\n│   ├── meta\n│   ├── process\n│   └── progress\n├── objects\n│   ├── start\n│   ├── trace\n│   ├── wait1\n│   ├── wait2\n│   ├── wait3\n│   └── wait4\n└── user\n```\n\n\n:::\n:::\n\n\n\nOh well. I'll know better next time, and anyway the entire point of this exercise was to teach myself how to use the package, so it's all good really.\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/htmltools-fill-0.5.8.1/fill.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<link href=\"../../site_libs/vis-9.1.0/vis-network.min.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/vis-9.1.0/vis-network.min.js\"></script>\n<script src=\"../../site_libs/visNetwork-binding-2.1.2/visNetwork.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}