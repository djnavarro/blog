{
  "hash": "663deaa05ff72e4cd51ac26214548eca",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Art from code III: Polygon tricks\"\ndescription: \"This is a subtitle\"\ndate: \"2024-12-20\"\ncategories: [\"R\", \"Art\"]\nimage: \"hexagon.png\"\n--- \n\n\n\n<!--------------- my typical setup ----------------->\n\n\n\n\n\n\n\n<!--------------- post begins here ----------------->\n\n(Adapted from my [Art From Code](https://art-from-code.netlify.app/day-1/session-3/) workshop)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(purrr)\nlibrary(tidyr)\nlibrary(tibble)\nlibrary(ggplot2)\nlibrary(ambient)\nlibrary(tictoc)\nlibrary(ggthemes)\nlibrary(gifski)\n```\n:::\n\n\n\n## Semi-transparent polygons\n\nA commonly used trick in generative art is to simulate graded textures by plotting many slightly-different and mostly-transparent polygons over the top of one another. I showed an example of this at the end of the previous section, in fact. However, it was all tangled up in the discussion of fractals and spatial noise patterns, so it might be useful to revisit it here. \n\nIn this section I'm going to adapt the recursive polygon-deformation technique described in Tyler Hobbes' [guide to simulating water colour paint](https://tylerxhobbs.com/essays/2017/a-generative-approach-to-simulating-watercolor-paints). It's a simple method and works surprisingly well sometimes. The approach I take here isn't precisely identical to his, but it's pretty close. \n\nLet's start by creating a `square` tibble that contains `x` and `y` columns specifying the coordinates for a square, and a `seg_len` column that specifies the length of that of the edge connecting that point to the next one (i.e., the point specified by the next row):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquare <- tibble(\n  x = c(0, 1, 1, 0, 0),\n  y = c(0, 0, 1, 1, 0),\n  seg_len = c(1, 1, 1, 1, 0)\n)\n```\n:::\n\n\n\nThis representation defines a closed path: the fifth and final point is the same location as the first one. You don't technically need this for `geom_polygon()`, but it's convenient for other reasons to set it up so that the final \"segment\" has length 0. \n\nNext let's write a simple plotting function to display a polygon:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nshow_polygon <- function(polygon, show_vertices = TRUE, ...) {\n  \n  pic <- ggplot(polygon, aes(x, y)) +\n    geom_polygon(colour = \"white\", fill = NA, show.legend = FALSE, ...) + \n    coord_equal() + \n    theme_void()\n  \n  if(show_vertices == TRUE) {\n    pic <- pic + geom_point(colour = \"white\", size = 2)\n  }\n  return(pic)\n}\n\nshow_polygon(square)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/square-1.png){fig-align='center' width=1200}\n:::\n:::\n\n\n\nYes, that is indeed a square. \n\nThe next step in our process is to think about ways that we can deform this polygon. A simple method would be to insert a new vertex: we select one of the edges and split it in half by creating a new point in between the two endpoints. If we then add a little noise to perturb the location of the new point, the polygon will be slightly deformed. \n\nHow should we select the edge to break in two? One possibility is to select completely at random, but I'm going to try something slightly different and choose edges with probability proportional to their length. A bias to break longer edges will help ensure we don't end up with polygons with one or two very long edges and many tiny edges. Here's a function that does this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample_edge <- function(polygon) {\n  sample(nrow(polygon), 1, prob = polygon$seg_len)\n}\n```\n:::\n\n\n\nAs a side bonus, this algorithm will never select the \"edge\" that starts with the final point (e.g., the \"fifth\" point in `square` never gets selected) because the corresponding edge has length zero. Thanks to this we can safely assume that no matter which row gets selected by `sample_edge()`, it can't be the last one. For every possible row `ind` it can return, there will always be a row `ind + 1` in the polygon.\n\nNext step is to realise that if we break an edge into two edges, we'll need to compute the length of these two new edges: so we might as well have a helper function that takes the co-ordinates of two points as input, and returns the length of an edge connecting them.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nedge_length <- function(x1, y1, x2, y2) {\n  sqrt((x1 - x2)^2 + (y1 - y2)^2)\n}\n```\n:::\n\n\n\nFinally, as a convenience, here's a function that takes a `size` argument and returns a random number between `-size/2` and `size/2`. It's just a wrapper around `runif()` but I find it helps me remember *why* I'm using the random number generator and it makes my code a little easier for me to read:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nedge_noise <- function(size) {\n  runif(1, min = -size/2, max = size/2)\n}\n```\n:::\n\n\n\nNow that I've got my helper functions, here's the code for an `insert_edge()` function that selects an edge and breaks it into two edges. In addition to expecting a `polygon` as input (a tibble like `square` that has columns `x`, `y`, and `seg_len`), it takes a `noise` argument: a number used to scale the amount of noise added when `edge_noise()` is called: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninsert_edge <- function(polygon, noise) {\n  \n  # sample and edge and remember its length\n  ind <- sample_edge(polygon)\n  len <- polygon$seg_len[ind]\n  \n  # one endpoint of the old edge\n  last_x <- polygon$x[ind]\n  last_y <- polygon$y[ind]\n  \n  # the other endpoint of the old edge\n  next_x <- polygon$x[ind + 1]\n  next_y <- polygon$y[ind + 1]\n  \n  # location of the new point to be inserted: noise \n  # is scaled proportional to the length of the old edge\n  new_x <- (last_x + next_x) / 2 + edge_noise(len * noise)\n  new_y <- (last_y + next_y) / 2 + edge_noise(len * noise)\n  \n  # the new row for insertion into the tibble, \n  # containing coords and length of the 'new' edge\n  new_row <- tibble(\n    x = new_x,\n    y = new_y,\n    seg_len = edge_length(new_x, new_y, next_x, next_y)\n  )\n  \n  # update the length of the 'old' edge\n  polygon$seg_len[ind] <- edge_length(\n    last_x, last_y, new_x, new_y\n  )\n  \n  # insert a row into the tibble\n  bind_rows(\n    polygon[1:ind, ],\n    new_row,\n    polygon[-(1:ind), ]\n  )\n}\n```\n:::\n\n\n\nHere's the function in action:\n\n\n\n::: {.cell .column-screen-inset layout-ncol=\"3\" layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(2)\npolygon <- square \npolygon <- insert_edge(polygon, noise = .5); show_polygon(polygon)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/polygon-insertion-1.png){fig-align='center' width=1200}\n:::\n\n```{.r .cell-code}\npolygon <- insert_edge(polygon, noise = .5); show_polygon(polygon)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/polygon-insertion-2.png){fig-align='center' width=1200}\n:::\n\n```{.r .cell-code}\npolygon <- insert_edge(polygon, noise = .5); show_polygon(polygon)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/polygon-insertion-3.png){fig-align='center' width=1200}\n:::\n:::\n\n\n\nI've no intention of manually calling `insert_edge()` over and over, so the time has come to write a `grow_polygon()` function that sequentially inserts edges into a `polygon` for a fixed number of `iterations`, and at a specific `noise` level. I'll also set it up so the user can optionally elect to specify the `seed` used to generate random numbers. If the user doesn't specify a seed, the random number generator state is left as-is:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrow_polygon <- function(polygon, iterations, noise, seed = NULL) {\n  if(!is.null(seed)) set.seed(seed)\n  for(i in 1:iterations) polygon <- insert_edge(polygon, noise)\n  return(polygon)\n}\n```\n:::\n\n\n\nThe images below show what our recursively deformed polygon looks like after 30, 100, and 1000 iterations:\n\n\n\n::: {.cell .column-screen-inset layout-nrow=\"1\" layout-align=\"center\"}\n\n```{.r .cell-code}\nsquare |> \n  grow_polygon(iterations = 30, noise = .5, seed = 2) |> \n  show_polygon(show_vertices = FALSE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/polygon-generation-1.png){fig-align='center' width=1200}\n:::\n\n```{.r .cell-code}\nsquare |> \n  grow_polygon(iterations = 100, noise = .5, seed = 2) |> \n  show_polygon(show_vertices = FALSE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/polygon-generation-2.png){fig-align='center' width=1200}\n:::\n\n```{.r .cell-code}\nsquare |> \n  grow_polygon(iterations = 1000, noise = .5, seed = 2) |> \n  show_polygon(show_vertices = FALSE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/polygon-generation-3.png){fig-align='center' width=1200}\n:::\n:::\n\n\n\nNow that we have functions `grow_polygon()` and `show_polygon()` that will create and display a single deformed polygon, let's generalise them. The `grow_multipolygon()` function below creates many deformed polygons by calling `grow_polygon()` repeatedly, and the `show_multipolygon()` function is a minor variation on `show_polygon()` that plots many polygons with a low opacity:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrow_multipolygon <- function(base_shape, n, seed = NULL, ...) {\n  if(!is.null(seed)) set.seed(seed)\n  polygons <- list()\n  for(i in 1:n) {\n    polygons[[i]] <- grow_polygon(base_shape, ...)\n  }\n  polygons <- bind_rows(polygons, .id = \"id\")\n  polygons\n}\n\nshow_multipolygon <- function(polygon, fill, alpha = .02, ...) {\n  ggplot(polygon, aes(x, y, group = id)) +\n    geom_polygon(colour = NA, alpha = alpha, fill = fill, ...) + \n    coord_equal() + \n    theme_void()\n}\n```\n:::\n\n\n\nSo now here's what we do. We take the original `square` and deform it a moderate amount. Running `grow_polygon()` for about 100 iterations seems to do the trick. This then becomes the `base_shape` to be passed to `grow_multipolygon()`, which we then use to create many polygons (say, `n = 50`) that are all derived from this base shape. Finally, we use `show_multipolygon()` to plot all 50 polygons. Each individual polygon is plotted with very low opacity, so the overall effect is to create a graded look:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntic()\ndat <- square |> \n  grow_polygon(iterations = 100, noise = .5, seed = 2) |>\n  grow_multipolygon(n = 50, iterations = 1000, noise = 1, seed = 2)\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n37.082 sec elapsed\n```\n\n\n:::\n\n```{.r .cell-code}\nshow_multipolygon(dat, fill = \"#d43790\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/polygon-layering-1.png){fig-align='center' width=1200}\n:::\n:::\n\n\n\nIt's a little slow to produce results, but at least the results are pretty!\n\n\n::: {.callout-important icon=false #exercise-grow-multipolygon}\n## Exercise\n\n1. Let's look at single polygons first. All the code you need to work with those is included in the `grow-polygon.R` function. Try modifying the `iterations`, `noise`, and `seed` arguments to see what kind of output is created at different parameter values.\n\n2. The `grow-multipolygons.R` file contains the extra machinery to create these textured plots. Try playing around with the code for this. I've tweaked the parameter settings so that it runs faster than the code shown here, but doesn't produce output that looks quite as nice.\n\n:::\n\n\n\n## Growing polygons faster\n\nAs an aside, you may have noticed that the code I've written here is inefficient: I've got vectors growing in a loop, which is very inefficient in R. There's a few ways we could speed this up. The most time consuming would be to rewrite the resource intensive loops in C++ and then call it from R using a package like `Rcpp` or `cpp11`. I'll show an example of this technique later in the workshop, but in this case I'll do something a little simpler.\n\nThe big problem with the previous code is that I've got atomic vectors (numeric vectors in this case) growing inside the loop, which tends to cause the entire vector to be copied at every iteration. One solution to this is to store each point as its own list, and treat the polygon as a list of points. That way, when I modify the polygon to add a new point, R will alter the container object (the list), but the objects representing the points themselves don't get copied. Happily, only a few minor modifications of the code are needed to switch to this \"list of points\" representation:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquare_l <- transpose(square)\n\nsample_edge_l <- function(polygon) {\n  sample(length(polygon), 1, prob = map_dbl(polygon, ~ .x$seg_len))\n}\n\ninsert_edge_l <- function(polygon, noise) {\n  \n  ind <- sample_edge_l(polygon)\n  len <- polygon[[ind]]$seg_len\n  \n  last_x <- polygon[[ind]]$x\n  last_y <- polygon[[ind]]$y\n  \n  next_x <- polygon[[ind + 1]]$x\n  next_y <- polygon[[ind + 1]]$y\n  \n  new_x <- (last_x + next_x) / 2 + edge_noise(len * noise)\n  new_y <- (last_y + next_y) / 2 + edge_noise(len * noise)\n  \n  new_point <- list(\n    x = new_x,\n    y = new_y,\n    seg_len = edge_length(new_x, new_y, next_x, next_y)\n  )\n  \n  polygon[[ind]]$seg_len <- edge_length(\n    last_x, last_y, new_x, new_y\n  )\n  \n  c(\n    polygon[1:ind],\n    list(new_point),\n    polygon[-(1:ind)]\n  )\n}\n\ngrow_polygon_l <- function(polygon, iterations, noise, seed = NULL) {\n  if(!is.null(seed)) set.seed(seed)\n  for(i in 1:iterations) polygon <- insert_edge_l(polygon, noise)\n  return(polygon)\n}\n\ngrow_multipolygon_l <- function(base_shape, n, seed = NULL, ...) {\n  if(!is.null(seed)) set.seed(seed)\n  polygons <- list()\n  for(i in 1:n) {\n    polygons[[i]] <- grow_polygon_l(base_shape, ...) |>\n      transpose() |>\n      as_tibble() |>\n      mutate(across(.fn = unlist))\n  }\n  polygons <- bind_rows(polygons, .id = \"id\")\n  polygons\n}\n```\n:::\n\n\n\nThat's a fairly large code chunk, but if you compare each part to the earlier versions you can see that these functions have almost the same structure as the original ones. Most of the changes are little changes to the indexing, like using `polygon[[ind]]$x` to refer to coordinate rather than `polygon$x[ind]`. \n\nThe code to generate images using the list-of-points version is almost identical to the original version. All we're doing differently is using `square_l`, `grow_polygon_l()`, and `grow_multipolygon_l()` where previously we'd used `square`, `grow_polygon()`, and `grow_multipolygon()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntic()\ndat <- square_l |> \n  grow_polygon_l(iterations = 100, noise = .5, seed = 2) |>\n  grow_multipolygon_l(n = 50, iterations = 1000, noise = 1, seed = 2) \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `across(.fn = unlist)`.\nCaused by warning:\n! Using `across()` without supplying `.cols` was deprecated in dplyr 1.1.0.\nℹ Please supply `.cols` instead.\n```\n\n\n:::\n\n```{.r .cell-code}\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n30.916 sec elapsed\n```\n\n\n:::\n:::\n\n\n\nThat's a pretty substantial improvement in performance relative to the original version, with only very minor rewriting of the code. And yes, it does produce the same result:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nshow_multipolygon(dat, fill = \"#d43790\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/fast-polygon-layering-1.png){fig-align='center' width=1200}\n:::\n:::\n\n\n\n\n## Using the method: splotches\n\nOkay, so that's the method. What I generally find when making art is that it's a little awkward to play around and explore when it takes a long time to render pieces, so it's handy to have a version of your generative art tools that will quickly produce results, even if those results aren't quite as nice. It's a little like having the ability to make rough sketches: something you can do easily before committing to doing something in detail. With that in mind, the `splotch()` function below wraps a slightly cruder version of the method than the one I showed earlier. It generates fewer polygons, and those polygons have fewer vertices.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsplotch <- function(seed, layers = 10) {\n  set.seed(seed)\n  square_l <- transpose(tibble(\n    x = c(0, 1, 1, 0, 0),\n    y = c(0, 0, 1, 1, 0),\n    seg_len = c(1, 1, 1, 1, 0)\n  ))\n  square_l |> \n    grow_polygon_l(iterations = 10, noise = .5, seed = seed) |>\n    grow_multipolygon_l(n = layers, iterations = 500, noise = .8, seed = seed) \n}\n```\n:::\n\n\n\nThe results aren't quite as nice as the full fledged version, but they are fast:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntic()\nsplotch_1 <- splotch(seed = 12) \nsplotch_2 <- splotch(seed = 34)\nsplotch_3 <- splotch(seed = 56)\nsplotch_4 <- splotch(seed = 78)\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n6.071 sec elapsed\n```\n\n\n:::\n:::\n\n\n\nBecause `splotch()` is fast and a little crude, it can be a handy way to explore colour choices:\n\n\n\n::: {.cell .column-screen-inset layout-ncol=\"4\" layout-align=\"center\"}\n\n```{.r .cell-code}\nshow_multipolygon(splotch_1, \"#f51720\", alpha = .2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/splotch-1.png){fig-align='center' width=1200}\n:::\n\n```{.r .cell-code}\nshow_multipolygon(splotch_2, \"#f8d210\", alpha = .2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/splotch-2.png){fig-align='center' width=1200}\n:::\n\n```{.r .cell-code}\nshow_multipolygon(splotch_3, \"#059dc0\", alpha = .2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/splotch-3.png){fig-align='center' width=1200}\n:::\n\n```{.r .cell-code}\nshow_multipolygon(splotch_4, \"#81b622\", alpha = .2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/splotch-4.png){fig-align='center' width=1200}\n:::\n:::\n\n\n\n## Using the method: Smudged hexagons\n\nThe goal of `splotch()` is to have a tool we can play around with and explore the method. That's nice and all, but can we also use the method to make something fun? Here's one example: since we are R users and love our hexagons, let's write a function that paints hexagons using this recursive deformation method. The goal is to create a shape with a naturalistic look, as if it had been painted or coloured, with some of the edges smudged or blurred. The `smudged_hexagon()` function attempts to do that:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsmudged_hexagon <- function(seed, noise1 = 0, noise2 = 2, noise3 = 0.5) {\n  set.seed(seed)\n  \n  # define hexagonal base shape\n  theta <- (0:6) * pi / 3\n  hexagon <- tibble(\n    x = sin(theta),\n    y = cos(theta),\n    seg_len = edge_length(x, y, lead(x), lead(y))\n  )\n  hexagon$seg_len[7] <- 0\n  hexagon <- transpose(hexagon)\n  base <- hexagon |> \n    grow_polygon_l(\n      iterations = 60, \n      noise = noise1\n    )\n  \n  # define intermediate-base-shapes in clusters\n  polygons <- list()\n  ijk <- 0\n  for(i in 1:3) {\n    base_i <- base |> \n      grow_polygon_l(\n        iterations = 50, \n        noise = noise2\n      )\n    \n    for(j in 1:3) {\n      base_j <- base_i |> \n        grow_polygon_l(\n          iterations = 50, \n          noise = noise2\n        )\n      \n      # grow 10 polygons per intermediate-base\n      for(k in 1:10) {\n        ijk <- ijk + 1\n        polygons[[ijk]] <- base_j |>\n          grow_polygon_l(\n            iterations = 500, \n            noise = noise3\n          ) |>\n          transpose() |>\n          as_tibble() |>\n          mutate(across(.fn = unlist))\n      }\n    }\n  }\n  \n  # return as data frame\n  bind_rows(polygons, .id = \"id\")\n}\n```\n:::\n\n\n\nHere it is in action:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntic()\ndat <- smudged_hexagon(seed = 1)\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n20.377 sec elapsed\n```\n\n\n:::\n\n```{.r .cell-code}\ndat |> show_multipolygon(fill = \"#d4379005\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/deeply-nested-polygon-layering-1.png){fig-align='center' width=1800}\n:::\n:::\n\n::: {.cell .column-screen layout-ncol=\"3\" layout-align=\"center\"}\n\n```{.r .cell-code}\nsmudged_hexagon(seed = 11) |> show_multipolygon(fill = \"#d4379005\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/smudged-hexagon-examples-1.png){fig-align='center' width=1800}\n:::\n\n```{.r .cell-code}\nsmudged_hexagon(seed = 44) |> show_multipolygon(fill = \"#d4379005\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/smudged-hexagon-examples-2.png){fig-align='center' width=1800}\n:::\n\n```{.r .cell-code}\nsmudged_hexagon(seed = 88) |> show_multipolygon(fill = \"#d4379005\") \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/smudged-hexagon-examples-3.png){fig-align='center' width=1800}\n:::\n:::\n\n::: {.cell .column-screen-inset layout-align=\"center\"}\n\n```{.r .cell-code}\ndat <- bind_rows(\n  smudged_hexagon(seed = 11),\n  smudged_hexagon(seed = 44),\n  smudged_hexagon(seed = 88),\n  .id = \"source\"\n) |>\n  mutate(\n    id = paste(id, source),\n    x = x + as.numeric(source)\n  ) |>\n  arrange(id)\n\nggplot(dat, aes(x, y, group = id, fill = factor(source))) +\n  geom_polygon(alpha = .02, show.legend = FALSE) + \n  theme_void() + \n  scale_fill_manual(values = c(\n    \"#ff1b8d\", \"#ffda00\", \"#1bb3ff\"\n  )) +\n  coord_equal() \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/layered-smudged-hexagon-1.png){fig-align='center' width=4200}\n:::\n:::\n\n\n\nThis one makes me happy :-) \n\n\n::: {.callout-important icon=false #exercise-splotch-hexagon}\n## Exercise\n\nCode for these two systems is included in the `splotch.R` and `smudged-hexagon.R` scripts.\n\n1. Explore the effect of the `layers` argument in the `splotch()` system, and how it interacts with the `alpha` argument to `show_multipolygon()`\n\n2. Create a modified version of the `smudged_hexagon()` system that creates a smudged triangle, or, if you're feeling more ambitious and want to read slightly further down the page to look for the code you need, a smudged heart shape!\n\n3. In the \"layered\" smudged hexagon example (the one with three hexagons of different colours), why did I include the calls to `mutate()` and `arrange()`? What would have happened without that code?\n\n:::\n\n\n\n## Slightly misshapen objects\n\nThe second case of polygon trickery that I want to talk about is adapted from an example kindly shared with me by [Will Chase](https://www.williamrchase.com/). Will posted some code on twitter showing how to very gently deform the outline of a shape to give it a slightly hand drawn look, and I'll expand on that example here. Let's suppose I want to draw the outline of a heart. I do a little googling and discover some formulas that I can use for that purpose. If I have a vector describing the `angle` around circle from 0 to 2$\\pi$, I can compute the x- and y-coordinates for a heart shape using these functions:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nheart_x <- function(angle) {\n  x <- (16 * sin(angle) ^ 3) / 17\n  return(x - mean(x))\n}\n\nheart_y <- function(angle) {\n  y <- (13 * cos(angle) - 5 * cos(2 * angle) - 2 * cos(3 * angle) -\n          cos(4 * angle)) / 17\n  return(y - mean(y))\n}\n```\n:::\n\n\n\nHere's what it looks like when I draw a heart using these formulas:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nheart_shape <- tibble(\n  angle = seq(0, 2 * pi, length.out = 50),\n  x = heart_x(angle),\n  y = heart_y(angle)\n)\nshow_polygon(heart_shape)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/heart-polygon-1.png){fig-align='center' width=1200}\n:::\n:::\n\n\n\nI use hearts drawn with these formulas quite frequently in my art. They're easy to compute, the shape often produces interesting patterns when other processes are applied to it, and of course it's meaningfully associated with positive emotions and affection! However, the problem with using this formula is that the hearts it draws are very precise and mechanical. Sometimes that's fine: precise, crisp shapes are often exactly the look we're going for. But other times we might want an outline that looks a little more naturalistic. For instance, I asked my 9 year old daughter to draw a few heart shapes for me that I could use as an example. Here's what she drew:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nknitr::include_graphics(\"hand-drawn-hearts.jpg\")\n```\n\n::: {.cell-output-display}\n![](hand-drawn-hearts.jpg){fig-align='center' width=666}\n:::\n:::\n\n\n\nSetting aside the fact that in one case she decided that she actually wanted to draw a frog face rather than a heart -- unlike [DALL-E](https://openai.com/dall-e-2/), humans have a tendency to flat out refuse to follow the text prompts when you ask them to make art for you -- these hearts have a qualitatively different feel to the crisp and clean look of the artificial ones.\n\nWhat we'd like to do is gently and smoothly deform the outline of the original shape to produce something that captures some of the naturalistic feel that the hand-drawn hearts have. As always we're not going to try to perfectly reproduce all the features of the original, just capture \"the vibe\".\n\n\n## Perlin blobs\n\nLet's start with a slightly simpler version of the problem: instead of deforming a heart shape we'll deform a circle using Perlin noise. Our base shape is a circle that looks like this:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncircle <- tibble(\n  angle = seq(0, 2*pi, length.out = 50),\n  x = cos(angle),\n  y = sin(angle)\n)\nshow_polygon(circle)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/basic-circle-1.png){fig-align='center' width=1200}\n:::\n:::\n\n\n\nWe can create gently distorted circles using the `perlin_blob()` function shown below. Here's how it works. First it defines coordinates in the shape of a perfect circle (that's the variables `x_base` and `y_base`). Then we use `gen_perlin()` to calculate some spatially varying noise at each of those co-ordinates. Or, more precisely, we generate fractal noise at those coordinates using `gen_perlin()` as the generator and `fbm()` as the fractal function, but that's not a super important detail rignt now. What is important is to realise that, although we want to use the numbers returned by our fractal generator to slightly modify the radius of the circle at that location, those numbers can be negative. So we'll rescale them using the helper function `normalise_radius()` so that the minimum distance from the origin is `r_min` and the maximum distance from the origin is `r_max`. This rescaling helps to ensure that the output is regular.\n\nIn any case, after computing the (Perlin-noise distorted) `radius` associated with each coordinate, we compute the final `x` and `y` values for the \"Perlin blob\" by multiplying the coordinates of the base shape by the radius. Here's the code:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnormalise_radius <- function(x, min, max) {\n  normalise(x, from = c(-0.5, 0.5), to = c(min, max))\n}\n\nperlin_blob <- function(n = 100, \n                        freq_init = 0.3,\n                        octaves = 2, \n                        r_min = 0.5, \n                        r_max = 1) {\n  tibble(\n    angle = seq(0, 2*pi, length.out = n),\n    x_base = cos(angle),\n    y_base = sin(angle),\n    radius = fracture(\n      x = x_base, \n      y = y_base, \n      freq_init = freq_init,\n      noise = gen_perlin, \n      fractal = fbm, \n      octaves = octaves\n    ) |>\n      normalise_radius(r_min, r_max),\n    x = radius * x_base,\n    y = radius * y_base\n  )\n}\n```\n:::\n\n\n\nHere are three outputs from our `perlin_blob()` function:\n\n\n\n::: {.cell .column-screen-inset layout-nrow=\"1\" layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(1); perlin_blob() |> show_polygon(FALSE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/show-perlin-blobs-1.png){fig-align='center' width=1200}\n:::\n\n```{.r .cell-code}\nset.seed(2); perlin_blob() |> show_polygon(FALSE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/show-perlin-blobs-2.png){fig-align='center' width=1200}\n:::\n\n```{.r .cell-code}\nset.seed(3); perlin_blob() |> show_polygon(FALSE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/show-perlin-blobs-3.png){fig-align='center' width=1200}\n:::\n:::\n\n\n\nTo give you a feel for how this function behaves, here's a few images showing the effect of changing the `freq_init` parameter. This argument is used to set the overall noise level when generating fractal noise patterns:\n\n\n\n::: {.cell .column-screen-inset layout-nrow=\"1\" layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(1); perlin_blob(freq_init = .2) |> show_polygon(FALSE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/show-perlin-blob-frequency-1.png){fig-align='center' width=1200}\n:::\n\n```{.r .cell-code}\nset.seed(1); perlin_blob(freq_init = .4) |> show_polygon(FALSE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/show-perlin-blob-frequency-2.png){fig-align='center' width=1200}\n:::\n\n```{.r .cell-code}\nset.seed(1); perlin_blob(freq_init = .8) |> show_polygon(FALSE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/show-perlin-blob-frequency-3.png){fig-align='center' width=1200}\n:::\n:::\n\n\n\nThe effect of the radius parameters is slightly different to the effect of the noise parameter. Shifting the `r_min` and `r_max` arguments has the effect of \"globally flattening\" the pattern of variation because the overall shape can only vary within a narrow bound. But it's quite possible to set a high value for `freq_init` (causing noticeable distortions to the radius to emerge even at small scales) while constraining the global shape to be almost perfectly circular. The result is a rough-edged but otherwise perfect circle:\n\n\n\n::: {.cell .column-screen-inset layout-nrow=\"1\" layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(1); \nperlin_blob(\n  n = 1000,\n  freq_init = 10, \n  r_min = .95, \n  r_max = 1\n) |> \n  show_polygon(FALSE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/show-perlin-blob-radius-1.png){fig-align='center' width=1200}\n:::\n:::\n\n\n\nAt these parameter settings the output of `perlin_blob()` reminds me more of a cookie shape than a hand-drawn circle. I've never used those settings in art before, but I can imagine some tasty applications!\n\n\n::: {.callout-important icon=false #exercise-perlin-blob}\n## Exercise\n\nCode for this system is included in the `perlin-blob.R` script. You can also find analogous code for the Perlin heart system describe in in the next section in the `perlin-heart.R` script.\n\n1. Try playing around with these two systems. See if you can reproduce the same \"qualitative variations\" with `perlin_heart()` that I showed above with `perlin_blob()`\n\n2. Explore the effect of modifying the arguments. It should be possible to produce some very wild looking shapes!\n\n:::\n\n\n\n## Perlin hearts\n\nModifying this system so that it draws distorted heart shapes rather than distorted circles is not too difficult. There's a few different ways we can do this, but the way I find most pleasing is to start with a distorted circle and then apply the `heart_x()` and `heart_y()` transformations:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nperlin_heart <- function(n = 100, \n                         freq_init = 0.3,\n                         octaves = 2, \n                         r_min = 0.5, \n                         r_max = 1,\n                         x_shift = 0,\n                         y_shift = 0,\n                         id = NA,\n                         seed = NULL) {\n  if(!is.null(seed)) set.seed(seed)\n  tibble(\n    angle = seq(0, 2*pi, length.out = n),\n    x_base = cos(angle),\n    y_base = sin(angle),\n    radius = fracture(\n      x = x_base, \n      y = y_base, \n      freq_init = freq_init,\n      noise = gen_perlin, \n      fractal = fbm, \n      octaves = octaves\n    ) |>\n      normalise_radius(r_min, r_max),\n    x = radius * heart_x(angle) + x_shift,\n    y = radius * heart_y(angle) + y_shift,\n    id = id\n  )\n}\n```\n:::\n\n\n\nHere are three outputs from our `perlin_heart()` function:\n\n\n\n::: {.cell .column-screen-inset layout-nrow=\"1\" layout-align=\"center\"}\n\n```{.r .cell-code}\nperlin_heart(seed = 1) |> show_polygon(FALSE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/show-perlin-hearts-1.png){fig-align='center' width=1200}\n:::\n\n```{.r .cell-code}\nperlin_heart(seed = 2) |> show_polygon(FALSE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/show-perlin-hearts-2.png){fig-align='center' width=1200}\n:::\n\n```{.r .cell-code}\nperlin_heart(seed = 3) |> show_polygon(FALSE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/show-perlin-hearts-3.png){fig-align='center' width=1200}\n:::\n:::\n\n\n\nOne of my favourite systems is a very simple one that draws many of these Perlin hearts on a grid, filling each one with a colour selected from a randomly sampled palette. To replicate that here I'll need a palette generator and once again I'll fall back on our old favourite `sample_canva()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample_canva <- function(seed = NULL) {\n  if(!is.null(seed)) set.seed(seed)\n  sample(ggthemes::canva_palettes, 1)[[1]]\n}\n```\n:::\n\n\n\nNow that we have a palette generator we can use the functional programming toolkit from `purrr` to do the work for us. In this case I'm using `pmap_dfr()` to call the `perlin_heart()` at a variety of different settings. I've included the `x_shift`, `y_shift` and `id` values among the settings to make it a little easier to plot the data:\n\n\n\n::: {.cell .column-screen-inset layout-ncol=\"1\" layout-align=\"center\"}\n\n```{.r .cell-code}\nperlin_heart_grid <- function(nx = 10, ny = 6, seed = NULL) {\n  if(!is.null(seed)) set.seed(seed)\n  \n  heart_settings <- expand_grid(\n    r_min = .3, \n    r_max = .4, \n    x_shift = 1:nx, \n    y_shift = 1:ny\n  ) |>\n    mutate(id = row_number()) \n  \n  heart_data <-  pmap_dfr(heart_settings, perlin_heart)\n  \n  heart_data |>\n    ggplot(aes(x, y, group = id, fill = sample(id))) +\n    geom_polygon(size = 0, show.legend = FALSE) +\n    theme_void() +\n    scale_fill_gradientn(colours = sample_canva(seed)) +\n    coord_equal(xlim = c(0, nx + 1), ylim = c(0, ny + 1))\n}\n\nperlin_heart_grid(seed = 451)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/perlin-hearts-1.png){fig-align='center' width=4200}\n:::\n:::\n\n\n\n::: {.callout-important icon=false #exercise-perlin-heard-grid}\n## Exercise\n\nCode for this system is included as the `perlin-heart-grid.R` script. To check that you understand it, try modifying it in the following ways:\n\n1. Only show 50% of the hearts\n\n2. Add a small amount of random noise to the position of each heart\n\n3. Give all the hearts the \"rough edged biscuit\" look\n\n:::\n\n\nWe can elaborate on this idea in various ways. For example, the `perlin_heart2()` function shown below modifies the original idea by adding a additional `width` variable computed in a similar way to `radius`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nperlin_heart2 <- function(n = 100, \n                          freq_init = 0.3,\n                          octaves = 2, \n                          r_min = 0.5, \n                          r_max = 1,\n                          w_min = 0,\n                          w_max = 4,\n                          rot = 0,\n                          x_shift = 0,\n                          y_shift = 0,\n                          id = NA,\n                          seed = NULL) {\n  if(!is.null(seed)) set.seed(seed)\n  tibble(\n    angle = seq(0, 2*pi, length.out = n),\n    \n    radius = fracture(\n      x = cos(angle), \n      y = sin(angle), \n      freq_init = freq_init,\n      noise = gen_perlin, \n      fractal = fbm, \n      octaves = octaves\n    ) |>\n      normalise_radius(r_min, r_max),\n    \n    x = radius * heart_x(angle) + x_shift,\n    y = radius * heart_y(angle) + y_shift,\n    \n    width = fracture(\n      x = cos(angle + rot), \n      y = sin(angle + rot), \n      freq_init = freq_init,\n      noise = gen_perlin, \n      fractal = fbm, \n      octaves = octaves\n    ) |>\n      normalise(to = c(w_min, w_max)),\n    \n    id = id\n  )\n}\n```\n:::\n\n\n\n\nHere are three outputs from our `perlin_heart2()` function, showing the effect of varying the `rot` parameter. Because the width of outline varies, `rot` causes the whole pattern of variable thickness to rotate around the heart. As you might imagine, this is going to turn out to be very handy in a moment when we start animating these things!\n\n\n\n::: {.cell .column-screen-inset layout-nrow=\"1\" layout-align=\"center\"}\n\n```{.r .cell-code}\nshow_width <- function(polygon) {\n  ggplot(polygon, aes(x, y, size = width)) +\n    geom_path(colour = \"white\", fill = NA, show.legend = FALSE) + \n    coord_equal() + \n    scale_size_identity() +\n    theme_void()\n}\n\nperlin_heart2(n = 1000, rot = 0, seed = 2) |> show_width()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/show-perlin-hearts-2-1.png){fig-align='center' width=1200}\n:::\n\n```{.r .cell-code}\nperlin_heart2(n = 1000, rot = pi / 2, seed = 2) |> show_width()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/show-perlin-hearts-2-2.png){fig-align='center' width=1200}\n:::\n\n```{.r .cell-code}\nperlin_heart2(n = 1000, rot = pi, seed = 2) |> show_width()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/show-perlin-hearts-2-3.png){fig-align='center' width=1200}\n:::\n:::\n\n\n\nHere's an example where I plot several hearts at once courtesy of the magic of `pmap_dfr()`:\n\n\n\n::: {.cell .column-screen-inset layout-ncol=\"1\" layout-align=\"center\"}\n\n```{.r .cell-code}\nperlin_heart_grid2 <- function(nx = 4, ny = 2, seed = NULL) {\n  if(!is.null(seed)) set.seed(seed)\n  \n  heart_settings <- expand_grid(\n    r_min = .3, \n    r_max = .4, \n    w_min = .01,\n    w_max = 6,\n    x_shift = 1:nx, \n    y_shift = 1:ny\n  ) |>\n    mutate(\n      n = 200,\n      x_shift = x_shift + runif(n(), -.1, .1),\n      y_shift = y_shift + runif(n(), -.1, .1),\n      rot = runif(n(), -.1, .1),\n      id = row_number()\n    ) \n  \n  heart_data <-  pmap_dfr(heart_settings, perlin_heart2)\n  \n  heart_data |>\n    ggplot(aes(x, y, group = id, colour = sample(id), size = width)) +\n    geom_path(show.legend = FALSE) +\n    theme_void() +\n    scale_size_identity() +\n    scale_colour_gradientn(colours = sample_canva(seed)) +\n    scale_x_continuous(expand = c(0, 0)) +\n    scale_y_continuous(expand = c(0, 0)) +\n    coord_fixed(xlim = c(0, nx + 1), ylim = c(0, ny + 1))\n}\n\nperlin_heart_grid2(seed = 666)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/perlin-heart-2-1.png){fig-align='center' width=4200}\n:::\n:::\n\n\n\n\n::: {.callout-important icon=false #exercise-perlin-heard-grid-2}\n## Exercise\n\nCode for this system is included as the `perlin-heart-grid-2.R` script. Can you modify it so that each heart is plotted in a single colour rather than in the banded pattern? With different hearts having different colours?\n\n:::\n\n\n## Animated perlin hearts\n\nThe final example for this session uses the `gifsky` package to create an animated version of the variable-width hearts from the last section, by \"rotating\" or \"sliding\" the variable-with curves along the contours of the Perlin hearts. The design of the functions in this system is very similar in spirit to that adopted in the static systems. The main difference is that the output is created by calling the `save_gif()` function. We pass it an expression that, in the normal course of events, would create many plots -- that's what the `generate_all_frames()` function does -- and it captures these plots and turns them into a single animated gif:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nperlin_heart_data <- function(nhearts = 10, scatter = .05, seed = NULL) {\n  \n  if(!is.null(seed)) set.seed(seed)\n  \n  palette <- sample_canva(seed) |>\n    (\\(x) colorRampPalette(x)(nhearts))()\n  \n  heart_settings <- tibble(\n    id = 1:nhearts,\n    n = 500,\n    r_min = .35, \n    r_max = .4,\n    w_min = -10, \n    w_max = 10,\n    x_shift = runif(nhearts, -scatter/2, scatter/2),\n    y_shift = runif(nhearts, -scatter/2, scatter/2),\n    rot = runif(nhearts, -pi, pi)\n  )\n  \n  heart_settings |>\n    pmap_dfr(perlin_heart2) |>\n    group_by(id) |>\n    mutate(\n      shade = sample(palette, 1),\n      width = abs(width)\n    )\n}\n\ngenerate_one_frame <- function(dat) {\n  \n  pic <- dat |>\n    ggplot(aes(x, y, group = id, size = width, colour = shade)) +\n    geom_path(show.legend = FALSE) +\n    theme_void() +\n    scale_x_continuous(expand = c(0, 0)) +\n    scale_y_continuous(expand = c(0, 0)) +\n    scale_colour_identity() +\n    scale_size_identity() +\n    coord_fixed(xlim = c(-.6, .6), ylim = c(-.6, .6))\n  \n  print(pic)\n}\n\nrotate_vector <- function(x, percent) {\n  \n  len <- length(x)\n  ind <- ceiling(len * percent)\n  if(ind == 0) return(x)\n  if(ind == len) return(x)\n  c(x[(ind+1):len], x[1:ind])\n}\n\ngenerate_all_frames <- function(dat, nframes = 100) {\n  \n  for(frame in 1:nframes) {\n    dat |>\n      group_by(id) |>\n      mutate(width = width |> rotate_vector(frame / nframes)) |>\n      generate_one_frame()\n  }\n}\n\nanimated_perlin_heart <- function(seed, ...) {\n  \n  save_gif(\n    expr = perlin_heart_data(seed = seed, ...) |> generate_all_frames(),\n    gif_file = paste0(\"animated-perlin-heart-\", seed, \".gif\"),\n    height = 1000,\n    width = 1000,\n    delay = .1,\n    progress = TRUE,\n    bg = \"#222222\"\n  )\n  invisible(NULL)\n}\n\ntic()\nanimated_perlin_heart(seed = 100)\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n12.454 sec elapsed\n```\n\n\n:::\n\n```{.r .cell-code}\nknitr::include_graphics(\"animated-perlin-heart-100.gif\") \n```\n\n::: {.cell-output-display}\n![](animated-perlin-heart-100.gif){fig-align='center'}\n:::\n:::\n\n::: {.cell .column-screen-inset layout-ncol=\"3\" layout-align=\"center\"}\n\n```{.r .cell-code}\nanimated_perlin_heart(seed = 123)\nanimated_perlin_heart(seed = 456)\nanimated_perlin_heart(seed = 789)\n\nknitr::include_graphics(\"animated-perlin-heart-123.gif\")\n```\n\n::: {.cell-output-display}\n![](animated-perlin-heart-123.gif){fig-align='center'}\n:::\n\n```{.r .cell-code}\nknitr::include_graphics(\"animated-perlin-heart-456.gif\")\n```\n\n::: {.cell-output-display}\n![](animated-perlin-heart-456.gif){fig-align='center'}\n:::\n\n```{.r .cell-code}\nknitr::include_graphics(\"animated-perlin-heart-789.gif\")\n```\n\n::: {.cell-output-display}\n![](animated-perlin-heart-789.gif){fig-align='center'}\n:::\n:::\n\n\n\n\n\n::: {.callout-important icon=false #exercise-perlin-animated}\n## Exercise\n\nCode for this system is included in the `perlin-heart-animated.R` script. Personally I just find this one fun to play with, so instead of setting an exercise I'll let you take a look! \n\n:::\n\n\n\n## Textured lines\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(e1071)\n```\n:::\n\n\n\nThere's one other topic I want to mention in this session, and it's completely unrelated to rayshader or 3D graphics. It's also -- broadly speaking -- to do with texture and shading, but it applies at a much lower level. To motivate the topic, I'll start by writing a function that uses statistical tools to generate random smooth curves in two dimensions:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsmooth_loess <- function(x, span) {\n  n <- length(x)\n  dat <- tibble(time = 1:n, walk = x)\n  mod <- loess(walk ~ time, dat, span = span)\n  predict(mod, tibble(time = 1:n))\n}\n\nsmooth_path <- function(n = 1000, smoothing = .4, seed = NULL) { \n  if(!is.null(seed)) set.seed(seed)\n  tibble(\n    x = smooth_loess(rbridge(1, n), span = smoothing),\n    y = smooth_loess(rbridge(1, n), span = smoothing),\n    stroke = 1\n  )\n}\n```\n:::\n\n\n\nHere's an example of the paths it produces:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npath <- smooth_path(seed = 123)\n\npath |> \n  ggplot(aes(x, y)) +\n  geom_path(colour = \"white\", size = 2) + \n  coord_equal() +\n  theme_void() \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/smooth-path-1.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\nThe path it self is smooth but slightly misshapen (i.e., it doesn't feel \"precise\" in the same way that the very first heart felt precise), and you can imagine creating a generative art system that uses this kind of technique, but it doesn't feel hand drawn. The problem here is that while the *path* feels fairly natural, the *stroke* itself is too perfect. It's a solid line with no texture or grading to it. That spoils the illusion of naturalness to an extent.\n\nIt's not too difficult to improve on this if, instead of plotting one smooth curve to represent the path, we plot a very large number of points or small segments with irregular breaks and spacing. In this section I won't go into a lot of detail on design choices and the various ways you can do this, but I'll mention that Ben Kovach has a lovely post on [making generative art feel natural](https://www.generativehut.com/post/how-to-make-generative-art-feel-natural) that discusses this in more detail. \n\nFor now, I'll limit myself to presenting some code for a system that implements this idea:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nperturb <- function(path, noise = .01, span = .1) {\n  path |> \n    group_by(stroke) |>\n    mutate(\n      x = x + rnorm(n(), 0, noise),\n      y = y + rnorm(n(), 0, noise),\n      x = smooth_loess(x, span),\n      y = smooth_loess(y, span),\n      alpha = runif(n()) > .5,\n      size = runif(n(), 0, .2)\n    )\n}\n\nbrush <- function(path, bristles = 100, seed = 1, ...) {\n  set.seed(seed)\n  dat <- list()\n  for(i in 1:bristles) {\n    dat[[i]] <- perturb(path, ...)\n  }\n  return(bind_rows(dat, .id = \"id\"))\n}\n\nstroke <- function(dat, geom = geom_path, colour = \"white\", ...) {\n  dat |>  \n    ggplot(aes(\n      x = x, \n      y = y, \n      alpha = alpha, \n      size = size, \n      group = paste0(stroke, id)\n    )) + \n    geom(\n      colour = colour, \n      show.legend = FALSE,\n      ...\n    ) + \n    coord_equal() +\n    scale_alpha_identity() +\n    scale_size_identity() +\n    theme_void() + \n    theme(plot.background = element_rect(\n      fill = \"#222222\", \n      colour = \"#222222\"\n    ))\n}\n```\n:::\n\n\n\nThe plots below show a couple of examples of how you can apply this idea to our original curve:\n\n\n\n::: {.cell .column-screen-inset layout-ncol=\"2\" layout-align=\"center\"}\n\n```{.r .cell-code}\npath |>\n  brush() |>\n  stroke()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/smooth-path-textured-1.png){fig-align='center' width=1800}\n:::\n\n```{.r .cell-code}\npath |>\n  brush(bristles = 200, span = .08) |>\n  mutate(size = size * 3) |>\n  stroke(geom = geom_point, stroke = 0)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/smooth-path-textured-2.png){fig-align='center' width=1800}\n:::\n:::\n\n\n\nThis doesn't in any sense exhaust the possibilities, but I hope it's a useful hint about how to get started if you ever find yourself trying to figure out how to draw naturalistic looking pen strokes. Also, the fact that I've included the code means I get to apply the idea to the Perlin hearts system:\n\n\n\n::: {.cell .column-page layout-align=\"center\"}\n\n```{.r .cell-code}\nperlin_heart(n = 500, seed = 123) |>\n  mutate(stroke = 1) |>\n  brush(bristles = 100, noise = .02) |>\n  stroke() \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/perlin-heart-texture-1.png){fig-align='center' width=1200}\n:::\n:::\n\n\n\n\n::: {.callout-important icon=false #exercise-textured-lines}\n## Exercise\n\nCode for this system is included in the `textured-lines.R` script. Try to use this a jumping-off point for designing your own system for generating textured lines. There's no real reason why you should do it my way. How would you do this yourself?\n\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}