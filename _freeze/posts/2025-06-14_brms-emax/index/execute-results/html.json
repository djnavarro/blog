{
  "hash": "e96bd5434468da7a7b334938e153d7bc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Bayesian Emax regression using brms\"\ndescription: \"This is a draft post, please do not cite or share yet\"\ndate: \"2025-06-14\"\nimage: \"./img/june_02_0205.jpg\"\nimage-alt: \"Abstract generative art in a red and orange palette\"\ncategories: [\"R\", \"Pharmacometrics\", \"Statistics\", \"Bayes\", \"Stan\"]\n--- \n\n\n\n\n<!--------------- my typical setup ----------------->\n\n\n\n\n\n\n\n<!--------------- post begins here ----------------->\n\nThis is another in the ongoing series of posts I've written on [pharmacometrics](/#category=Pharmacometrics). As usual I feel a little cautious writing about this topic because I'm still relatively new to this field,^[I mean okay I've been a pharmacometrician for two years now so I guess I can officially add that to the long list of scientific/technical fields in which I've worked, but nevertheless I am acutely aware of how much I still have left to learn.] but fortunately for my impostor syndrome this is a post about Bayesian Emax regression models for exposure-response analysis, and as it happens I've worked with these tools a few times before. In fact, one of my ongoing collaborations has been with the very wonderful Kenta Yoshida, in which I've helped out with some updates to the [rstanemax](https://yoshidk6.github.io/rstanemax/) and [BayesERtools](https://mc-stan.org/docs/stan-users-guide/latent-discrete.html) R packages, and contributed a few chapters to the [BayesERbook](https://genentech.github.io/BayesERbook/) guide that Kenta has been leading. It's been a lot of fun. I love it when my professional life lets me work on projects that are legitimately enjoyable. ðŸŽ‰\n\nSo okay, in this post I'm going to talk about implementing Bayesian Emax regression models within the lovely [brms](https://paulbuerkner.com/brms/) package. It's territory we've already covered in BayesERbook, which might make people wonder why I would write a blog post here also, but the thing about writing on my own blog is that here I am under no obligation to behave professionally, thus [allowing me my full range of expression](https://www.quotes.net/mquote/716213). It would be only the most naive of readers that come to this blog expecting a statistics discusssion to be PG-rated. I am notoriously poor at compartmentalisation, and miscellaneous queerness tends to intrude into the data science.^[In fairness, this goes both ways, and I rather suspect that my tendency to discuss linear algebra on grindr might explain the current absence of a man in my life. Though also in fairness, it's not precisely *my life* that I want a man inside. Either way though, bringing up eigendecompositions has not been a very effective strategy for me on the apps.] Also, because the book chapters already exist and cover a wider range of topics than this post, it gives me licence to touch on a few topics that aren't in the book. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(brms)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(tibble)\nlibrary(ggplot2)\nlibrary(tidybayes)\n```\n:::\n\n\n\n\n\n\n![\"coatless in the rain\"](./img/june_02_0205.jpg)\n\n## Formalism\n\nI'll start by considering the simplest case: a simple Emax regression model for a continuous response variable, with no covariates. First, the formalism. Letting $\\phi_i$ denote^[Using $\\phi_i$ here is not standard notation, and insofar as exposure is treated as a predictor for the response (as it is in the logistic regression context) you can think of it statistically in the same way you would a covariate. That would suggest that $x_i$ would be a sensible notation choice, but it is a little misleading. From a scientific perspective exposure-response modelling treats exposure as a qualitatively different entity to the covariates, and within the Emax regression framework in particular exposure is structurally different to other covariates. As such it seems sensible to use a distinct symbol.] the observed exposure for the $i$-th subject, and letting $y_i$ denote the observed response, the Emax model for a continuous response is written as follows:\n\n$$\ny_i = E_0 + E_{max} \\frac{\\phi_i^\\gamma}{EC_{50}^\\gamma + \\phi_i^\\gamma} + \\epsilon_i \n$$\n\nwhere $\\epsilon_i \\sim \\mbox{Normal}(0, \\sigma^2)$ supplies the measurement model for the data set. The (nonlinear) predictor function in an Emax regression is described by four structural model parameters, as well as the residual variance $\\sigma^2$. The interpretation of the structural parameers are:\n\n- $E_0$ is represents the baseline response when drug exposure is zero. It is interpreted on the same scale as the response variable. Depending on what the response variable is, there might be constraints on what values are permitted (e.g., negative numbers might not make sense).\n- $E_{max}$ defines the maximum change from baseline as the drug exposure increases. In some contexts we expect this value to be positive, but in others we might be expecting the drug to inhibit a response in which case a negative value would be appropriate. Again, the parameter lies on the same scale as the response. \n- $EC_{50}$ defines the exposure at which the change from baseline is 50% of the maximum. It lies on the same scale as the exposure, and inherits the same restrictions that apply to the exposure (e.g., negative exposure makes no sense).\n- $\\gamma$ is the Hill coefficient, and describes the steepness of the response curve. In the regular version of the Emax model (sometimes called the \"hyperbolic\" Emax model) we fix $\\gamma = 1$, and for the purposes of this post I'll make this restriction rather than use the full \"sigmoidal\" Emax model: you can see worked examples using the full model in the BayesERbook. To my knowledge there isn't really a natural scale on which to interpret this parameter, though I'm told it can sometimes make sense in terms of [cooperative binding](/2024-01-09_emax-models/#interpreting-the-hill-coefficient). Honestly most of the time I think of it as \"steepness\" and leave it at that. \n\nThe Emax regression framework also supports binary response data (e.g., adverse events in an exposure-safety analysis). At the risk of being even more tedious than usual by writing down that which seems obvious, and letting $p_i = \\mbox{Pr}(y_i = 1)$ be the probability of an event, we typically have\n\n$$\n\\mbox{logit}(p_i) = E_0 + E_{max} \\frac{\\phi_i^\\gamma}{EC_{50}^\\gamma + \\phi_i^\\gamma} \n$$\n\nwhere $\\mbox{logit}(p_i) = \\ln (p_i/(1-p_i))$. I won't focus much on this version of the model in this blog post but it is not difficult to specify this version within brms, and anyway there are some examples using binary Emax regression in the book so you can go look at those if it's deeply important to you I guess?\n\n\n![\"we used up all the perfect\"](./img/june_21_2137.jpg)\n\n## Data\n\nNow that we have dispensed with the tiresome notation part, we'll need some data to work with. As I mentioned in [an earlier blog post](/posts/2024-11-11_emax-parameters/), simulating semi-plausible data sets for exposure-response analysis isn't trivial when you don't have a properly specified pharmacokinetic (PK) model under the hood, but if we make a few simplifying assumptions we can produce something that seems reasonable. Rather than waste all our time repeating material from an earlier post, I'll simply note that the framework I put together in that post is (more or less) exactly the one I used to generate the `d_sim_emax` data set that comes with the BayesERtools package. So, let's just load that data here yes?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"d_sim_emax\", package = \"BayesERtools\")\nd_sim_emax\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 300 Ã— 9\n    dose exposure response_1 response_2 cnt_a cnt_b cnt_c bin_d bin_e\n   <dbl>    <dbl>      <dbl>      <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1   100    4151.       12.8          1  5.71  2.33  7.83     0     1\n 2   100    8067.       14.6          1  4.92  4.66  6.74     1     1\n 3   100    4878.       12.8          1  4.88  4.21  4.68     1     1\n 4   100    9713.       16.6          1  8.42  6.56  1.29     0     1\n 5   100   11491.       14.4          0  4.37  3.96  3.55     0     1\n 6   100    2452.       12.6          1  8.69  7.60  3.64     0     0\n 7   100    5652.       14.8          1  6.61  3.95  5.13     0     0\n 8   100    9939.       15.2          1  5.35  7.77  8.29     0     1\n 9   100    5817.       14.6          0  5.61  2.24  9.60     0     1\n10   100    5176.       13.7          1  6.06  1.79  8.74     0     1\n# â„¹ 290 more rows\n```\n\n\n:::\n:::\n\n\n\nThe data set comes with an `exposure` variable, but does not supply units and is intentionally vague about what specific exposure metric it refers to. Similarly, there are two different outcome variables with generic names: the continuous-valued `response_1` and the binary-valued `response_2`. There are five covariates included, with equally unimaginitive names. The `cnt_a`, `cnt_b`, and `cnt_c` columns correspond to continuous covariates, while `bin_d` and `bin_e` are binary-valued. It is of course heavily simplified in comparison to a real world exposure-response data set, but that's the point: it's not meant to be realistic, it's meant to be convenient.\n\nIn any case, to give you a general sense of what the simulated data set looks like (at least, those parts most relevant to this post), here are some scatterplots depicting how the continuous response variable is related to exposure and to the three continuous covariates in the data set:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_sim_emax |> \n  pivot_longer(\n    cols = c(exposure, cnt_a, cnt_b, cnt_c), \n    names_to = \"variable\",\n    values_to = \"value\"\n  ) |> \n  ggplot(aes(value, response_1)) + \n  geom_point() + \n  geom_smooth(formula = y ~ x, method = \"loess\") + \n  facet_wrap(~ variable, scales = \"free_x\") + \n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-continuous-response-1.png){width=768}\n:::\n:::\n\n\n\nAt a quick glance it's clear that `exposure` is related to `response_1` (as one would hope), but it also seems clear that the response is related to `cnt_a`. Some modelling will be required to disentangle these effects.\n\n![\"rothko in ggplot2\"](./img/june_18_1808.jpg)\n\n![\"burn-in samples\"](./img/june_12_1236.jpg)\n\n\n## Simple Emax regression\n\nLike anyone in Bayes-land who hasn't been living under a rock, I've followed Paul BÃ¼rkner's fabulous work on brms with interest for many years, but it is only in my new life as a pharmacometrician that I've found an excuse to put it to good use.^[This might seem odd given that in my former professional life I was an [academic mathematical psychologist](https://papers.djnavarro.net/), and brms is well-equipped to handle classic psychometric tools like IRT models and math psych models like Weiner diffusion, but my specific field of work tended to force me to run head-first into the nightmare of [latent discrete parameters](https://mc-stan.org/docs/stan-users-guide/latent-discrete.html), which limited the usefulness of stan for me. Happily for me, this is rarely an issue in pharmacometrics, so I have now joined the Church of the No U-Turn Sampler and offer up my daily prayers to Our Lady of the Hamiltonian Monte Carlo like all the other Bayesian girls.] I am very excited about this. In the first instance, I'll ignore the covariates and focus only on the relationship between `exposure` and `response_1`. To build an Emax regression model within brms we have to define three components: the **model specification**, the **measurement model**, and the **parameter priors**. I'll discuss each of these in turn.\n\n### Model specification\n\nThe first step in the model building process is describing the nonlinear predictor function. We do this in brms using the `brmsformula()` function, or just `bf()` if we want to use the shorthand:^[My personal preference is to use `brmsformula()`. In general I prefer informative function names, even if they require a few extra keystrokes. Among other things, it helps me remember that `bf()` does not stand for [\"Bayes factor\"](/posts/2023-04-12_bayes-factors/), nor does it stand for \"boyfriend\". I have far too much trauma around both of these topics, and as much as I'm trying to repent my sins, my therapist isn't very well versed in statistical model selection and has not been particularly helpful in that arena.]\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_model <- brmsformula(\n  response_1 ~ e0 + emax * exposure / (ec50 + exposure),\n  e0 ~ 1,\n  emax ~ 1,\n  ec50 ~ 1,\n  nl = TRUE\n) \n```\n:::\n\n\n\nThere are a few important things to note here. \n\n- First, notice that we've set `nl = TRUE`. This is important because the syntax for a nonlinear model formula is qualitatively different to the syntax for a linear model formula. For linear models, we use the compact syntax where the model parameters (i.e., the regression coefficients) are *implicit*, like `y ~ x1 + x2` corresponds to the regression model $y_i = b_0 + b_1 x_1 + b_2 x_2$. For nonlinear models, this approach won't work because brms has no way to know the form of the model. So we have to be *explicit* and include the parameters (in this case `e0`, `emax`, and `ec50`) in the model formula.\n\n- Second, note that I explicitly included formulas `e0 ~ 1`, `emax ~ 1`, and `ec50 ~ 1` in the model specification. This serves two purposes. First, it tells brms that `e0`, `emax` and `ec50` should be interpreted as model parameters (and brms will expect a prior for these parameters), whereas `exposure` should be treated as a predictor (brms will look for it in the data set).\n\n- Third, be aware that the formula notation like `e0 ~ 1` is not arbitrary. In this particular model, `e0` will be treated like an \"intercept\" parameter: it's a single parameter and doesn't have a covariate model or any random effects attached to it. I'll come back to this later, but for now let's just be aware of this because you'll see this pop up in the output later.\n\nOkay, let's get back on track. \n\n### Measurement model\n\nThe second step is specifying the error model and link function. In an Emax regression with continuous response variables such as `response_1` in our data set, we typically adopt the same approach we would do in an ordinary linear regression, and assume that measurement errors are normally distributed with an identity link:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngaussian_measurement <- brmsfamily(\n  family = \"gaussian\", \n  link = \"identity\"\n)\n```\n:::\n\n\n\nIf we were analysing the binary outcome `response_2`, we would typically specify a Bernoulli distribution with logit-link:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbernoulli_measurement <- brmsfamily(\n  family = \"bernoulli\", \n  link = \"logit\"\n)\n```\n:::\n\n\n\n### Parameter priors\n\nFinally we need to specify priors. By default brms places an improper flat prior over regression parameters, but that's not usually the best approach and (at least in my experience) can misbehave when you have a nonlinear model such as Emax.^[I discussed this in an [earlier blog post](/posts/2024-11-11_emax-parameters/). The structure of an Emax model more or less guarantees that if you don't have strong information provided either by the data or the priors, you'll run into some unpleasant model identifability issues. For this post I'll be supplying mildly informative priors and using data sets that are moderately informative, so we won't run into the pathological cases I constructed in that post, but it is still important to be mindful of this as an issue.] In addition, since the `e0` and `emax` variables are interpreted on the same scale as `response_1`, and `ec50` is interpreted on the same scale as `exposure`, it's usually possible to set informed priors that make sense for the experimental design (e.g., if you've already built a PK model you have a good sense of the range of possible exposures, and that in turn tells you something about the plausible range for your EC50 parameter). Anyway, here's a prior that is pretty conservative but not unreasonable for this design (e.g., I'm allowing for an exposure-response relationship but not specifying the direction in advance), but rules out nonsense parameters (e.g., you really shouldn't have negative EC50 values):^[Okay yes, I have not manually specified the prior for the error variance $\\sigma^2$. Feel free to inspect the Stan code to see how brms handles that.]\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparameter_prior <- c(\n  prior(normal(0, 5), nlpar = \"e0\"),\n  prior(normal(0, 5), nlpar = \"emax\"),\n  prior(normal(2000, 500), nlpar = \"ec50\", lb = 0)\n)\n```\n:::\n\n\n\n\n### Fitting the model\n\nNow that we have all three components we are ready to go. It's possible to use `make_stancode()` to inspect the Stan code that brms generates, and you can take a look at it here if you want to get a sense of what the \"brms to stan\" translation does, but I'll admit it's not always very pretty:\n\n::: {.callout-caution collapse=\"true\" appearance=\"minimal\" title=\"Click to see the Stan code\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_stancode(\n  formula = base_model, \n  family = gaussian_measurement, \n  data = d_sim_emax, \n  prior = parameter_prior\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n// generated with brms 2.22.0\nfunctions {\n}\ndata {\n  int<lower=1> N;  // total number of observations\n  vector[N] Y;  // response variable\n  int<lower=1> K_e0;  // number of population-level effects\n  matrix[N, K_e0] X_e0;  // population-level design matrix\n  int<lower=1> K_emax;  // number of population-level effects\n  matrix[N, K_emax] X_emax;  // population-level design matrix\n  int<lower=1> K_ec50;  // number of population-level effects\n  matrix[N, K_ec50] X_ec50;  // population-level design matrix\n  // covariates for non-linear functions\n  vector[N] C_1;\n  int prior_only;  // should the likelihood be ignored?\n}\ntransformed data {\n}\nparameters {\n  vector[K_e0] b_e0;  // regression coefficients\n  vector[K_emax] b_emax;  // regression coefficients\n  vector<lower=0>[K_ec50] b_ec50;  // regression coefficients\n  real<lower=0> sigma;  // dispersion parameter\n}\ntransformed parameters {\n  real lprior = 0;  // prior contributions to the log posterior\n  lprior += normal_lpdf(b_e0 | 0, 5);\n  lprior += normal_lpdf(b_emax | 0, 5);\n  lprior += normal_lpdf(b_ec50 | 2000, 500)\n    - 1 * normal_lccdf(0 | 2000, 500);\n  lprior += student_t_lpdf(sigma | 3, 0, 2.5)\n    - 1 * student_t_lccdf(0 | 3, 0, 2.5);\n}\nmodel {\n  // likelihood including constants\n  if (!prior_only) {\n    // initialize linear predictor term\n    vector[N] nlp_e0 = rep_vector(0.0, N);\n    // initialize linear predictor term\n    vector[N] nlp_emax = rep_vector(0.0, N);\n    // initialize linear predictor term\n    vector[N] nlp_ec50 = rep_vector(0.0, N);\n    // initialize non-linear predictor term\n    vector[N] mu;\n    nlp_e0 += X_e0 * b_e0;\n    nlp_emax += X_emax * b_emax;\n    nlp_ec50 += X_ec50 * b_ec50;\n    for (n in 1:N) {\n      // compute non-linear predictor values\n      mu[n] = (nlp_e0[n] + nlp_emax[n] * C_1[n] / (nlp_ec50[n] + C_1[n]));\n    }\n    target += normal_lpdf(Y | mu, sigma);\n  }\n  // priors including constants\n  target += lprior;\n}\ngenerated quantities {\n}\n```\n\n\n:::\n:::\n\n\n\n:::\n\nMore important for our current purposes we can fit the model by calling `brm()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontinuous_base_fit <- brm(\n  formula = base_model, \n  family = gaussian_measurement, \n  data = d_sim_emax, \n  prior = parameter_prior\n) \n```\n:::\n\n\n\nPrint the output:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontinuous_base_fit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Family: gaussian \n  Links: mu = identity; sigma = identity \nFormula: response_1 ~ e0 + emax * exposure/(ec50 + exposure) \n         e0 ~ 1\n         emax ~ 1\n         ec50 ~ 1\n   Data: d_sim_emax (Number of observations: 300) \n  Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 4000\n\nRegression Coefficients:\n               Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\ne0_Intercept       5.02      1.23     2.28     7.11 1.00      779     1060\nemax_Intercept    11.92      1.21     9.79    14.54 1.00      824     1097\nec50_Intercept  2398.14    394.72  1662.63  3202.76 1.00      871     1214\n\nFurther Distributional Parameters:\n      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma     1.27      0.05     1.17     1.38 1.00     1520     1453\n\nDraws were sampled using sample(hmc). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n\n\n:::\n:::\n\n\n\nExtract model predictions:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontinuous_base_epred <- continuous_base_fit |> \n  epred_draws(newdata = tibble(exposure = seq(0, 50000, 1000))) |> \n  ungroup() |> \n  summarize(response_1 = mean(.epred), .by = exposure)\n\ncontinuous_base_epred\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 51 Ã— 2\n   exposure response_1\n      <dbl>      <dbl>\n 1        0       5.02\n 2     1000       8.61\n 3     2000      10.5 \n 4     3000      11.7 \n 5     4000      12.5 \n 6     5000      13.1 \n 7     6000      13.6 \n 8     7000      13.9 \n 9     8000      14.2 \n10     9000      14.5 \n# â„¹ 41 more rows\n```\n\n\n:::\n:::\n\n\n\nPlot:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(mapping = aes(exposure, response_1)) + \n  geom_path(data = continuous_base_epred) + \n  geom_point(data = d_sim_emax) + \n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-continuous-emax-model-predictions-1.png){width=672}\n:::\n:::\n\n\n\n\n![\"mechanised loom\"](./img/june_04_0462.jpg)\n\n## Adding covariates\n\nWe can adapt the exposure-response curve in the last example to illustrate why the simple emax regression model `base_model` is inadequate. If we shade the data points by the value of `cov_a` it is clear that the effect of this covariate has not been properly accounted for in the model:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(mapping = aes(exposure, response_1)) + \n  geom_path(data = continuous_base_epred) + \n  geom_point(mapping = aes(color = cnt_a), data = d_sim_emax) + \n  scale_color_distiller(palette = \"PuOr\", limits = c(0, 10)) + \n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/show-continuous-residuals-1.png){width=672}\n:::\n:::\n\n\n\nClearly we need an extended model.\n\n### Formalism revisited\n\nTo include covariates in the model we need to revisit the notation at the start of the post, and extend it in a way that allows us to represent the effect of covariates $\\mathbf{X} = [x_{ik}]$. In the most common case, covariates are included as additional linear terms, which gives us this as our extended Emax model:\n\n$$\ny_i = E_0 + E_{max} \\frac{\\phi_i^\\gamma}{EC_{50}^\\gamma + \\phi_i^\\gamma} + \\sum_k b_k x_{ik} + \\epsilon_i \n$$\n\nIf we were to translate this formula literally in the call to `brmsformula()` the model specification would look like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfull_model <- brmsformula(\n  response_1 ~ e0 + emax * exposure / (ec50 + exposure) + \n    a * cnt_a + b * cnt_b + c * cnt_c,\n  e0 ~ 1,\n  emax ~ 1,\n  ec50 ~ 1,\n  a ~ 1, \n  b ~ 1,\n  c ~ 1,\n  nl = TRUE\n)\n```\n:::\n\n\n\nA model written this way would work just fine but it is a little inelegant, and we can do better than this. Earlier in the post I mentioned that the recommended way to think about nonlinear \"parameters\" in brms is to think of them as \"placeholders\". This is the point at which that becomes relevant. We can write a more general formulation of Emax regression with covariates like this:\n\n$$\ny_i = f_1(X_i) + f_2(X_i) \\frac{\\phi_i^{f_4(X)}}{f_3(X_i) ^ {f_4(X_i)} + \\phi_i ^ {f_4(X_i)}} + \\epsilon_i\n$$\nwhere each of the functions $f_1$, $f_2$, $f_3$ and $f_4$ describe a linear predictor, $X_i$ denotes the covariate vector for the $i$-th subject, and for simplicity the dependence on regression coefficients is suppressed in the notation. When we specify an emax model without covariates all four of these functions correspond to \"intercept-only\" models and are constant with respect to $X_i$:\n\n$$\n\\begin{array}{rcl}\nf_1(X_i) &=& E_0 \\\\\nf_2(X_i) &=& E_{max} \\\\\nf_3(X_i) &=& EC_{50} \\\\\nf_4(X_i) &=& \\gamma\n\\end{array}\n$$\n\nIf we fix $\\gamma = 1$ we can drop $f_4$ entirely:\n\n$$\ny_i = f_1(X_i) + f_2(X_i) \\frac{\\phi_i}{f_3(X_i) + \\phi_i} + \\epsilon_i\n$$\n\nIn principle we could specify a covariate model for any of these functions, but in the typical case we would do so only for $f_1$. Letting $b_k$ denote the regression coefficient for the $k$-th covariate:\n\n$$\n\\begin{array}{rcl}\nf_1(X_i) &=& E_0 + \\sum_k b_k x_{ik} \\\\\nf_2(X_i) &=& E_{max} \\\\\nf_3(X_i) &=& EC_{50}\n\\end{array}\n$$\nOr, if we wrote this in the \"classical\" R formula style where, it would look something like this:\n\n```r\ne0 ~ 1 + x1 + x2 + ...\nemax ~ 1\nec50 ~ 1\n```\n\nOh hey, that's how it works in brms. The first line in the model formula defines Emax as a structural model, and subsequent lines specify covariate models for each of the Emax components:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfull_model <- brmsformula(\n  response_1 ~ e0 + emax * exposure / (ec50 + exposure), # structural model\n  e0   ~ 1 + cnt_a + cnt_b + cnt_c, # covariate model for baseline\n  emax ~ 1,                         # covariate model for max response\n  ec50 ~ 1,                         # covariate model for EC50\n  nl = TRUE\n)\n```\n:::\n\n\n\nHaving done so, the prior specification looks like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparameter_prior <- c(\n  prior(normal(0, 5), nlpar = \"e0\"),\n  prior(normal(0, 5), nlpar = \"emax\"),\n  prior(normal(2000, 500), nlpar = \"ec50\", lb = 0)\n)\n```\n:::\n\n\n\nAlthough this specification of `parameter_prior` is identical to the one I wrote down earlier, it's worth noting that brms interprets this prior slightly differently in the context of the two models. In `base_model` there is only one `e0` parameter (the intercept) over which the normal prior is specified. In contrast, `full_model` has four parameters (intercept plus three coefficients), and each of those four terms is supplied with its own normal prior. In other words, the specification `prior(normal(0, 5), nlpar = \"e0\")` is interpreted as a prior to be applied across all parameters in the `e0` part of the structural model. You can see this if you look closely at the Stan code, which is tucked below the fold here, but it's not the most thrilling read so let's move on, shall we?\n\n::: {.callout-caution collapse=\"true\" appearance=\"minimal\" title=\"Click to see the Stan code\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_stancode(\n  formula = full_model, \n  family = gaussian_measurement, \n  data = d_sim_emax, \n  prior = parameter_prior\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n// generated with brms 2.22.0\nfunctions {\n}\ndata {\n  int<lower=1> N;  // total number of observations\n  vector[N] Y;  // response variable\n  int<lower=1> K_e0;  // number of population-level effects\n  matrix[N, K_e0] X_e0;  // population-level design matrix\n  int<lower=1> K_emax;  // number of population-level effects\n  matrix[N, K_emax] X_emax;  // population-level design matrix\n  int<lower=1> K_ec50;  // number of population-level effects\n  matrix[N, K_ec50] X_ec50;  // population-level design matrix\n  // covariates for non-linear functions\n  vector[N] C_1;\n  int prior_only;  // should the likelihood be ignored?\n}\ntransformed data {\n}\nparameters {\n  vector[K_e0] b_e0;  // regression coefficients\n  vector[K_emax] b_emax;  // regression coefficients\n  vector<lower=0>[K_ec50] b_ec50;  // regression coefficients\n  real<lower=0> sigma;  // dispersion parameter\n}\ntransformed parameters {\n  real lprior = 0;  // prior contributions to the log posterior\n  lprior += normal_lpdf(b_e0 | 0, 5);\n  lprior += normal_lpdf(b_emax | 0, 5);\n  lprior += normal_lpdf(b_ec50 | 2000, 500)\n    - 1 * normal_lccdf(0 | 2000, 500);\n  lprior += student_t_lpdf(sigma | 3, 0, 2.5)\n    - 1 * student_t_lccdf(0 | 3, 0, 2.5);\n}\nmodel {\n  // likelihood including constants\n  if (!prior_only) {\n    // initialize linear predictor term\n    vector[N] nlp_e0 = rep_vector(0.0, N);\n    // initialize linear predictor term\n    vector[N] nlp_emax = rep_vector(0.0, N);\n    // initialize linear predictor term\n    vector[N] nlp_ec50 = rep_vector(0.0, N);\n    // initialize non-linear predictor term\n    vector[N] mu;\n    nlp_e0 += X_e0 * b_e0;\n    nlp_emax += X_emax * b_emax;\n    nlp_ec50 += X_ec50 * b_ec50;\n    for (n in 1:N) {\n      // compute non-linear predictor values\n      mu[n] = (nlp_e0[n] + nlp_emax[n] * C_1[n] / (nlp_ec50[n] + C_1[n]));\n    }\n    target += normal_lpdf(Y | mu, sigma);\n  }\n  // priors including constants\n  target += lprior;\n}\ngenerated quantities {\n}\n```\n\n\n:::\n:::\n\n\n\n:::\n\n### Fitting the model\n\nNow that the model is full specified we can call `brm()` and estimate model parameters:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontinuous_full_fit <- brm(\n  formula = full_model, \n  family = gaussian_measurement, \n  data = d_sim_emax, \n  prior = parameter_prior\n) \n```\n:::\n\n\n\nHere they are:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontinuous_full_fit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Family: gaussian \n  Links: mu = identity; sigma = identity \nFormula: response_1 ~ e0 + emax * exposure/(ec50 + exposure) \n         e0 ~ 1 + cnt_a + cnt_b + cnt_c\n         emax ~ 1\n         ec50 ~ 1\n   Data: d_sim_emax (Number of observations: 300) \n  Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 4000\n\nRegression Coefficients:\n               Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\ne0_Intercept       3.47      0.63     2.10     4.57 1.00     1042     1412\ne0_cnt_a           0.51      0.01     0.49     0.54 1.00     3499     2725\ne0_cnt_b          -0.01      0.01    -0.04     0.01 1.00     3533     2706\ne0_cnt_c          -0.00      0.01    -0.03     0.02 1.00     3918     2689\nemax_Intercept    11.34      0.56    10.34    12.57 1.00     1152     1560\nec50_Intercept  2997.86    321.22  2390.23  3636.36 1.00     1081     1499\n\nFurther Distributional Parameters:\n      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma     0.50      0.02     0.46     0.54 1.00     2846     1813\n\nDraws were sampled using sample(hmc). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n\n\n:::\n:::\n\n\n\n![\"cottage whore\"](./img/june_20_2000.jpg)\n\n\n## Model comparison\n\nThe brms package provides a flexible interface for model comparison using LOO-CV and WAIC, using the [loo](http://mc-stan.org/loo/) package under the hood to do the work. Because the interface is flexible there are several ways to write the code: the approach below is my preferred way to do it. First, we use `add_criterion()` to run the LOO-CV procedure, and store the results internally within the brmsfit object:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontinuous_full_fit <- add_criterion(continuous_full_fit, \"loo\")\ncontinuous_base_fit <- add_criterion(continuous_base_fit, \"loo\")\n```\n:::\n\n\n\nYou can extract the stored result like this if you need to use it for some other purpose:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontinuous_full_fit$criteria$loo\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nComputed from 4000 by 300 log-likelihood matrix.\n\n         Estimate   SE\nelpd_loo   -219.0 13.4\np_loo         6.7  0.8\nlooic       438.0 26.8\n------\nMCSE of elpd_loo is 0.0.\nMCSE and ESS estimates assume MCMC draws (r_eff in [0.4, 1.1]).\n\nAll Pareto k estimates are good (k < 0.7).\nSee help('pareto-k-diagnostic') for details.\n```\n\n\n:::\n:::\n\n\n\nNow that we have the required samples stored within both model fit objects, we can call `loo_compare()` to perform the model comparison:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontinuous_loo_compare <- loo_compare(continuous_full_fit, continuous_base_fit)\ncontinuous_loo_compare\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                    elpd_diff se_diff\ncontinuous_full_fit    0.0       0.0 \ncontinuous_base_fit -280.1      15.5 \n```\n\n\n:::\n:::\n\n\n\nBy default the printed output only shows the most important columns, but the return value from `loo_compare()` is richer than this. It's an object of class \"compare.loo\", and if we call the print method with `simplify = FALSE` it will show all the columns:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(continuous_loo_compare, simplify = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                    elpd_diff se_diff elpd_loo se_elpd_loo p_loo  se_p_loo\ncontinuous_full_fit    0.0       0.0  -219.0     13.4         6.7    0.8  \ncontinuous_base_fit -280.1      15.5  -499.1     11.2         3.0    0.3  \n                    looic  se_looic\ncontinuous_full_fit  438.0   26.8  \ncontinuous_base_fit  998.2   22.5  \n```\n\n\n:::\n:::\n\n\n\n\n\n\n![\"all the mermaids have sharp teeth\"](./img/june_09_0907.jpg)\n\n## Cheerful oblivion\n\n\nEverything is harder than it looks. ",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}