{
  "hash": "914394ae04763fcea894236e7bbcb0fc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \" Bézier curve\"\ndescription: \"What sins will she commit?\"\ndate: \"2024-11-24\"\nimage: \"./img/worm3.jpg\"\nimage-alt: \"Worm on a string meme\"\ncategories: [\"R\", \"Art\", \"Worms\"]\n--- \n\n\n\n<!--------------- my typical setup ----------------->\n\n\n\n\n\n\n\n<!--------------- post begins here ----------------->\n\nIt has annoyed me for many years that I have used [Bézier curves](https://en.wikipedia.org/wiki/B%C3%A9zier_curve) without really understanding them. Consider, for example, the [flametree](https://github.com/djnavarro/flametree) package I wrote when first learning how to make generative art. \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntree <- flametree::flametree_grow(\n  seed = 100L,\n  time = 7L,\n  split = 3L,\n  trees = 1L\n)\n\nflametree::flametree_plot(\n  data = tree, \n  background = \"white\", \n  palette = \"black\",\n  style = \"nativeflora\" \n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){fig-align='center' width=576}\n:::\n:::\n\n\n\nSetting aside the details of the system, you can see that the branching shapes here are constructed from many curved lines connected to one another. Each segment is a distinct Bézier curve. If I'd not used Bézier curves and instead constructed the art using straight lines, these pieces would lose any sense of flowing growth.\n\nOr consider these images, all of which are outputs from something I hastily cobbled together this morning in a desperate effort to wake my brain from its weekend stupor:\n\n::: {layout-ncol=3}\n\n![](./img/sketches_06_0681.png)\n\n![](./img/sketches_06_0688.png)\n\n![](./img/sketches_06_0692.png)\n\n:::\n\nThe influence of Bézier curves is more subtle in these pieces, because each image is comprised of many distinct \"ribbon\" shapes that are described by rules I talked about in the [S7 post](/posts/2024-02-25_s7/), and their individual character isn't at all related to Bézier curves. But notice how, in all three pieces, there's tendency for all the ribbons to \"bend\" in the same (or similar) direction? This happens because under the hood I've replaced the straight lines that were used in the original system with Bézier curves. \n\nAnd let's not even get started on all the point-and-click GUI interfaces out there that let you create Bézier curves without writing a single line of code. Bézier curves are everywhere.\n\nNevertheless, until today I'd never thought to look into the mathematics. For some reason -- possibly because my idiot brain sometimes confuses Bézier functions with [Bessel functions](https://en.wikipedia.org/wiki/Bessel_function) -- I had this weird idea in my head that Bézier curves were complicated. \n\nThey are not.\n\n## Definition\n\nReduced to the bare essentials a Bézier curve is nothing special: it's just a polynomial function. More precisely, it's a special case of the [Bernstein polynomials](https://en.wikipedia.org/wiki/Bernstein_polynomial) \n\n$$\nB_n(t) \\sum_{v = 0}^n \\beta_v \\ b_{v,n}(t)\n$$\n\nwhere $\\beta_v$ describes the weight assigned to, $b_{v,n}(t)$, which denotes a Bernstein basis polynomial:\n\n$$\nb_{v,n}(t) = \\frac{n!}{(n - v)!v!} \\ t^v (1-t)^{n-v}\n$$\nLooking at this expression, every data-minded person will immediately recognise that $n!/((n - v)!v!)$ is the [binomial coefficient](https://en.wikipedia.org/wiki/Binomial_coefficient), and indeed that for $t \\in [0, 1]$, a Bernstein basis polynomial is no different mathematically to the expression for the binomial probability of observing $v$ events out of $n$ trials when the probability of a single event is $t$. \n\nNone of this is very interesting.\n\nBut suppose we have a collection of $n + 1$ control points $P_0, \\ldots, P_n$ that lie in a coordinate space. In a Bézier curve, these control points are analogous the $\\beta_v$ coefficients in a Bernstein polynomial, and (by definition) we restrict the domain of the function to the unit interval $t \\in [0, 1]$\n\n$$\nB_n(t) = \\sum_{v = 0}^n P_v \\frac{n!}{(n - v)!v!} \\ t^v (1-t)^{n-v}\n$$\nand we have the general form of the equation for a Bézier curve defined by these control points. A Bézier curve *is* a Bernstein polynomial, and as such you can think of a Bézier curve as being a particular kind of weighted average of the control points, where the weight assigned to the $v$-th of the $n$ control points is identical to the binomial probability of $v$ successes from $n$ trials, if the probability of a single success is $t$, where $t$ refers to the proportion distance along the curve that you have travelled. Admittedly, this \"explanation\" doesn't help very much in itself, but it did motivate me to construct a little gif that shows how the \"weights\" assigned to each of the control points change as you sweep through the values of $t$:\n\n![](./img/weights-1.gif)\n\nIn this plot:\n\n- The line is the Bézier curve\n- The coloured dots are the control points \n- The black dot is the value of the Bézier curve $B_n(t)$ at the current value of $t$ \n- The colour of the Bézier curve at each point represents the value of $t$\n- The colour of the control points is proportional to its numerical index (i.e., the colour of the first control point, where $v = 0$, is mapped to the same colour as $t = 0$; and similarly, the colour of the final control point where $v = n$ is the same as the colour of the Bézier curve when $t = 1$)\n- The label denotes the actual index of the control points (i.e., $v + 1$)\n- The area of the control point dots is proportional to the weight $b_{n,v}(t)$ assigned to the that control point: i.e., it represents the \"pull\" that this control point has when determining the location of the black dot \n\nThis is still not very interesting. \n\nEven so, making this connection also helped me realise (at long last) that the *order* of the control points matters a lot to the shape of the curve. The curve will always pass through the first and last of the control points, but it won't necessarily go through any of the intermediate points. Not only that, if you change the order in which the intermediate control points are specified, you change the curve, even if the locations of those control points don't change. Here's what happens to the previous example if I switch the order of two intermediate control points (i.e., notice the colours of those two points have swapped): \n\n![](./img/weights-2.gif)\n\n::: {.column-margin}\n\n![](./img/worm1.jpg)\n\n:::\n\nSigh.\n\n## Implementation\n\nFrom a practical perspective there is no need to roll our own implementation of Bézier functions in R, because this has already been done many times before. Nevertheless -- since the whole point of this post is to unpack how Bézier functions work -- I'll do so here for illustrative purposes. To that end, I'll start by implementing my own `bernstein()` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbernstein <- function(beta, t = seq(0, 1, .01)) {\n  n <- length(beta) - 1\n  w <- choose(n, 0:n)\n  b <- rep(0, length(t))\n  for(v in 0:n) {\n    b = b + beta[v + 1] * w[v + 1] * t^v * (1 - t)^(n-v)\n  }\n  b\n}\n```\n:::\n\n\n\nArmed with a function that computes Bernstein polynomials, it's very straightforward to construct Bézier curves and add them to plots. First, let's load some packages:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(tibble)\n```\n:::\n\n\n\nNext, I'll define a set of `control` points as a tibble that stores the `x` and `y` coordinates of the control points as separate columns:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontrol <- tibble(\n  x = c(1, 5, 8),\n  y = c(1, 1, 6)\n)\n```\n:::\n\n\n\nI can now define a `bezier` curve by computing two `bernstein()` polynomials, one associated with the x-coordinates and the other associated with the y-coordinates:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbezier <- tibble(\n  t = seq(0, 1, .01),\n  x = bernstein(control$x, t),\n  y = bernstein(control$y, t)\n)\n```\n:::\n\n\n\nBetter yet, I can plot them:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  aes(x, y) +\n  geom_path(data = bezier) + \n  geom_point(data = control, color = \"red\") + \n  coord_equal(xlim = c(0, 10), ylim = c(0, 10)) + \n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\nIn this example there are only three control points, and if I'm honest I'll admit that when I use Bézier curves in art I've only ever used curves with three control points, but there's no principled reason for that restriction. Indeed, adding more control points can change the shape of the curve in interesting ways:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontrol <- tibble(\n  x = c(1, 5, 6, 7, 8),\n  y = c(1, 1, 9, 8, 6)\n)\nbezier <- tibble(\n  t = seq(0, 1, .01),\n  x = bernstein(control$x, t),\n  y = bernstein(control$y, t)\n)\nggplot() + \n  aes(x, y) +\n  geom_path(data = bezier) + \n  geom_point(data = control, color = \"red\") + \n  coord_equal(xlim = c(0, 10), ylim = c(0, 10)) + \n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\nNo, sorry, I lied. Still not interesting.\n\n::: {.column-margin}\n\n![](./img/worm2.jpg)\n\n:::\n\n\n## S7 bezier classes, why not\n\nIn order to play around with this a little further, and given that I mentioned the [S7 post](/posts/2024-02-25_s7/) earlier, I'll practice my S7 skills a little by defining a new \"bezier\" class:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(S7)\n\nbezier <- new_class(\n  name = \"bezier\",\n  parent = S7_object,\n  properties = list(\n    x = class_numeric,\n    y = class_numeric,\n    n = new_property(class = class_numeric, default = 100L),\n    curve = new_property(\n      class = class_data.frame,\n      getter = function(self) {\n        t <- seq(0, 1, length.out = self@n)\n        data.frame(\n          x = bernstein(self@x, t),\n          y = bernstein(self@y, t)\n        )\n      }\n    )\n  ),\n  validator = function(self) {\n    if (length(self@x) != length(self@y)) return(\"x and y must have same length\")\n    if (length(self@x) < 2) return(\"at least two control points are required\")\n    if (length(self@n) != 1) return(\"n must be length 1\")\n    if (self@n <= 0) return(\"n must be a non-negative number\")\n  })\n```\n:::\n\n\n\nI call `bezier()` by passing the `x` and `y` coordinates of the control points, like so:   \n  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nb <- bezier(\n  x = c(1, 5, 6, 7, 8),\n  y = c(1, 1, 9, 8, 6)\n)\n```\n:::\n\n\n\nThe result is a data structure that stores points defining the Bézier curve as an internal data frame `b@curve`, and also keeps the control points as `b@x` and `b@y`. This is probably not a great class design, but whatever. In any case, here's the object:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<bezier>\n @ x    : num [1:5] 1 5 6 7 8\n @ y    : num [1:5] 1 1 9 8 6\n @ n    : int 100\n @ curve:'data.frame':\t100 obs. of  2 variables:\n .. $ x: num  1 1.16 1.32 1.47 1.62 ...\n .. $ y: num  1 1 1.02 1.04 1.07 ...\n```\n\n\n:::\n:::\n\n\n\nThis data structure is not very interesting. \n\nWe can make this a little less tedious by noting that every S7 class is also an S3 class, which allows me to define an S3 plot method:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot.bezier <- function(x, show_control = TRUE, ...) {\n  p <- ggplot() + \n    aes(x, y) +\n    geom_path(data = x@curve) + \n    coord_equal() + \n    theme_bw()\n  if (show_control) {\n    p <- p + geom_point(\n      data = data.frame(x = x@x, y = x@y), \n      color = \"red\"\n    ) \n  }\n  p\n}\n\nplot(b)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\nI guess that's nice? Sort of?\n\nAnyway, if we really wanted to we could push this a little further. For examples, we could define a \"bezier_noise\" class where objects are comprised of many Bézier curves, in which random noise is injected into some of the control points. I'll spare you the terrible, horrible, no good, very bad code that I used to define this class. Instead I'll just plot a whole bunch of Bézier curves atop one another:\n\n::: {.column-margin}\n\n![](./img/worm3.jpg)\n\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"(The terrible, horrible, no good, very bad code)\"}\nbezier_noise <- new_class(\n  name = \"bezier_noise\",\n  parent = S7_object,\n  properties = list(\n    x = class_numeric,\n    y = class_numeric,\n    k = new_property(class = class_numeric, default = 100L),\n    n = new_property(class = class_numeric, default = 100L),\n    noise = new_property(class = class_numeric, default = 1),\n    seed = new_property(class = class_numeric, default = 1L),\n    bezier = new_property(\n      class = class_list, \n      getter = function(self) {\n        l <- list()\n        np <- length(self@x)\n        s <- seq(0, 2, length.out = np)\n        s <- s * (2 - s) \n        withr::with_seed(\n          self@seed, \n          {\n            for(i in 1:self@k) {\n              l[[i]] <- bezier(\n                x = self@x + rnorm(np, sd = self@noise) * s^2,\n                y = self@y + rnorm(np, sd = self@noise) * s^2,\n                n = self@n\n              )\n            }\n          }\n        )\n        l\n      }\n    )\n  ),\n  validator = function(self) {\n    if (length(self@x) != length(self@y)) return(\"x and y must have same length\")\n    if (length(self@x) < 2) return(\"at least two control points are required\")\n    if (length(self@n) != 1) return(\"n must be length 1\")\n    if (self@n <= 0) return(\"n must be a non-negative number\")\n    if (length(self@k) != 1) return(\"k must be length 1\")\n    if (self@k <= 1) return(\"k must be a positive number\")\n    if (length(self@noise) != 1) return(\"noise must be length 1\")\n    if (self@noise <= 0) return(\"noise must be a non-negative number\")\n    if (length(self@seed) != 1) return(\"seed must be length 1\")\n    if (self@seed <= 0) return(\"seed must be a non-negative number\")\n  })\n\nplot.bezier_noise <- function(x, palette = \"bilbao\", dots = TRUE, ...) {\n  p <- ggplot() + aes(x, y) + coord_equal() + theme_void()\n  pal <- scico::scico(x@k, palette = palette)\n  pal <- sample(pal)\n  if(dots) for(l in 1:x@k) p <- p + \n      geom_point(\n        data = data.frame(\n          x = x@bezier[[l]]@x,\n          y = x@bezier[[l]]@y\n        ),\n        color = \"grey80\",\n        size = 1,\n        shape = 19\n      )\n  for(l in 1:x@k) p <- p + \n      geom_path(\n        data = x@bezier[[l]]@curve,\n        color = pal[l],\n        lineend = \"round\"\n      )\n  p\n}\n\nplot(\n  bezier_noise(\n    x = c(0, 10, 15, 20, 25, 30, 35),\n    y = c(0,  0,  5, 15,  5,  5,  5),\n    k = 200L, \n    noise = 1.5 \n  ), \n  palette = \"lajolla\",\n  dots = TRUE\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\nOkay? But why, Danielle? Why?\n\n## What sins indeed\n\nNone of this may seem like a great life accomplishment. But this is only because you do not realise how close I am to writing an R package that generates worm on a string memes in ggplot2.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"(worm in a plot)\"}\nset.seed(1L)\nplot(\n  bezier_noise(\n    x = sort(rnorm(10L)),\n    y = rnorm(10L),\n    k = 200L, \n    noise = .1 \n  ),\n  palette = \"oslo\",\n  dots = FALSE\n) + \n  annotate(\n    \"point\", \n    x = c(.8, .85), \n    y = c(.7, .8), \n    size = 6, \n    shape = 19, \n    color = \"white\"\n  ) +\n  annotate(\n    \"point\", \n    x = c(.8, .85), \n    y = c(.7, .8), \n    size = 6, \n    shape = 1, \n    color = \"black\"\n  ) +\n  annotate(\n    \"point\", \n    x = c(.81, .86), \n    y = c(.7, .8), \n    size = 2, \n    shape = 19, \n    color = \"black\"\n  ) +\n  annotate(\n    \"label\",\n    x = .5,\n    y = .3,\n    size = 8,\n    label = \"🪱 i will subsett  closurs\"\n  ) +\n  annotate(\n    \"text\",\n    x = .2,\n    y = .9,\n    angle = 70,\n    size = 10,\n    color = \"pink\",\n    label = \"on purpse\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){fig-align='center' width=576}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}