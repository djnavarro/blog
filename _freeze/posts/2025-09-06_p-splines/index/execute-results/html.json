{
  "hash": "572acc9d24ee27567c033294d8334323",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"A short post about p-splines\"\ndescription: \"Yes, this is also secretly about GAMLSS regression\"\ndate: \"2025-09-06\"\ncategories: [\"statistics\", \"R\"]\nknitr:\n  opts_chunk: \n    dev.args:\n      bg: \"#00000000\"\n--- \n\n\n\n<!--------------- my typical setup ----------------->\n\n\n\n\n\n\n\n<!--------------- post begins here ----------------->\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(purrr)\nlibrary(tibble)\nlibrary(ggplot2)\n```\n:::\n\n\n\nThis is a post about penalised splines, and lets be brutally honest I do not care for penalised splines any more than I care for the [Box-Cox power exponential distribution](/posts/2025-08-02_box-cox-power-exponential/) that I wittered on about in the last post. I did not care about the BCPE then and I do not care about P-splines now. Unfortunately, in much the same way that I had to learn about the BCPE distribution in order to understand the [GAMLSS regression](https://en.wikipedia.org/wiki/Generalized_additive_model_for_location,_scale_and_shape) framework that I'm going to talk about in the [next post](/posts/2025-09-07_gamlss/), so much so that my BCPE notes became their own post, I have fallen prey to my own vices and again found myself through the looking glass, shaving an unhappy yak, and writing about a topic very different to the one I originally intended to. \n\nOh well.\n\n## Splines\n\nA [spline](https://en.wikipedia.org/wiki/Spline_(mathematics)) is just a piecewise polynomial, and for the sake of my sanity I'm only going to consider polynomials in a single variable $x$, and consider a spline function $f(x)$ defined over the interval $[a, b]$. To build the spline, we partition the interval $[a, b]$ into $m$ disjoint regions $r_1, r_2, \\ldots, r_m$, whose edges are defined by a vector of **knot** points $\\mathbf{k} = (k_0, k_1, \\ldots, k_m)$.^[Conventionally, the knot points are denoted $t$ but I think that's stupid and the number of knots uses $k$ as the notation but honestly I think that's stupid and just makes it harder to understand.] If we order the knot points such that $k_i \\leq k_{i+1}$ and set $k_0 = a$ and $k_m = b$, then the $i$-th region corresponds to the interval $[k_{i-1}, k_i]$ between two successive knots.^[I suppose if I were being nitpicky enough to define the partition properly I would be a bit more precise and use half-open intervals like $[k_{i-1}, k_i)$ and then make a special case for the final interval by making that one closed, i.e., $[k_{m-1}, k_m]$, but this isn't the kind of post where I'm going to be that technical, and frankly even if I tried I'd probably just fuck it up.] Given this partition we can then define a continuous spline function in terms of $m$ distinct polynomial functions $p_1(x), p_2(x), \\ldots p_m(x)$, one for each subinterval. Our spline function is just a fancy if-then rule. If the point $x$ lies within region $r_i$, use the polynomial $p_i(x)$:\n\n$$\nf(x) = \n\\left\\{\n\\begin{array}{rcl}\np_1(x) &\\mbox{if}& x \\in r_1 \\\\\np_2(x) &\\mbox{if}& x \\in r_2 \\\\\n\\ldots \\\\\np_k(x) &\\mbox{if}& x \\in r_k \\\\\n\\end{array}\n\\right.\n$$\n\nTo ensure that the resulting spline function $f(x)$ is continuous, the polynomials must be constrained so the polynomials on either side of the knot point have the same value at the knot point that connects them.^[To write it slightly more tediously in order to pretend that the author is smart, she notes that the constraint is that $p_i(k_i) = p_{i+1}(k_i)$ for $i = 1, 2, \\ldots m-1$. This adds precisely nothing of value to the post, of course. However, in deference to her undiagnosed-but-painfully-obvious autism she will dump it in a footnote and move on.] To help get a feel for how splines work, I wrote `piecewise()` function that takes knot vector and a list of functions as inputs, and returns the corresponding piecewise polynomial function `f`. The source for `piecewise()` isn't very interesting but for what it's worth it's hidden below the fold here:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Code for piecewise()\"}\npiecewise <- function(knots, funs) { \n  f <- function(x) {\n    k <- length(funs)\n    n <- length(x)\n    y <- rep(NA_real_, n)\n    r <- rep(NA_integer_, n)\n    for (i in 1:k) {\n      ind <- x >= knots[i] & x < knots[i + 1]\n      r[ind] <- i\n      y[ind] <- funs[[i]](x[ind])\n    }\n    ind <- x == knots[k + 1]\n    r[ind] <- k\n    y[ind] <- funs[[k]](x[ind])\n    attr(y, \"region\") <- r\n    y\n  }\n  attr(f, \"knots\") <- knots\n  attr(f, \"funs\") <- funs\n  return(f)\n}\n```\n:::\n\n\n\nIn my implementation the spline function is undefined outside the interval $[a, b]$ so the values outside the interval are always `NA`, but I suppose other choices could be made. It's not important: my `piecewise()` function isn't intended for serious use, it's just something I wrote so that I could play around with simple splines before moving into the world of pain that is B-splines and P-splines. Armed with this entirely uninteresting tool, let's consider the following example. At the risk of stretching the imagination beyond the limits of human capability, let's try to pretend that I am deeply interested in the following spline: \n\n$$\nf(x) = \n\\left\\{\n\\begin{array}{rcl}\n2x^2 - 3x + 2 & \\mbox{if} & x \\in [0, 1] \\\\\nx & \\mbox{if} & x \\in [1, 3] \\\\\n-x^3 + 28x - 54 &\\mbox{if} & x \\in [3, 3.5] \\\\\n\\end{array}\n\\right.\n$$\n\nIt is comprised of three polynomials of different [degree](https://en.wikipedia.org/wiki/Degree_of_a_polynomial): there's a linear function (degree 1), a quadratic function (degree 2), and a cubic function (degree 3). So the degree of our spline is at most 3. For reasons that escape me, if the maximum degree of any of the polynomial pieces is $d$, we say that the spline is of **order** $d+1$. So this is a spline of order 4. Again, thrilling. But let's suppose I want to implement this spline using my `piecewise()` function. All I need to do is this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- piecewise(\n  knots = c(0, 1, 3, 3.5),\n  funs = list(\n    \\(x) 2*x^2 - 3*x + 2, # left piece is quadratic\n    \\(x) x,               # middle piece is linear\n    \\(x) -x^3 + 28*x - 54 # right piece is cubic\n  )\n) \n```\n:::\n\n\n\nYay. To get a sense of what the function looks like I'll also define a `plot_piecewise()` function that plots the spline over the interval $[a, b]$, but it's really boring so I'm again going to hide the code behind the fold and jump straight to plotting the spline function `f`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Code for plot_piecewise()\"}\nplot_piecewise <- function(f, n = 5000L) {\n\n  lb <- min(attr(f, \"knots\"))\n  ub <- max(attr(f, \"knots\"))\n  x <- seq(lb, ub, length.out = n)\n\n  dat_sp <- tibble(\n    x = x, \n    y = f(x),\n    r = factor(attr(y, \"region\"))\n  )\n\n  dat_pn <- attr(f, \"funs\") |> \n    map(\\(p) tibble(x = x, y = p(x))) |> \n    bind_rows(.id = \"r\") |> \n    mutate(r = factor(r))\n\n  dat_kn <- tibble(\n    x = attr(f, \"knots\"),\n    y = f(x)\n  )\n\n  plt <- ggplot() +\n    geom_path(data = dat_sp, aes(x, y, color = r), linewidth = 5, alpha = .25) + \n    geom_path(data = dat_pn, aes(x, y, color = r)) +\n    geom_path(data = dat_sp, aes(x, y, group = r), linewidth = 1) + \n    geom_point(data = dat_kn, mapping = aes(x, y), size = 3) + \n    labs(x = \"x\", y = \"f(x)\", color = \"polynomial\")\n\n  return(plt)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_piecewise(f) + lims(y = c(0, 4))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/piecewise-0-1.png){width=672}\n:::\n:::\n\n\n\nFirst derivatives are continuous:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf_deriv1 <- piecewise(\n  knots = c(0, 1, 3, 3.5),\n  funs = list(\n    \\(x) 4*x - 3,       # 1st derivative of left piece\n    \\(x) 1,             # 1st derivative of middle piece \n    \\(x) -3 * x^2 + 28  # 1st derivative of right piece\n  )\n)\nplot_piecewise(f_deriv1) + lims(y = c(-10, 2))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/piecewise-1-1.png){width=672}\n:::\n:::\n\n\n\nSecond derivatives are not:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf_deriv2 <- piecewise(\n  knots = c(0, 1, 3, 3.5),\n  funs = list(\n    \\(x) 4,      # 2nd derivative of left piece\n    \\(x) 0,      # 2nd derivative of middle piece\n    \\(x) -6 * x  # 2nd derivative of right piece\n  )\n)\nplot_piecewise(f_deriv2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/piecewise-2-1.png){width=672}\n:::\n:::\n\n\n\nTo put it in slightly fancier language, since the 0th derivative (the function) and 1st derivative are continuous everywhere we say that our example spline has **smoothness 1 everywhere**. However, because the 2nd derivatives are discontinuous at the knot points, the spline does not have smoothness 2 at the knots. More generally, for the spline to have [smoothness](https://en.wikipedia.org/wiki/Smoothness) $s$ at a knot, the derivatives of orders $0, 1, \\ldots, s$ of adjacent polynomials must all be equal at the knot point.\n\nYeah, yeah, whatever.\n\n## B-splines\n\nNext comes the \"basis spline\" trick. As it happens, you can rewrite *any* spline as a weighted sum of so-called B-splines. Let $f_{m, \\mathbf{k}}(x)$ denote a spline function of order $m$ with knot vector $\\mathbf{k}$. Then \n\n$$\nf_{m, \\mathbf{k}}(x) = \\sum_i \\alpha_i \\ B_{i,m}(x)\n$$\n\nwhere $B_{i,m}(x)$ is a **basis spline** ([B-spline](https://en.wikipedia.org/wiki/B-spline)) function defined with respect to the same knot vector $\\mathbf{k}$, and the coefficient $\\alpha_i$ define the weight assigned to the $i$-th basis spline of order $m$. The basis spline functions are themselves splines, but they are a specific set of spline functions designed to give us the result above.^[Something something about B-splines forming a basis for the spline function space or whatever.] From the perspective of a data analyst who wants to fit an arbitrary spline function to a set of points, it can be awfully convenient to work with basis splines because the problem of estimating the unknown spline function $f(x)$ can be transformed into the problem of estimating the coefficients $\\alpha$. \n\n## P-splines\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}