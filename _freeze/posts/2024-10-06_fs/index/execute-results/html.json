{
  "hash": "9975bed2648a6a883a3b4f31b0286e03",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"For fs\"\ndescription: \"Let's be honest... I wrote this post because I wanted an excuse to be sweary. But I guess it's also a post about interacting with the file system in R\"\ndate: \"2024-10-06\"\ncategories: [\"R\", \"Command Line\"]\n--- \n\n\n\n<!--------------- my typical setup ----------------->\n\n\n\n\n\n\n\n<!--------------- post begins here ----------------->\n\n\n\n\n\n\n\n\n-- okay i'm doing it. gonna write a post about the fs package <br>\n-- **but why tho?** <br>\n-- because it's cool and fun <br>\n-- **girl it's literally a tool for interacting with the file system within a statistical programming language. in no possible universe is this cool, fun, or exciting. you are the absolute worst engagement farmer in the history of engagement farming** <br>\n-- pfft, everyone's gonna love it babe, you'll see. this shit is girt af <br>\n-- **hon \"girt\" died the moment the olympics ended. it is as passé as a raygun meme. we're all doing moo deng now, so all you're accomplishing here is giving away just how long this post has been in drafts. but hey you do you. i just wanna see how this ends...** <br>\n\nUm. So. \n\nNow that my vicious alter ego has brutally shattered all my hopes and dreams for this blog post, I suppose I should introduce it properly? This is a post about the [fs](https://fs.r-lib.org/) R package, and as I *tried* to explain to that bitch who lives in the back of my head and kills every source of love and joy in my world, it provides a cross-platform, uniform interface to file system operations. It is, in a sense, a drop-in replacement for base R functions like `file.path()`, `list.files()` and so on. It supplies a cleaner and more consistent interface to these functions, and provides a few other handy tools that aren't available in the base R equivalents. It's a\n\n-- **no sorry gonna have to step in here. where are you going with this? you just lost like 99% of your possible readership the moment you plagiarised from the package documentation. wtf girl**\n\nlovely little package. Sheesh. She's not very nice, is she?\n\n<br>\n\n## Why should anyone care about this?\n\nA package like fs is hard to write about. It's not a sparkly shiny thing, it's not the new hotness, and low-level utility tooling is... well, it's inherently boring. In everyday life, about 90% of my usage of the fs package is just me using the `path()` function to specify a file path, and... okay, let's load the package and see what that looks like, yeah?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(fs)\npath(\"hello\", \"world.txt\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nhello/world.txt\n```\n\n\n:::\n:::\n\n\n\nIn this example I'm passing two input strings, `\"hello\"` and `\"world.txt\"`, and from these the `path()` function has concatenated them using an appropriate separator character so that the output can be interpreted as a (relative) path to a file. Even in the world of statistical programming it is hard to think of anything you could do with a computer that is less exciting than this. It is undeniably, unequivocally, unbelievably dull.\n\n-- **no shit** <br>\n-- do you mind? i'm trying to set the stage here <br>\n-- **fine. please, do continue. this should be good**\n\nInterruptions notwithstanding, the thing about boring tasks is that they're often neglected. Especially if those boring things look simple. And to be fair, neglecting a thing that looks simple is probably an okay thing to do if it actually *is* simple, but it can create problems if there are hidden nuances underneath the apparently-simple appearance. Interacting with the file system is one of those things. I cannot count the number of times when I've encountered code that looks like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# I am setting up my project now...\ndir1  <- \"project_root/a_folder/another_folder\"\nfile <- \"file.ext\" \n\n# ...and 3000 lines of code later I do this\npaste(dir1, file, sep = \"\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"project_root/a_folder/another_folderfile.ext\"\n```\n\n\n:::\n:::\n\n\n\nObviously, this is not the result we wanted. Unlike `path()`, the `paste()` function is not specifically designed to construct file paths: it's a tool for concatenating strings and it makes no distinction between strings that look like file paths and strings that don't. \n\nWhen looking at a code extract like the one above, it's so very easy to think \"well I would never be that dumb\", but the \"3000 lines later\" part is crucial here. The moment any project starts to grow in scope -- be it a developer project or an analysis project -- you reach a point where the code base is large enough that you can't remember what you did earlier, and it is *horrifyingly* easy to be exactly that stupid. \n\nOn top of that, if you happened to be lucky enough not to make the error above, there's a pretty good chance you'll mess up the other way and write code like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# this time I terminate my folder path with a slash...\ndir2 <- \"project_root/a_folder/\"\n\n# ...and 3000 lines later I forget I did that\npaste(dir2, file, sep = \"/\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"project_root/a_folder//file.ext\"\n```\n\n\n:::\n:::\n\n\n\nIn a way, this is a worse mistake. In the first example you'll definitely notice the problem because your code breaks the moment you try to work with a file that doesn't exist, and R will throw an error. But the second one won't do that. It's a valid path to the relevant file, so your code will work just fine... right up to the point that you try to write a regular expression that operates on paths and that extra slash breaks something. Worse yet, if your project has expanded to the point that you're writing a regex to operate on vectors of paths you can be *entirely* certain you've lost tract of the initial mistake that created the problem, and you're trapped in debugging mode for an hour and a half trying to work out where you went wrong.\n\nASK. ME. HOW. I. KNOW.\n\nIn any case, the point in all this is that human [working memory capacity](https://en.wikipedia.org/wiki/Working_memory) is about 7 plus or minus 2 \"chunks\" of meaninful information:^[No I absolutely will not be going into details about the subtle differences in working memory capacity as a function of modality and age, or the nuances about what precisely comprises as chunk, or whatever in the well-actually fuck you want to nitpick. Do I look like a cognitive scientist to you?] we literally do not have the ability to hold a lot of code in our mind at once. So if you manage your file paths using `paste()` I guarantee you that you *will* mess this up eventually. Not because you're stupid, but because you are human.\n\nWouldn't it be nice if we had a function... let's call it `path()`... that protects us from this particular kind of human frailty? Of course it would.\n\n## Lorem ipsum text\n\nNow that we've established some motivation for caring about this topic\n\n-- **lol. lmao even** <br>\n-- oh hush <br>\n\nit will be convenient to have a little tool that generates [lorem ipsum text](https://en.wikipedia.org/wiki/Lorem_ipsum) that we can write to files that we'll then manipulate using fs. To that end, I'll define a `lorem_text()` function that uses the [lorem](http://pkg.garrickadenbuie.com/lorem/) and [withr](https://withr.r-lib.org/) packages to reproducibly generate paragraphs of lorem ipsum text:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlorem_text <- function(seed, paragraphs, digit_pad = 3) {\n  lorem <- withr::with_seed(seed, lorem::ipsum(paragraphs))\n  names(lorem) <- purrr::imap_chr(lorem, \\(x, y) paste(\n    stringr::str_pad(seed, width = digit_pad, pad = \"0\"),\n    stringr::str_pad(y, width = digit_pad, pad = \"0\"),\n    stringr::str_to_lower(stringr::str_remove_all(x, \" .*$\")),\n    sep = \"_\"\n  ))\n  lorem\n}\n```\n:::\n\n\n\nTo call this function we pass the `seed` value for the random number generator to use, and the number of `paragraphs` of lorem ipsum text to create:^[In the interests of tranparency I should mention that if you tried this code as-is within a quarto or R markdown document, it wouldn't necessarily be displayed in italics like this. That's a personal affectation I added in this post to more clearly delineate the end of the R output from the start of the markdown text.]\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlorem_text(seed = 999, paragraphs = 3)\n```\n:::\n\n_Amet arcu suscipit donec cras inceptos rhoncus varius hac? Sociosqu luctus iaculis; ut sociosqu porta risus tristique phasellus? Duis porta in placerat phasellus class. Dapibus nostra ac, aptent nam tempus mattis eleifend metus._\n\n_Lorem molestie in elementum nascetur scelerisque cum pulvinar felis massa. Fringilla est tortor auctor nulla tristique ac mi commodo vitae. Torquent sodales eget lacinia quam elementum sodales. Cras porttitor iaculis curae eleifend fringilla pellentesque nascetur. Integer ligula per dignissim, dapibus feugiat nullam urna tristique viverra sociis felis etiam._\n\n_Sit posuere suscipit accumsan mus curabitur nullam, etiam scelerisque donec justo libero posuere. Mattis curae et litora._\n\n\n\n\nThough not obvious from the printed output, the data structure that this function returns is a named list under the hood:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(lorem_text(seed = 999, paragraphs = 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"999_001_amet\"  \"999_002_lorem\" \"999_003_sit\"  \n```\n\n\n:::\n:::\n\n\n\nThe names here follow a regular pattern: they contain the seed number, the paragraph number, and the first word in the paragraph, separated by underscores. In the examples below, these names become file names, and the text in each paragraph become the content written to the various files. \n\n-- **thrilling** <br>\n-- so you're just set on doing this? you're going to snipe at me the whole way through?<br>\n--  <br>\n--  <br>\n--  <br>\n--  <br>\n-- **yes.**\n\n\n## Building paths\n\nSo as I was saying earlier, about 90% of my usage of the fs package is via the `path()` function used to construct file paths, so it's the natural place to start. Here's a very simple example that specifies the path from my blog root to this quarto document:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npath(\"posts\", \"2024-09-15_fs\", \"index.qmd\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nposts/2024-09-15_fs/index.qmd\n```\n\n\n:::\n:::\n\n\n\nI'm building this post on linux, so paths are separated by the `\"/\"` character. If I were building on windows, I'd get a different result.\n\nThe `path()` function is vectorised and doesn't require that the paths in question actually exist on the machine, so I can do something like this to define a vector of paths that I can work with later on:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlorem <- lorem_text(seed = 1, paragraphs = 20)\nlorem_paths <- path(\"lorem\", names(lorem))\nlorem_paths\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlorem/001_001_consectetur lorem/001_002_ipsum       \nlorem/001_003_elit        lorem/001_004_lorem       \nlorem/001_005_consectetur lorem/001_006_sit         \nlorem/001_007_sit         lorem/001_008_adipiscing  \nlorem/001_009_adipiscing  lorem/001_010_lorem       \nlorem/001_011_lorem       lorem/001_012_adipiscing  \nlorem/001_013_amet        lorem/001_014_sit         \nlorem/001_015_elit        lorem/001_016_ipsum       \nlorem/001_017_adipiscing  lorem/001_018_consectetur \nlorem/001_019_amet        lorem/001_020_consectetur \n```\n\n\n:::\n:::\n\n\n\nThese are relative paths, and since (by default) quarto blog posts are executed with the working directory set to the folder that contains the document, these paths are implicitly taken relative to this folder.\n\n-- **wow how exci...** <br>\n-- shut up, nobody wants to hear from you <br>\n-- **uh huh** <br>\n\n## File system operations\n\nThe second most common thing I find myself using the fs package for is basic file system operations: creating files and folders, copying, deleting, and moving files, etc. For example, the paths I specified in the previous section all refer to a folder called \"lorem\", but that folder doesn't currently exist. Indeed, I can verify that no such folder exists using the `dir_exists()` function\":\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir_exists(\"lorem\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlorem \nFALSE \n```\n\n\n:::\n:::\n\n\n\nThat's handy to know, because I actually *do* want this folder to exist, and fortunately I can create the folder I want from R by using `dir_create()`, and then verify that it now exists:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir_create(\"lorem\")\ndir_exists(\"lorem\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlorem \n TRUE \n```\n\n\n:::\n:::\n\n\n\nLike all functions in fs, these are vectorised operations. For example, I can test for the existence of multiple folders at once like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir_exists(c(\"lorem\", \"ipsum\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlorem ipsum \n TRUE FALSE \n```\n\n\n:::\n:::\n\n\n\nIn any case, now that the \"lorem\" directory exists, I can use `file_create()` to create the files listed in the `lorem_paths` vector I defined earlier. Again, `file_create()` is vectorised, so I can pass the vector of file names directly with no need to write a loop:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfile_create(lorem_paths)\n```\n:::\n\n\n\nThough there is no output printed to the console, all the files I requested have now been created. To see this, I can use `dir_ls()` to return a vector containing all the file names within a specified folder:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir_ls(\"lorem\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlorem/001_001_consectetur lorem/001_002_ipsum       \nlorem/001_003_elit        lorem/001_004_lorem       \nlorem/001_005_consectetur lorem/001_006_sit         \nlorem/001_007_sit         lorem/001_008_adipiscing  \nlorem/001_009_adipiscing  lorem/001_010_lorem       \nlorem/001_011_lorem       lorem/001_012_adipiscing  \nlorem/001_013_amet        lorem/001_014_sit         \nlorem/001_015_elit        lorem/001_016_ipsum       \nlorem/001_017_adipiscing  lorem/001_018_consectetur \nlorem/001_019_amet        lorem/001_020_consectetur \n```\n\n\n:::\n:::\n\n\n\nOkay, that's nice, but I don't actually want a folder full of empty files. So let's delete the folder and everything in it. That's easy enough to do with `dir_delete()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir_delete(\"lorem\")\n```\n:::\n\n\n\nAnd just like that, the files and folder are gone. Alternatively, if I had wanted only to delete some of the files I could have used `file_delete()` to be a little more selective!\n\n\n## File trees\n\nOkay that's handy. As a slightly fancier example, though, let's try creating files with a little more structure to them. Rather than write each of the lorem files to the same directory, we can place them in subfolders based on the first word in the lorem text. To do that, I'll need to create these directories:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlorem_dirs <- unique(stringr::str_remove(names(lorem), \"^.*_\"))\nlorem_dirs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"consectetur\" \"ipsum\"       \"elit\"        \"lorem\"       \"sit\"        \n[6] \"adipiscing\"  \"amet\"       \n```\n\n\n:::\n:::\n\n\n\nHowever, I don't want to create these as top level folders: my file structure could become a mess if I do that. Instead, I'll create them as subfolders of a \"nonsense\" folder. I can do this with a single call to `dir_create()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir_create(path(\"nonsense\", lorem_dirs))\n```\n:::\n\n\n\nThis command creates the \"nonsense\" folder itself, and populates it with all the subfolders listed in `lorem_dirs`. To see this displayed as a nice file tree, I'll use the `dir_tree()` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir_tree(\"nonsense\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nnonsense\n├── adipiscing\n├── amet\n├── consectetur\n├── elit\n├── ipsum\n├── lorem\n└── sit\n```\n\n\n:::\n:::\n\n\n\nHaving created a nested directory structure, I can now define the paths to which I want to write files:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlorem_paths <- path(\n  \"nonsense\", \n  stringr::str_remove(names(lorem), \"^.*_\"), \n  names(lorem)\n)\nlorem_paths\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nnonsense/consectetur/001_001_consectetur\nnonsense/ipsum/001_002_ipsum\nnonsense/elit/001_003_elit\nnonsense/lorem/001_004_lorem\nnonsense/consectetur/001_005_consectetur\nnonsense/sit/001_006_sit\nnonsense/sit/001_007_sit\nnonsense/adipiscing/001_008_adipiscing\nnonsense/adipiscing/001_009_adipiscing\nnonsense/lorem/001_010_lorem\nnonsense/lorem/001_011_lorem\nnonsense/adipiscing/001_012_adipiscing\nnonsense/amet/001_013_amet\nnonsense/sit/001_014_sit\nnonsense/elit/001_015_elit\nnonsense/ipsum/001_016_ipsum\nnonsense/adipiscing/001_017_adipiscing\nnonsense/consectetur/001_018_consectetur\nnonsense/amet/001_019_amet\nnonsense/consectetur/001_020_consectetur\n```\n\n\n:::\n:::\n\n\n\nFor each path in the `lorem_paths` vector, we can write the text to the corresponding file like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::walk(\n  seq_along(lorem),\n  \\(x) brio::write_lines(\n    text = lorem[[x]],\n    path = lorem_paths[x]\n  )\n)\n```\n:::\n\n\n\nThe file tree now looks like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir_tree(\"nonsense\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nnonsense\n├── adipiscing\n│   ├── 001_008_adipiscing\n│   ├── 001_009_adipiscing\n│   ├── 001_012_adipiscing\n│   └── 001_017_adipiscing\n├── amet\n│   ├── 001_013_amet\n│   └── 001_019_amet\n├── consectetur\n│   ├── 001_001_consectetur\n│   ├── 001_005_consectetur\n│   ├── 001_018_consectetur\n│   └── 001_020_consectetur\n├── elit\n│   ├── 001_003_elit\n│   └── 001_015_elit\n├── ipsum\n│   ├── 001_002_ipsum\n│   └── 001_016_ipsum\n├── lorem\n│   ├── 001_004_lorem\n│   ├── 001_010_lorem\n│   └── 001_011_lorem\n└── sit\n    ├── 001_006_sit\n    ├── 001_007_sit\n    └── 001_014_sit\n```\n\n\n:::\n:::\n\n\n\n\n## File information\n\nSometimes it is useful to retrieve information about a file, analogous to the [`stat`](https://www.man7.org/linux/man-pages/man2/stat.2.html) command on linux systems. From the terminal, you'd get output that looks like this:^[Sigh. I'm hiding something. If you do this command at the R console, you will indeed get the output shown below. However, if you try to do this from within R markdown or quarto you will not. This is because the output you see here reflects the system stdout, which is different from the R console stdout, and if you want to capture this within the HTML document you have to do something a little fancier, setting `intern = TRUE` to ensure `system()` returns the terminal output as a character vector that you can then print to the R console in the usual way with `cat()`. See [this](https://stackoverflow.com/questions/36928322/how-to-capture-the-output-of-system) discussion on stackoverflow.]\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsystem(\"stat nonsense/lorem/001_004_lorem\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n  File: nonsense/lorem/001_004_lorem\n  Size: 474       \tBlocks: 8          IO Block: 4096   regular file\nDevice: 252,1\tInode: 1586402     Links: 1\nAccess: (0664/-rw-rw-r--)  Uid: ( 1000/danielle)   Gid: ( 1000/danielle)\nAccess: 2024-10-06 13:13:58.912217954 +1100\nModify: 2024-10-06 13:13:58.912217954 +1100\nChange: 2024-10-06 13:13:58.912217954 +1100\n Birth: 2024-10-06 13:13:58.912217954 +1100\n```\n\n\n:::\n:::\n\n\n\n\n\nThe `file_info()` function in the fs package mirrors this behaviour, all nicely vectorised so you can pass a vector of file paths, and with output organised into a tidy little tibble to make it easy to work with programmatically:\n\n\n\n::: {.cell .column-screen-inset}\n\n```{.r .cell-code}\nfile_info(lorem_paths[1:4])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 18\n  path                                     type         size permissions modification_time   user     group    device_id hard_links special_device_id   inode block_size blocks flags generation access_time         change_time         birth_time         \n  <fs::path>                               <fct> <fs::bytes> <fs::perms> <dttm>              <chr>    <chr>        <dbl>      <dbl>             <dbl>   <dbl>      <dbl>  <dbl> <int>      <dbl> <dttm>              <dttm>              <dttm>             \n1 nonsense/consectetur/001_001_consectetur file          307 rw-rw-r--   2024-10-06 13:13:58 danielle danielle     64513          1                 0 1586371       4096      8     0          0 2024-10-06 13:13:58 2024-10-06 13:13:58 2024-10-06 13:13:58\n2 nonsense/ipsum/001_002_ipsum             file          322 rw-rw-r--   2024-10-06 13:13:58 danielle danielle     64513          1                 0 1586372       4096      8     0          0 2024-10-06 13:13:58 2024-10-06 13:13:58 2024-10-06 13:13:58\n3 nonsense/elit/001_003_elit               file          397 rw-rw-r--   2024-10-06 13:13:58 danielle danielle     64513          1                 0 1586401       4096      8     0          0 2024-10-06 13:13:58 2024-10-06 13:13:58 2024-10-06 13:13:58\n4 nonsense/lorem/001_004_lorem             file          474 rw-rw-r--   2024-10-06 13:13:58 danielle danielle     64513          1                 0 1586402       4096      8     0          0 2024-10-06 13:13:58 2024-10-06 13:13:58 2024-10-06 13:13:58\n```\n\n\n:::\n:::\n\n\n\nThere is an analogous function `dir_info()` that can be applied to a directory, and the output is structured the same way:\n\n\n\n::: {.cell .column-screen-inset}\n\n```{.r .cell-code}\ndir_info(\"nonsense\", recurse = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 27 × 18\n   path                                     type             size permissions modification_time   user     group    device_id hard_links special_device_id   inode block_size blocks flags generation access_time         change_time         birth_time         \n   <fs::path>                               <fct>     <fs::bytes> <fs::perms> <dttm>              <chr>    <chr>        <dbl>      <dbl>             <dbl>   <dbl>      <dbl>  <dbl> <int>      <dbl> <dttm>              <dttm>              <dttm>             \n 1 nonsense/adipiscing                      directory          4K rwxr-xr-x   2024-10-06 13:13:58 danielle danielle     64513          2                 0 1586368       4096      8     0          0 2024-10-06 13:13:58 2024-10-06 13:13:58 2024-10-06 13:13:58\n 2 nonsense/adipiscing/001_008_adipiscing   file              415 rw-rw-r--   2024-10-06 13:13:58 danielle danielle     64513          1                 0 1586419       4096      8     0          0 2024-10-06 13:13:58 2024-10-06 13:13:58 2024-10-06 13:13:58\n 3 nonsense/adipiscing/001_009_adipiscing   file              370 rw-rw-r--   2024-10-06 13:13:58 danielle danielle     64513          1                 0 1586420       4096      8     0          0 2024-10-06 13:13:58 2024-10-06 13:13:58 2024-10-06 13:13:58\n 4 nonsense/adipiscing/001_012_adipiscing   file              254 rw-rw-r--   2024-10-06 13:13:58 danielle danielle     64513          1                 0 1586514       4096      8     0          0 2024-10-06 13:13:58 2024-10-06 13:13:58 2024-10-06 13:13:58\n 5 nonsense/adipiscing/001_017_adipiscing   file              393 rw-rw-r--   2024-10-06 13:13:58 danielle danielle     64513          1                 0 1589481       4096      8     0          0 2024-10-06 13:13:58 2024-10-06 13:13:58 2024-10-06 13:13:58\n 6 nonsense/amet                            directory          4K rwxr-xr-x   2024-10-06 13:13:58 danielle danielle     64513          2                 0 1586369       4096      8     0          0 2024-10-06 13:13:58 2024-10-06 13:13:58 2024-10-06 13:13:58\n 7 nonsense/amet/001_013_amet               file              367 rw-rw-r--   2024-10-06 13:13:58 danielle danielle     64513          1                 0 1586515       4096      8     0          0 2024-10-06 13:13:58 2024-10-06 13:13:58 2024-10-06 13:13:58\n 8 nonsense/amet/001_019_amet               file              313 rw-rw-r--   2024-10-06 13:13:58 danielle danielle     64513          1                 0 1589484       4096      8     0          0 2024-10-06 13:13:58 2024-10-06 13:13:58 2024-10-06 13:13:58\n 9 nonsense/consectetur                     directory          4K rwxr-xr-x   2024-10-06 13:13:58 danielle danielle     64513          2                 0 1586360       4096      8     0          0 2024-10-06 13:13:58 2024-10-06 13:13:58 2024-10-06 13:13:58\n10 nonsense/consectetur/001_001_consectetur file              307 rw-rw-r--   2024-10-06 13:13:58 danielle danielle     64513          1                 0 1586371       4096      8     0          0 2024-10-06 13:13:58 2024-10-06 13:13:58 2024-10-06 13:13:58\n# ℹ 17 more rows\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfile_size(lorem_paths)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n307 322 397 474 196 599 501 415 370 135 228 254 367 360 357 375 393 552 313 523\n```\n\n\n:::\n:::\n\n\n\n## Path arithmetic\n\nMy absolute favourite collection of functions within fs are the ones that can be used to perform \"path arithmetic\", by which what I really mean is string manipulations for common tasks that you have to perform with paths, thereby saving me from having to write a regular expression. Because, like all right-thinking people, I loathe regular expressions with a passion I usually reserve for real estate agents and people who don't pick up after their dogs. \n\nTo illustrate the idea, let's think about some common tasks we might need to perform using the `lorem_paths` vector:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlorem_paths\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nnonsense/consectetur/001_001_consectetur\nnonsense/ipsum/001_002_ipsum\nnonsense/elit/001_003_elit\nnonsense/lorem/001_004_lorem\nnonsense/consectetur/001_005_consectetur\nnonsense/sit/001_006_sit\nnonsense/sit/001_007_sit\nnonsense/adipiscing/001_008_adipiscing\nnonsense/adipiscing/001_009_adipiscing\nnonsense/lorem/001_010_lorem\nnonsense/lorem/001_011_lorem\nnonsense/adipiscing/001_012_adipiscing\nnonsense/amet/001_013_amet\nnonsense/sit/001_014_sit\nnonsense/elit/001_015_elit\nnonsense/ipsum/001_016_ipsum\nnonsense/adipiscing/001_017_adipiscing\nnonsense/consectetur/001_018_consectetur\nnonsense/amet/001_019_amet\nnonsense/consectetur/001_020_consectetur\n```\n\n\n:::\n:::\n\n\n\nThe most common task that I have to do regularly with paths like this is extract the file name. Under other circumstances I'd have to spend time asking myself \"are these paths correctly formatted?\" and \"god, how do I write a basic regex again????\" but thankfully the `path_file()` functions saves me from this terrible fate:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npath_file(lorem_paths)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"001_001_consectetur\" \"001_002_ipsum\"       \"001_003_elit\"       \n [4] \"001_004_lorem\"       \"001_005_consectetur\" \"001_006_sit\"        \n [7] \"001_007_sit\"         \"001_008_adipiscing\"  \"001_009_adipiscing\" \n[10] \"001_010_lorem\"       \"001_011_lorem\"       \"001_012_adipiscing\" \n[13] \"001_013_amet\"        \"001_014_sit\"         \"001_015_elit\"       \n[16] \"001_016_ipsum\"       \"001_017_adipiscing\"  \"001_018_consectetur\"\n[19] \"001_019_amet\"        \"001_020_consectetur\"\n```\n\n\n:::\n:::\n\n\n\nAnalogously, if I need to extract the directory name and ignore the file name, I could waste precious seconds of my life thinking about this tedious task using first principles, or I can simply use `path_dir()` to do this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npath_dir(lorem_paths)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"nonsense/consectetur\" \"nonsense/ipsum\"       \"nonsense/elit\"       \n [4] \"nonsense/lorem\"       \"nonsense/consectetur\" \"nonsense/sit\"        \n [7] \"nonsense/sit\"         \"nonsense/adipiscing\"  \"nonsense/adipiscing\" \n[10] \"nonsense/lorem\"       \"nonsense/lorem\"       \"nonsense/adipiscing\" \n[13] \"nonsense/amet\"        \"nonsense/sit\"         \"nonsense/elit\"       \n[16] \"nonsense/ipsum\"       \"nonsense/adipiscing\"  \"nonsense/consectetur\"\n[19] \"nonsense/amet\"        \"nonsense/consectetur\"\n```\n\n\n:::\n:::\n\n\n\nMuch easier, and frankly more reliable, than trying to do the job myself. \n\nThere's even a `path_common()` function that returns the part of the path that is shared by all paths in the vector. I'll admit I don't use that one as often, but it's kind of nice that the package supplies this. I appreciate the attention to detail involved in recognising that sometimes you do need to find the lowest-level folder that contains all files:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npath_common(lorem_paths)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nnonsense\n```\n\n\n:::\n:::\n\n\n\nSure, I already knew that \"nonsense\" is the folder containing all these files because I designed this little exercise that way, but still pretty handy, especially when you combine it with `path_abs()` that converts a relative path to an absolute path to find the actual location on my machine that contains all these files:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlorem_paths |> \n  path_common() |> \n  path_abs()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n/home/danielle/GitHub/djnavarro/blog/posts/2024-10-06_fs/nonsense\n```\n\n\n:::\n:::\n\n\n\nYou can also call `path_split()` to split paths into a list of character vectors, where each such vector contains one element per level in the file hierarchy. This behaves analogously to base `split()` or `stringr::str_split()`, but automatically splits using the relevant file separator character on your operating system:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npath_split(lorem_paths[1:2])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"nonsense\"            \"consectetur\"         \"001_001_consectetur\"\n\n[[2]]\n[1] \"nonsense\"      \"ipsum\"         \"001_002_ipsum\"\n```\n\n\n:::\n:::\n\n\n\nIt's not the prettiest of outputs, but notice that you can use this as the basis for a list column in a data frame that you can then unnest with the assistance of tidyr:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlorem_paths |> \n  path_split() |> \n  tibble::tibble(level = _) |> \n  tidyr::unnest_wider(col = \"level\", names_sep = \"_\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 20 × 3\n   level_1  level_2     level_3            \n   <chr>    <chr>       <chr>              \n 1 nonsense consectetur 001_001_consectetur\n 2 nonsense ipsum       001_002_ipsum      \n 3 nonsense elit        001_003_elit       \n 4 nonsense lorem       001_004_lorem      \n 5 nonsense consectetur 001_005_consectetur\n 6 nonsense sit         001_006_sit        \n 7 nonsense sit         001_007_sit        \n 8 nonsense adipiscing  001_008_adipiscing \n 9 nonsense adipiscing  001_009_adipiscing \n10 nonsense lorem       001_010_lorem      \n11 nonsense lorem       001_011_lorem      \n12 nonsense adipiscing  001_012_adipiscing \n13 nonsense amet        001_013_amet       \n14 nonsense sit         001_014_sit        \n15 nonsense elit        001_015_elit       \n16 nonsense ipsum       001_016_ipsum      \n17 nonsense adipiscing  001_017_adipiscing \n18 nonsense consectetur 001_018_consectetur\n19 nonsense amet        001_019_amet       \n20 nonsense consectetur 001_020_consectetur\n```\n\n\n:::\n:::\n\n\n\nNote that this trick also works when the paths are of different lengths. For example, suppose I were to use `dir_ls()` to return the complete list of all files *and* folders contained within the \"nonsense\" folder, some of the paths will be length 2 rather than length 3, because the folder paths are also included in the output. Because `unnest_wider()` is able to handle ragged list columns, you get this as the output:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir_ls(\"nonsense\", recurse = TRUE) |> \n  path_split() |> \n  tibble::tibble(level = _) |> \n  tidyr::unnest_wider(col = \"level\", names_sep = \"_\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 27 × 3\n   level_1  level_2     level_3            \n   <chr>    <chr>       <chr>              \n 1 nonsense adipiscing  <NA>               \n 2 nonsense adipiscing  001_008_adipiscing \n 3 nonsense adipiscing  001_009_adipiscing \n 4 nonsense adipiscing  001_012_adipiscing \n 5 nonsense adipiscing  001_017_adipiscing \n 6 nonsense amet        <NA>               \n 7 nonsense amet        001_013_amet       \n 8 nonsense amet        001_019_amet       \n 9 nonsense consectetur <NA>               \n10 nonsense consectetur 001_001_consectetur\n# ℹ 17 more rows\n```\n\n\n:::\n:::\n\n\n\n## Miscellanea\n\nThere are a variety of other helper functions in fs, some of which I very occasionally make use of. For instance, you can use `file_chmod()` to change file permissions, `file_touch()` to change file access and modification time metadata, `file_temp()` to create a temporary file, and so on. I find I don't use these as often, but I'm glad they exist.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}