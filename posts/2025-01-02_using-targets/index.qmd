---
title: "Using targets"
description: "Less painful than makefiles"
date: "2025-01-02"
--- 

<!--------------- my typical setup ----------------->

```{r}
#| label: setup
#| include: false
very_wide <- 500
wide <- 136
narrow <- 76
options(width = narrow)
cache_images <- TRUE
set.seed(1)
```

<!--------------- post begins here ----------------->

Useful links:

- [targets package website](https://docs.ropensci.org/targets/)
- [targets user manual](https://books.ropensci.org/targets/)

Unhelpful links:

- [balrogs and makefiles](/posts/2023-06-30_makefiles/)
- [my shitty repo](https://github.com/djnavarro/tartoys)

```{r}
library(targets)
```

## Project 1: D&D spells

The first project is a fun [Tidy Tuesday](https://github.com/rfordatascience/tidytuesday/tree/main/data/2024/2024-12-17) project that makes these two images: 

::: {layout="[2,1]" .column-page}

![dice_pic.png](img/dice_pic.png)

![scholastic_pic.png](img/scholastic_pic.png)

:::

```{r}
#| label: targets-spells-destroy
#| echo: false
# complete clean, mimic fresh state
if (fs::dir_exists("spells/_targets")) fs::dir_delete("spells/_targets")
if (fs::dir_exists("spells/output")) fs::dir_delete("spells/output")
```

```{r}
#| label: spells-dir-tree-fresh
fs::dir_tree("spells")
```

### Defining the pipeline

The nice thing about a targets workflow is that you can (sometimes) see the entire structure of the project just by looking at the `_targets.R` script:

```{r}
#| label: spells-targets-file
#| eval: false
#| code-line-numbers: true
#| filename: "_targets.R"
# packages used in the pipeline -------------------------------------------

library(targets)

tar_option_set(
  packages = c(
    "rprojroot", "fs", "tibble", "readr",
    "ggplot2", "dplyr", "stringr",
    "tidyr", "forcats", "ggrepel",
    "legendry"
  )
)

# define functions for the pipeline ---------------------------------------

tar_source(files = c("dice.R", "scholastic.R"))

set_output_dir <- function() {
  root <- find_root(has_file("_targets.R"))
  output <- path(root, "output")
  dir_create(output)
  return(output)
}

# define the targets ------------------------------------------------------

list(
  # preprocessing targets
  tar_target(input, "spells.csv", format = "file"),
  tar_target(output, set_output_dir()),
  tar_target(spells, read_csv(input, show_col_types = FALSE)),

  # dice plot targets
  tar_target(dice_dat, dice_data(spells)),
  tar_target(dice_pic, dice_plot(dice_dat, output)),

  # scholastic plot targets
  tar_target(scholastic_dat, scholastic_data(spells)),
  tar_target(scholastic_clus, scholastic_clusters(scholastic_dat)),
  tar_target(
    scholastic_pic,
    scholastic_plot(scholastic_dat, scholastic_clus, output)
  )
)
```

There are three clear sections:

- packages needed for the workflow
- functions used to execute the workflow
- the list of targets 

It's not super relevant to the post, but here's the code defined in the `dice.R` and `scholastic.R` scripts. This code does all the work of building the plots, but I'm not going to dive into it in any detail here:

::: {.callout-note icon=false title="Plotting code"}

```{r}
#| label: dnd-dice-file
#| eval: true
#| code-line-numbers: true
#| code-fold: true
#| code-summary: "Click to show/hide the dice.R code"
#| filename: "dice.R"
dice_data <- function(spells) {
  dice_dat <- spells |>
    select(name, level, description) |>
    mutate(
      dice_txt = str_extract_all(description, "\\b\\d+d\\d+\\b"),
      dice_txt = purrr::map(dice_txt, unique)
    ) |>
    unnest_longer(
      col = "dice_txt",
      values_to = "dice_txt",
      indices_to = "position"
    ) |>
    mutate(
      dice_num = dice_txt |> str_extract("\\d+(?=d)") |> as.numeric(),
      dice_die = dice_txt |> str_extract("(?<=d)\\d+") |> as.numeric(),
      dice_val = dice_num * (dice_die + 1)/2,
      dice_txt = factor(dice_txt) |> fct_reorder(dice_val)
    )
  return(dice_dat)
}

dice_plot <- function(dice_dat, output) {

  palette <- hcl.colors(n = 10, palette = "PuOr")

  labs <- dice_dat |>
    summarise(
      dice_txt = first(dice_txt),
      count = n(),
      .by = dice_txt
    )

  pic <- ggplot(
    data = dice_dat,
    mapping = aes(
      x = dice_txt,
      fill = factor(level)
    )
  ) +
    geom_bar(color = "#222") +
    geom_label_repel(
      data = labs,
      mapping = aes(
        x = dice_txt,
        y = count,
        label = dice_txt
      ),
      size = 3,
      direction = "y",
      seed = 1,
      nudge_y = 4,
      color = "#ccc",
      fill = "#222",
      arrow = NULL,
      inherit.aes = FALSE
    ) +
    scale_fill_manual(
      name = "Spell level",
      values = palette
    ) +
    scale_x_discrete(
      name = "Increasing average outcome \u27a1",
      breaks = NULL,
      expand = expansion(.05)
    ) +
    scale_y_continuous(name = NULL) +
    labs(
      title = "Frequency of dice rolls described in D&D spell descriptions, by spell level",
      subtitle = "Or whatever",
      caption = "Source: https://github.com/rfordatascience/tidytuesday/tree/main/data/2024/2024-12-17"
    ) +
    theme_void() +
    theme(
      plot.background = element_rect(fill = "#222"),
      text = element_text(color = "#ccc"),
      axis.text = element_text(color = "#ccc"),
      axis.title = element_text(color = "#ccc"),
      plot.margin = unit(c(1, 1, 1, 1), units = "cm"),
      legend.position = "inside",
      legend.position.inside = c(.3, .825),
      legend.direction = "horizontal",
      legend.title.position = "top",
      legend.byrow = TRUE
    )

  out <- path(output, "dice_pic.png")

  ggsave(
    filename = out,
    plot = pic,
    width = 2000,
    height = 1000,
    units = "px",
    dpi = 150
  )

  return(out)
}
```


```{r}
#| label: dnd-scholastic-file
#| eval: true
#| code-line-numbers: true
#| code-fold: true
#| code-summary: "Click to show/hide the scholastic.R code"
#| filename: "scholastic.R"
# constructs the data frame used by geom_tile() later
scholastic_data <- function(spells) {
  spells |>
    select(name, school, bard:wizard) |>
    pivot_longer(
      cols = bard:wizard,
      names_to = "class",
      values_to = "castable"
    ) |>
    summarise(
      count = sum(castable),
      .by = c("school", "class")
    ) |>
    mutate(
      school = str_to_title(school),
      class  = str_to_title(class)
    )
}

# hierarchical clustering for the schools and classes
scholastic_clusters <- function(dat) {

  # matrix of counts for each school/class combination
  mat <- dat |>
    pivot_wider(
      names_from = "school",
      values_from = "count"
    ) |>
    as.data.frame()
  rownames(mat) <- mat$class
  mat$class <- NULL
  as.matrix(mat)

  # each school is a distribution over classes,
  # each class is a distribution over schools
  class_distribution  <- mat / replicate(ncol(mat), rowSums(mat))
  school_distribution <- t(mat) / (replicate(nrow(mat), colSums(mat)))

  # pairwise distances
  class_dissimilarity  <- dist(class_distribution)
  school_dissimilarity <- dist(school_distribution)

  # hierarchical clustering
  clusters <- list(
    class = hclust(class_dissimilarity, method = "average"),
    school = hclust(school_dissimilarity, method = "average")
  )

  return(clusters)
}

scholastic_plot <- function(dat, clusters, output) {

  pic <- ggplot(dat, aes(school, class, fill = count)) +
    geom_tile() +
    scale_x_dendro(
      clust = clusters$school,
      guide = guide_axis_dendro(n.dodge = 2),
      expand = expansion(0, 0),
      position = "top"
    ) +
    scale_y_dendro(
      clust = clusters$class,
      expand = expansion(0, 0)
    ) +
    scale_fill_distiller(palette = "RdPu") +
    labs(
      x = "The Schools of Magic",
      y = "The Classes of Character",
      fill = "Number of Learnable Spells"
    ) +
    coord_equal() +
    theme(
      plot.background = element_rect(fill = "#222", color = "#222"),
      plot.margin = unit(c(2, 2, 2, 2), units = "cm"),
      text = element_text(color = "#ccc"),
      axis.text = element_text(color = "#ccc"),
      axis.title = element_text(color = "#ccc"),
      axis.ticks = element_line(color = "#ccc"),
      legend.position = "bottom",
      legend.background = element_rect(fill = "#222", color = "#222")
    )

  out <- path(output, "scholastic_pic.png")

  ggsave(
    filename = out,
    plot = pic,
    width = 1000,
    height = 1000,
    units = "px",
    dpi = 150
  )

  return(out)
}
```

:::

blah blah blah. 

As it happens, I have a copy of the project in the `spells` directory within this blog post, so we can in fact play with this project and see how targets operates. However, the project is designed to be a standalone, not part of a blog post, so I'll tweak my knitr settings so that code will now be executed from the `spells` subdirectory:

```{r}
#| label: knitr-setwd-spells
knitr::opts_knit$set(
  root.dir = here::here(
    "posts", 
    "2025-01-02_using-targets",  
    "spells"
  )
)
```


### Inspecting the pipeline

The `tar_visnetwork()` function provides a handy way of visualising the structure of a pipeline as a little HTML widget. By default it will show the dependencies between all functions and all targets, which is often totally fine, but I'm going to simplify it here by setting `targets_only = TRUE` (i.e., don't show the user-defined functions), and also set `exclude = c("input", "output")` to ignore the two really boring pre-processing targets! 

I'm also going to set `physics = TRUE`, which you don't usually need, but in this case turns out to be handy because it pushes some of the vertices in the graph just far enough apart that you can see all the edges properly. 

Anyway, here it is:

```{r}
#| label: targets-spells-visnetwork
tar_visnetwork(
  targets_only = TRUE, 
  exclude = c("input", "output"),
  physics = TRUE
)
```

This makes the structure of the project clear:

- The `dice_pic` image depends only on the `dice_dat` data set, and the `dice_dat` data set is derived from the `spells` data frame
- The `scholastic_pic` is a little more complicated because it depends on two data sets: there's the `scholastic_dat` data set that is derived directly from `spells`, but there's also the `scholastic_clus` object that is constructed from the `scholastic_dat` data set. 

If you want a little more detail, you can use `tar_manifest()` to get a summary of all the targets and the command with which they are associated:

```{r}
#| label: targets-spells-manifest
tar_manifest()
```

The output isn't as pretty as the HTML widget, but you can use it to see exactly what the target objects are, as well as the the command used to construct them. 

### Executing the pipeline

In the HTML widget above, all the targets are coloured in blue, indicating that these are "outdated". You can get a listing of all outdated targets like this:

```{r}
#| label: targets-spells-outdated
tar_outdated()
```

These are the targets that need to be (re)run. We can do this by calling `tar_make()`

```{r}
#| label: execute-spells
tar_make()
```


```{r}
#| label: spells-dir-tree-built
fs::dir_tree()
```

## Project 2: A toy blog

```{r}
#| label: knitr-setwd-liteblog
knitr::opts_knit$set(
  root.dir = here::here(
    "posts", 
    "2025-01-02_using-targets",  
    "liteblog"
  )
)
```

```{r}
#| label: targets-liteblog-destroy
#| echo: false
# complete clean, mimic fresh state
tar_destroy("all")
if(fs::dir_exists("_targets")) fs::dir_delete("_targets")
if(fs::dir_exists("site")) fs::dir_delete("site")
if(fs::file_exists("_liteblog.rds")) fs::file_delete("_liteblog.rds")
```

```{r}
#| label: liteblog-filetree-fresh
fs::dir_tree()
```

```{r}
#| label: liteblog-make
tar_make()
```

```{r}
#| label: liteblog-filetree-built
fs::dir_tree()
```

```{r}
#| label: copy-liteblog-to-site
#| echo: false
fs::dir_copy(
  path = "site",
  new_path = here::here("_site", "posts", "2025-01-02_using-targets"),
  overwrite = TRUE
)
```

You can browse the built website [here](./site/index.html)
