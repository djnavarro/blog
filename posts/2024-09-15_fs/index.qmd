---
title: "For fs"
description: "Let's be honest... I wrote this post because I wanted an excuse to be sweary. But I guess it's also a post about interacting with the file system in R"
date: "2024-09-15"
categories: ["R", "Command Line"]
--- 

<!--------------- my typical setup ----------------->

```{r}
#| label: setup
#| include: false
very_wide <- 500
wide <- 136
narrow <- 76
options(width = narrow)
cache_images <- TRUE
set.seed(1)
```

<!--------------- post begins here ----------------->

```{r}
#| include: false
dirs <- c("lorem")
for(d in dirs) if(fs::dir_exists(d)) fs::dir_delete(d)
```


-- okay i'm doing it. gonna write a post about the fs package <br>
-- **but why tho?** <br>
-- because it's cool and fun <br>
-- **girl it's literally a tool for interacting with the file system within a statistical programming language. in no possible universe is this cool, fun, or exciting. you are the absolute worst engagement farmer in the history of engagement farming** <br>
-- pfft, everyone's gonna love it babe, you'll see. this shit is girt af <br>
-- **hon "girt" died the moment the olympics ended. it is as pass√© as a raygun meme, and raygun is so far past her cultural moment that even jimmy bloody fallon already did an achingly unfunny bit on her. but hey you do you. i just wanna see how this ends...** <br>

Um. So. 

Now that my alter ego has so very kindly shattered all my hopes and dreams for this blog post, I suppose I should introduce it properly? This is a post about the [fs](https://fs.r-lib.org/) R package, and as I *tried* to explain to that bitch who lives in the back of my head and kills every source of love and joy in my world, it provides a cross-platform, uniform interface to file system operations. It is, in a sense, a drop-in replacement for base R functions like `file.path()`, `list.files()` and so on. It supplies a cleaner and more consistent interface to these functions, and provides a few other handy tools that aren't available in the base R equivalents. It's a

-- **no sorry gonna have to step in here. where are you going with this? you just lost like 99% of your possible readership the moment you plagiarised from the package documentation. wtf girl**

really lovely little package. Sheesh. She's not very nice, is she?

<br>

## Why should anyone care about this?

A package like fs is hard to write about. It's not a sparkly shiny thing, it's not the new hotness, and low-level utility tooling is... well, it's inherently boring. In everyday life, about 90% of my usage of the fs package is just me using the `path()` function to specify a file path, and... okay, let's load the package and see what that looks like, yeah?

```{r}
library(fs)
path("hello", "world.txt")
```

In this example I'm passing two input strings, `"hello"` and `"world.txt"`, and from these the `path()` function has concatenated them using an appropriate separator character so that the output can be interpreted as a (relative) path to a file. Even in the world of statistical programming it is hard to think of anything you could do with a computer that is less exciting than this. It is undeniably, unequivocally, unbelievably dull.

-- **no shit** <br>
-- do you mind? i'm trying to set the stage here <br>
-- **fine. please, do continue. this should be good**

Interruptions notwithstanding, the thing about boring tasks is that they're often neglected. Especially if those boring things look simple. And to be fair, neglecting a thing that looks simple is probably an okay thing to do if it actually *is* simple, but it can create problems if there are hidden nuances underneath the apparently-simple appearance. Interacting with the file system is one of those things. I cannot count the number of times when I've encountered code that looks like this:

```{r}
# I am setting up my project now...
dir1  <- "project_root/a_folder/another_folder"
file <- "file.ext" 

# ...and 3000 lines of code later I do this
paste(dir1, file, sep = "")
```

Obviously, this is not the result we wanted. Unlike `path()`, the `paste()` function is not specifically designed to construct file paths: it's a tool for concatenating strings and so it will assume that the user knows what they are doing. 

And yeah, it's so very easy to think "well I would never be that dumb", but the "3000 lines later" part is crucial here. The moment any project -- be it a developer project or an analysis project -- starts to become big enough that you can't remember what you did earlier, it is *horrifyingly* easy to be exactly that stupid. Besides. If you managed not to make the error above, there's a pretty good chance you'll mess up the other way and write code like this:

```{r}
# this time I terminate my folder path with a slash...
dir2 <- "project_root/a_folder/"

# ...and 3000 lines later I forget I did that
paste(dir2, file, sep = "/")
```

In a way, this is a worse mistake. In the first example you'll definitely notice the problem because your code breaks the moment you try to find a file that doesn't exist, and R will throw an error. But the second one won't do that. You'll find the file you're looking for and everything will work just fine... right up to the point that you try to write a regular expression that operates on paths and that extra slash breaks something. And of course by the time you're writing a regex to operate on vectors of paths you can be entirely certain you've lost tract of the initial mistake that created the problem, and you're trapped in debugging mode for an hour and a half trying to work out where you went wrong.

ASK. ME. HOW. I. KNOW.

In any case, the point in all this is that human [working memory capacity](https://en.wikipedia.org/wiki/Working_memory) is about 7 plus or minus 2 "chunks" of meaninful information:^[No I absolutely will not be going into details about the subtle differences in working memory capacity as a function of modality and age, or the nuances about what precisely comprises as chunk, or whatever in the well-actually fuck you want to nitpick. Do I look like a cognitive scientist to you?] we literally do not have the ability to hold a lot of code in our mind at once. So if you manage your file paths using `paste()` I guarantee you that you *will* fuck this up eventually. Not because you're stupid, but because you are human.

Wouldn't it be nice if we had a function... let's call it `path()`... that protects us from this particular kind of human frailty? Of course it would.

## Lorem ipsum text

Before diving in, I'm going to define a `lorem_text()` function that uses the [lorem](http://pkg.garrickadenbuie.com/lorem/) and [withr](https://withr.r-lib.org/) packages to reproducibly generate paragraphs of lorem ipsum text:

```{r}
lorem_text <- function(seed, paragraphs, digit_pad = 3) {
  lorem <- withr::with_seed(seed, lorem::ipsum(paragraphs))
  names(lorem) <- purrr::imap_chr(lorem, \(x, y) paste(
    stringr::str_pad(seed, width = digit_pad, pad = "0"),
    stringr::str_pad(y, width = digit_pad, pad = "0"),
    stringr::str_to_lower(stringr::str_remove_all(x, " .*$")),
    sep = "_"
  ))
  lorem
}
```


```{r}
lorem_text(seed = 1, paragraphs = 3)
```

Though not obvious from the printed output, this is a named list:

```{r}
names(lorem_text(seed = 1, paragraphs = 3))
```


## Building paths

So as I was saying earlier, about 90% of my usage of the fs package is via the `path()` function used to construct file paths, so it's the natural place to start. Here's a very simple example that specifies the path from my blog root to this quarto document:

```{r}
path("posts", "2024-09-15_fs", "index.qmd")
```

I'm building this post on linux, so paths are separated by the `"/"` character. If I were building on windows, I'd get a different result. The `path()` function is vectorised and doesn't require that the paths in question actually exist on the machine, so I can do something like this:



```{r}
lorem <- lorem_text(seed = 1, paragraphs = 20)
lorem_paths <- path("lorem", names(lorem))
lorem_paths
```

These are relative paths, and since (by default) quarto blog posts are executed with the working directory set to the folder that contains the document, these paths are implicitly taken relative to this folder.

## File system operations

The second most common thing I find myself using the fs package for is basic file system operations: creating files and folders, copying, deleting, and moving files, etc. For example, the paths I specified in the previous section all refer to a folder called "sentence", but that folder doesn't currently exist. I can check this using the `dir_exists()` function":

```{r}
dir_exists("lorem")
```

I can create this folder using `dir_create()`, and verify that it exists:

```{r}
dir_create("lorem")
dir_exists("lorem")
```

Now that the directory exists, I can use `file_create()` to create files that correspond to all the file paths I specified earlier. Like other functions in the fs package, `file_create()` is vectorised, so I can pass the `word_paths` vector to create empty files corresponding to each path listed:

```{r}
file_create(lorem_paths)
```

To see what files we've created, I can use `dir_ls()` to return a vector containing all the file names within a specified folder:

```{r}
dir_ls("lorem")
```

Okay, that's nice, but I don't actually want a folder full of empty files. So let's delete the folder and everything in it. That's easy enough to do with `dir_delete()`

```{r}
dir_delete("lorem")
```

Alternatively, if I wanted only to delete some of the files I could have used `file_delete()`


## File trees

```{r}
lorem_dirs <- unique(stringr::str_remove(names(lorem), "^.*_"))
lorem_dirs
```

```{r}
dir_create("lorem")
dir_create(path("lorem", lorem_dirs))
```

```{r}
dir_tree("lorem")
```

```{r}
lorem_paths <- path(
  "lorem", 
  stringr::str_remove(names(lorem), "^.*_"), 
  names(lorem)
)
lorem_paths
```

```{r}
purrr::walk(
  seq_along(lorem),
  \(x) brio::write_lines(
    text = lorem[[x]],
    path = lorem_paths[x]
  )
)
```

```{r}
dir_tree("lorem")
```

```{r}
#| include: false
options(width = very_wide)
```

```{r}
#| column: screen-inset
dir_info("lorem", recurse = TRUE)
```

```{r}
#| include: false
options(width = narrow)
```


```{r}
files <- dir_ls("lorem", recurse = TRUE, type = "file")
```

```{r}
path_file(files)
```

```{r}
path_abs(files)
```

```{r}
path_split(files)
```


```{r}
file_size(files)
```
