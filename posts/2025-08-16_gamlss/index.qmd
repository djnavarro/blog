---
title: "gamlss"
description: "This is a subtitle"
date: "2025-08-16"
knitr:
  opts_chunk: 
    dev.args:
      bg: "#00000000"
--- 

<!--------------- my typical setup ----------------->

```{r}
#| label: setup
#| include: false
very_wide <- 500
wide <- 136
narrow <- 76
options(width = narrow)
cache_images <- TRUE
set.seed(1)

theme_custom <- function() {

  transparent_rect <- ggplot2::element_rect(fill = NA, color = NA)
  grey_text <- ggplot2::element_text(color = "#888")
  rotated_grey_text <- ggplot2::element_text(color = "#888", angle = 90)
  light_grey_rect <- ggplot2::element_rect(fill = "#ccc", color = "#ccc")

  plot_margin <- ggplot2::margin(18, 18, 18, 18)

  strip_margin <- ggplot2::margin(4.4, 4.4, 4.4, 4.4)
  strip_background <- ggplot2::element_rect(fill = "#333", color = "#333")
  strip_text <- ggplot2::element_text(colour = "#ddd", margin = strip_margin)

  ggplot2::`%+replace%`(
    ggplot2::theme_bw(),
    ggplot2::theme(

      # plot exterior regions
      plot.margin = plot_margin,
      plot.background   = transparent_rect,
      legend.background = transparent_rect,
      legend.key        = light_grey_rect,
      plot.title    = grey_text,
      plot.subtitle = grey_text,
      plot.caption  = grey_text,
      axis.text.x   = grey_text,
      axis.text.y   = grey_text,
      axis.title.x  = grey_text,
      axis.title.y  = rotated_grey_text, 
      legend.text   = grey_text,
      legend.title  = grey_text,

      # plot strip region
      strip.background = strip_background,
      strip.text = strip_text,

      # plot interior background
      panel.background = light_grey_rect
    ) 
  )
}
ggplot2::theme_set(theme_custom())
```

<!--------------- post begins here ----------------->

Okay, so in my [last post](/posts/2025-08-02_box-cox-power-exponential/) I was whining about the Box-Cox power exponential distribution, and promising that it would be followed by a new post whining about the [generalised additive model for location, shape and scale](https://en.wikipedia.org/wiki/Generalized_additive_model_for_location,_scale_and_shape) (GAMLSS). This is that post.

```{r}
#| label: load-packages
#| message: false
library(fs)
library(dplyr)
library(purrr)
library(haven)
library(readr)
library(tidyr)
library(gamlss)
library(tibble)
library(ggplot2)
library(quartose)
library(rprojroot)
```

```{r}
#| label: directories
proj_root  <- find_root_file(criterion = has_file(".here"))
local_dir  <- path(proj_root, "nhanes")
data_dir   <- path(local_dir, "data")
output_dir <- path(local_dir, "output")
```

## NHANES

The NHANES [body measurements](https://wwwn.cdc.gov/nchs/nhanes/search/datapage.aspx?Component=Examination) and [demographics](https://wwwn.cdc.gov/nchs/nhanes/search/datapage.aspx?Component=Demographics) data sets. Brief summaries here:

```{r}
#| results: asis
#| message: false
#| label: nhanes-metadata
metadata <- list( 
  BMX  = read_csv(path(local_dir, "bmx-summary.csv"), show_col_types = FALSE),
  DEMO = read_csv(path(local_dir, "demo-summary.csv"), show_col_types = FALSE) 
)

quarto_tabset(metadata, level = 3)
```

Import the data:

```{r}
#| label: nhanes-import
# all demographics and body measurement files
demo_files <- dir_ls(path(data_dir, "demo"))
bmx_files  <- dir_ls(path(data_dir, "bmx"))

# read demographics file (selected variables only)
demos <- demo_files |> 
  map(\(xx) {
    dd <- read_xpt(xx) 
    if (!exists("RIDEXAGM", where = dd)) dd$RIDEXAGM <- NA_real_
    dd <- select(dd, SEQN, RIAGENDR, RIDAGEYR, RIDAGEMN, RIDEXAGM)
    dd
  }) |> 
  bind_rows(.id = "file_demo") |> 
  mutate(file_demo = path_file(file_demo)) |>
  left_join(metadata$DEMO, by = "file_demo") |>
  select(-description)

# read body measurements file (selected variables only)
bmxes <- bmx_files |> 
  map(\(xx) {
    dd <- read_xpt(xx) 
    dd <- select(dd, SEQN, BMXWT, BMXHT, BMXRECUM)
    dd
}) |> 
  bind_rows(.id = "file_bmx") |> 
  mutate(file_bmx = path_file(file_bmx)) |>
  left_join(metadata$BMX, by = "file_bmx") |>
  select(-description)

# join data sets, retaining only those rows where the
# required body measurements exist, and use nicer names
nhanes <- bmxes |>
  left_join(demos, by = c("SEQN", "cohort")) |>
  select(
    id          = SEQN,
    sex_s       = RIAGENDR, # sex/gender at screen (1 = M, 2 = F, . = NA)
    weight_kg_e = BMXWT,    # weight at exam
    height_cm_e = BMXHT,    # standing height at exam
    length_cm_e = BMXRECUM, # recumbent length at exam (0-47 months only)
    age_yr_s    = RIDAGEYR, # natal age at screening (years)
    age_mn_s    = RIDAGEMN, # natal age at screening (months; 0-24 mos only)
    age_mn_e    = RIDEXAGM, # natal age at exam (months; 0-19 years only)
    cohort
  )

# recumbent length and standing height are not equivalent; in the NHANES
# data when both are present for the same person, length is 1.02cm greater
# than height; in this context, a simple adjustment will suffice
length_to_height <- function(length_cm, adjust = 1.02) {
  length_cm - adjust
}

# additional preprocessing
nhanes <- nhanes |>
  mutate(
    sex_num = sex_s - 1, # rescale to 0 = M, 1 = F
    sex_fct = factor(sex_s, levels = 1:2, labels = c("male", "female")),
    age_mn = case_when(
      !is.na(age_mn_e) ~ age_mn_e, # use exam months if present
      !is.na(age_mn_s) ~ age_mn_s, # else use survey months
      TRUE ~ (age_yr_s * 12)       # else use age in years
    ),
    age_yr    = age_mn / 12,
    weight_kg = weight_kg_e,
    height_cm = case_when(
      !is.na(height_cm_e) ~ height_cm_e, # use height if it was measured
      !is.na(length_cm_e) ~ length_to_height(length_cm_e), # or convert length
      TRUE ~ NA_real_, # else missing
    )
  )

# retain only the to-be-used columns, and only those cases for which
# age, weight, height, and sex are all present; filter to age < 80
# because NHANES uses "80" to mean "80 and above" so the actual age
# is not known
ok <- function(x) !is.na(x)
nhanes <- nhanes |>
  select(id, sex_num, sex_fct, weight_kg, height_cm, age_mn, age_yr, cohort) |>
  filter(ok(sex_num), ok(weight_kg), ok(height_cm), ok(age_mn)) |>
  filter(age_yr < 80)

nhanes
```


## GAMLSS

### Estimation

```{r}
# maximum age used in gamlss modelling; this restriction is
# to ensure that the gamlss models are well-behaved over
# the age range of most interest (i.e. pediatric)
age_max_yr <- 40

# subsets used for gamlss training
nhanes_m <- nhanes |> filter(sex_fct == "male", age_yr <= age_max_yr)
nhanes_f <- nhanes |> filter(sex_fct == "female", age_yr <= age_max_yr)

# gamlss settings that turned out not to matter much in this case
opt_control <- gamlss.control(c.crit = .001, n.cyc = 250)
```


```{r}
#| label: gamlss-height-models
#| eval: false
ht_m <- gamlss(
  formula       = height_cm ~ ps(age_mn),
  sigma.formula = ~ps(age_mn),
  nu.formula    = ~1,
  tau.formula   = ~1,
  data    = nhanes_m,
  family  = BCPE,
  control = opt_control
)

ht_f <- gamlss(
  formula       = height_cm ~ ps(age_mn),
  sigma.formula = ~ps(age_mn),
  nu.formula    = ~1,
  tau.formula   = ~1,
  data    = nhanes_f,
  family  = BCPE,
  control = opt_control
)
```

```{r}
#| label: gamlss-weight-models
#| eval: false
wt_htm <- gamlss(
  formula       = weight_kg ~ ps(age_mn) + height_cm + ps(age_mn):height_cm,
  sigma.formula = ~ps(age_mn),
  nu.formula    = ~1,
  tau.formula   = ~1,
  data    = nhanes_m,
  family  = BCPE,
  control = opt_control
)

wt_htf <- gamlss(
  formula       = weight_kg ~ ps(age_mn) + height_cm + ps(age_mn):height_cm,
  sigma.formula = ~ps(age_mn),
  nu.formula    = ~1,
  tau.formula   = ~1,
  data    = nhanes_f,
  family  = BCPE,
  control = opt_control
)
```

```{r}
#| label: gamlss-objects
#| results: asis
ht_m   <- readRDS(path(output_dir, "ht-m-v03.rds"))
ht_f   <- readRDS(path(output_dir, "ht-f-v03.rds"))
wt_htm <- readRDS(path(output_dir, "wt-htm-v03.rds"))
wt_htf <- readRDS(path(output_dir, "wt-htf-v03.rds"))

mod <- list(
  ht_m = ht_m,
  ht_f = ht_f,
  wt_htm = wt_htm,
  wt_htf = wt_htf
)

quarto_tabset(mod, level = 3)
```

### Quantiles

```{r}
#| label: height-quantiles
get_predictors <- function(model) {
  outcome <- deparse(model$mu.formula[[2]])
  all_vars <- unique(c(
    all.vars(model$mu.formula),
    all.vars(model$sigma.formula),
    all.vars(model$nu.formula),
    all.vars(model$tau.formula)
  )) 
  setdiff(all_vars, outcome)
}

get_pars <- function(data, model) {
  pars <- tibble(
    mu    = predict(model, newdata = data, type = "response", what = "mu"),
    sigma = predict(model, newdata = data, type = "response", what = "sigma"),
    nu    = predict(model, newdata = data, type = "response", what = "nu"),
    tau   = predict(model, newdata = data, type = "response", what = "tau"),
  )
  bind_cols(data, pars)
}

predict_cases_ht <- expand_grid(
  age_mn  = 1:(age_max_yr * 12),
  sex_fct = factor(c("male", "female"))
)

predict_pars_ht <- bind_rows(
  predict_cases_ht |> filter(sex_fct == "male") |> get_pars(ht_m),
  predict_cases_ht |> filter(sex_fct == "female") |> get_pars(ht_f)
)

predict_quantiles_ht <- predict_pars_ht |>
  mutate(
    q05 = qBCPE(.05, mu = mu, sigma = sigma, nu = nu, tau = tau),
    q25 = qBCPE(.25, mu = mu, sigma = sigma, nu = nu, tau = tau),
    q50 = qBCPE(.50, mu = mu, sigma = sigma, nu = nu, tau = tau),
    q75 = qBCPE(.75, mu = mu, sigma = sigma, nu = nu, tau = tau),
    q95 = qBCPE(.95, mu = mu, sigma = sigma, nu = nu, tau = tau)
  )

predict_quantiles_ht
```

```{r}
#| label: height-quantiles-plot
#| fig-width: 8
#| fig-height: 6
ggplot() + 
  geom_point(
    data = nhanes |> filter(age_yr < age_max_yr), 
    mapping = aes(age_mn, height_cm),
    size = .25
  ) +
  geom_path(
    data = predict_quantiles_ht |> 
      pivot_longer(
        cols = starts_with("q"),
        names_to = "quantile",
        values_to = "height_cm"
      ),
    mapping = aes(age_mn, height_cm, color = quantile)
  ) +
  facet_wrap(~sex_fct) +
  theme(legend.position = "bottom")
```

Okay, that's nice but you might argue that the GAMLSS modelling is overkill here. The distribution of heights conditional on age and sex is fairly close to normal, and in any case we have about 100k rows in the data set spanning the full range of ages. However, it's not too hard to construct a case where you really do need the model.

We can take the logic further and predict the distribution of weights for very tall (99th height percentile) and short (1st height percentile) people, stratified by age and sex. It's a nice illustration of where the GAMLSS framework is useful even when you have a lot of data: as good as it is, the NHANES data become very sparse when you start focusing on very thin slices through the tails of the distributions. 

```{r}
predict_cases_wt <- predict_pars_ht |>
  mutate(
    very_tall  = qBCPE(.99, mu = mu, sigma = sigma, nu = nu, tau = tau),
    very_short = qBCPE(.01, mu = mu, sigma = sigma, nu = nu, tau = tau)
  ) |> 
  pivot_longer(
    cols = c(very_tall, very_short),
    names_to = "height_fct", 
    values_to = "height_cm"
  ) |> 
  mutate(height_fct = factor(height_fct)) |> 
  select(age_mn, sex_fct, height_fct, height_cm)

predict_cases_wt

predict_pars_wt <- bind_rows(
  predict_cases_wt |> filter(sex_fct == "male") |> select(-height_fct) |> get_pars(wt_htm),
  predict_cases_wt |> filter(sex_fct == "female") |> select(-height_fct) |> get_pars(wt_htf)
) |> 
  left_join(predict_cases_wt, by = join_by(age_mn, sex_fct, height_cm)) |> 
  relocate(height_fct, .before = height_cm)

predict_quantiles_wt <- predict_pars_wt |>
  mutate(
    q05 = qBCPE(.05, mu = mu, sigma = sigma, nu = nu, tau = tau),
    q25 = qBCPE(.25, mu = mu, sigma = sigma, nu = nu, tau = tau),
    q50 = qBCPE(.50, mu = mu, sigma = sigma, nu = nu, tau = tau),
    q75 = qBCPE(.75, mu = mu, sigma = sigma, nu = nu, tau = tau),
    q95 = qBCPE(.95, mu = mu, sigma = sigma, nu = nu, tau = tau)
  )

predict_quantiles_wt
```

```{r}
permitted <- predict_cases_wt |> 
  mutate(
    height_cm_lo = height_cm * 0.99, 
    height_cm_hi = height_cm * 1.01
  ) |> 
  select(age_mn, sex_fct, height_fct, height_cm_lo, height_cm_hi)

match_rules <- join_by(
  x$sex_fct == y$sex_fct, 
  x$age_mn == y$age_mn, 
  x$height_cm > y$height_cm_lo, 
  x$height_cm < y$height_cm_hi
)

nhanes_very_short <- semi_join(
  x = nhanes, 
  y = permitted |> filter(height_fct == "very_short"),
  by = match_rules
)

nhanes_very_tall <- semi_join(
  x = nhanes, 
  y = permitted |> filter(height_fct == "very_tall"),
  by = match_rules
)

nhanes_partial <- bind_rows(
  very_short = nhanes_very_short,
  very_tall = nhanes_very_tall,
  .id = "height_fct"
) |> mutate(height_fct = factor(height_fct))

nhanes_partial
```

```{r}
#| label: weight-quantiles-plot
#| fig-width: 8
#| fig-height: 10
ggplot() + 
  geom_point(
    data = nhanes_partial, 
    mapping = aes(age_mn, weight_kg),
    size = .5
  ) +
  geom_path(
    data = predict_quantiles_wt |> 
      pivot_longer(
        cols = starts_with("q"),
        names_to = "quantile",
        values_to = "weight_kg"
      ),
    mapping = aes(age_mn, weight_kg, color = quantile),
    linewidth = 1
  ) +
  facet_grid(height_fct ~ sex_fct) +
  theme(legend.position = "bottom")

```

Works better than I would have expected. Note that the slight "clumpiness" of the NHANES data is partially tied to the slight misfit in the model at ~12 years. The data flatten out slightly faster than the model predictions, which has the effect that the curves are slightly below the data at that specific age. So if we slice through the data based on model-predicted 99th percentile, there will be more actual 12 year olds selected than other age groups.

### Sampling 

Sample height conditional on `age`, using an appropriate (sec-specific) gamlss model `ht_mod`. Similarly, we can sample weight conditional on `age` and `height` using a model. Note the use of a trimmed Box-Cox power-exponential: even with nu/tau parameters, the BCPE has support on non-biological values in the tails creating physically impossible outliers in large simulations. The default trim is 0.25% on either side, as compared to 3% for `nhanesgamlss::simwtage()`. 
  

```{r}
sample_hw <- function(age_mn, sex_fct, mod) {

  rTBCPE <- function(n, mu, sigma, nu, tau, trim = .0025) {
    p <- runif(n, min = trim, max = 1 - trim)
    if (any(mu <= 0)) mu[mu <= 0] <- 1E-6
    if (any(sigma <= 0)) sigma[sigma <= 0] <- 1E-6
    r <- qBCPE(p, mu = mu, sigma = sigma, nu = nu, tau = tau)
    r
  }
  sample_h <- function(age_mn, ht_mod) {
    tibble(age_mn) |> 
      get_pars(model = ht_mod) |> 
      select(mu, sigma, nu, tau) |> 
      pmap_dbl(\(mu, sigma, nu, tau) rTBCPE(n = 1, mu, sigma, nu, tau))
  }
  sample_w <- function(age_mn, height_cm, wt_mod) {
    tibble(age_mn, height_cm) |>
      get_pars(model = wt_mod) |> 
      select(mu, sigma, nu, tau) |> 
      pmap_dbl(\(mu, sigma, nu, tau) rTBCPE(n = 1, mu, sigma, nu, tau))
  }

  height_cm <- weight_kg <- numeric(length(age_mn))
  mm <- sex_fct == "male"
  ff <- sex_fct == "female"

  if (any(mm)) height_cm[mm] <- sample_h(age_mn[mm], mod$ht_m)
  if (any(ff)) height_cm[ff] <- sample_h(age_mn[ff], mod$ht_f)  
  if (any(mm)) weight_kg[mm] <- sample_w(age_mn[mm], height_cm[mm], mod$wt_htm)
  if (any(ff)) weight_kg[ff] <- sample_w(age_mn[ff], height_cm[ff], mod$wt_htf)
  
  tibble(age_mn, sex_fct, height_cm, weight_kg)
}
```


```{r}
nhanes_fit <- bind_rows(nhanes_m, nhanes_f) |> arrange(age_mn)

age_band <- function(age_mn) {
  factor(
    x = case_when(
      age_mn <= 12                 ~ 1,
      age_mn >  12 & age_mn <=  24 ~ 2,
      age_mn >  24 & age_mn <=  72 ~ 3,
      age_mn >  72 & age_mn <= 144 ~ 4,
      age_mn > 144 & age_mn <= 216 ~ 5,
      age_mn > 216                 ~ 6
    ),
    levels = 1:6,
    labels = c(
      "<1 year",
      "1-2 years",
      "2-6 years",
      "6-12 years",
      "12-18 years",
      ">18 years"
    )
  )
}

pop <- bind_rows(
  gamlss = sample_hw(nhanes_fit$age_mn, nhanes_fit$sex_fct, mod = mod),
  nhanes = nhanes_fit |> select(age_mn, sex_fct, height_cm, weight_kg),
  .id = "source"
) |> mutate(age_band_fct = age_band(age_mn))

pop
```

```{r}
#| label: height-weight-age-band-scatterplot
#| fig-width: 8
#| fig-height: 10
pop |>
  ggplot(aes(height_cm, weight_kg, color = sex_fct)) + 
  geom_point(size = .25, alpha = .5) +
  facet_grid(age_band_fct ~ source, scales = "free_y") +
  theme(legend.position = "bottom")
```

Once again this is a neat example, but it's mostly a validation of the GAMLSS model: it shows us the model does allow us to sample from the joint conditional density $P(\mbox{weight}, \mbox{height} | \mbox{age}, \mbox{sex})$. But by design the GAMLSS samples in `pop` are matched to the NHANES data on age and sex. Anything that we could do with the GAMLSS samples is something that we could have done with the NHANES samples directly. 


```{r}
#| label: bsa-computation
compute_bsa <- function(height, weight, method = "dubois") {

  w <- weight # numeric (kg)
  h <- height # numeric (cm)

  # Du Bois D, Du Bois EF (Jun 1916). "A formula to estimate the approximate
  # surface area if height and weight be known". Archives of Internal Medicine
  # 17 (6): 863-71. PMID 2520314.
  if (method == "dubois") return(0.007184 * w^0.425 * h^0.725)

  # Mosteller RD. "Simplified calculation of body-surface area". N Engl J Med
  # 1987; 317:1098. PMID 3657876.
  if (method == "mosteller") return(0.016667 * w^0.5 * h^0.5)

  # Haycock GB, Schwartz GJ, Wisotsky DH "Geometric method for measuring body
  # surface area: A height-weight formula validated in infants, children and
  # adults" J Pediatr 1978, 93:62-66.
  if (method == "haycock") return(0.024265 * w^0.5378 * h^0.3964)

  # Gehan EA, George SL, Cancer Chemother Rep 1970, 54:225-235
  if (method == "gehan") return(0.0235 * w^0.51456 * h^0.42246)

  # Boyd, Edith (1935). The Growth of the Surface Area of the Human Body.
  # University of Minnesota. The Institute of Child Welfare, Monograph Series,
  # No. x. London: Oxford University Press
  if (method == "boyd") return(0.03330 * w^(0.6157 - 0.0188 * log10(w)) * h^0.3)

  # Fujimoto S, Watanabe T, Sakamoto A, Yukawa K, Morimoto K. Studies on the
  # physical surface area of Japanese. 18. Calculation formulae in three stages
  # over all ages. Nippon Eiseigaku Zasshi 1968;5:443-50.
  if (method == "fujimoto") return(0.008883 * w^0.444 * h^0.663)

  rlang::abort("unknown BSA method")
}
```

```{r}
#| label: height-weight-bsa-scatterplot
#| fig-width: 8
#| fig-height: 10
bsa_cutoff <- tibble(
  height_cm = 60:110,
  dubois  = (0.5 / 0.007184 / (height_cm^0.725)) ^ (1/0.425),
  haycock = (0.5 / 0.024265 / (height_cm^0.3964)) ^(1/0.5378)
) |> 
  pivot_longer(
    cols = c(dubois, haycock),
    names_to = "method",
    values_to = "weight_kg"
  )

bsa_pop <- pop |> 
  select(age_mn, age_band_fct, height_cm, weight_kg, sex_fct, source) |>
  filter(age_mn <= 72) |>
  mutate(
    bsa_m2_dubois  = compute_bsa(height_cm, weight_kg, method = "dubois"),
    bsa_m2_haycock = compute_bsa(height_cm, weight_kg, method = "haycock")
  ) |>
  filter(bsa_m2_dubois > 0.5) 
 
ggplot() + 
  geom_point(
    data = bsa_pop,
    mapping = aes(height_cm, weight_kg), 
    size = .25
  ) +
  geom_path(
    data = bsa_cutoff,
    mapping = aes(height_cm, weight_kg, linetype = method)
  ) +
  facet_grid(age_band_fct ~ source, scales = "free_y") +
  theme(legend.position = "bottom")
``` 

```{r}
cases <- expand_grid(
  age_mn  = 1:24,
  sex_fct = factor(c("male", "female"))
)
bsa_pop_2 <- sample_hw(
  age_mn  = rep(cases$age_mn, 10000),
  sex_fct = rep(cases$sex_fct, 10000),
  mod = mod 
) |> 
  mutate(
    id = row_number(),
    bsa_m2_dubois  = compute_bsa(height_cm, weight_kg, method = "dubois"),
    bsa_m2_haycock = compute_bsa(height_cm, weight_kg, method = "haycock"),
    threshold = case_when(
      bsa_m2_dubois >  .5 & bsa_m2_haycock >  .5 ~ "above both",
      bsa_m2_dubois >  .5 & bsa_m2_haycock <= .5 ~ "above dubois only",
      bsa_m2_dubois <= .5 & bsa_m2_haycock >  .5 ~ "above haycock only",
      bsa_m2_dubois <= .5 & bsa_m2_haycock <= .5 ~ "below both",
    )
  ) |> 
  relocate(id, 1)
bsa_pop_2
```


```{r}
#| label: height-weight-bsa-scatterplot-detailed
#| fig-width: 8
#| fig-height: 12
ggplot() + 
  geom_point(
    data = bsa_pop_2,
    mapping = aes(height_cm, weight_kg, color = threshold), 
    alpha = .25, 
    shape = ".",
    show.legend = FALSE
  ) +
  geom_path(
    data = bsa_cutoff,
    mapping = aes(height_cm, weight_kg, linetype = method)
  ) +
  facet_wrap(~ age_mn, ncol = 4) +
  theme(legend.position = "bottom")
```


```{r}
#| label: bsa-method-comparison
#| fig-width: 8
#| fig-height: 6
bsa_pop_2 |> 
  summarise(
    dubois_0.4  = mean(bsa_m2_dubois > 0.4),
    dubois_0.5  = mean(bsa_m2_dubois > 0.5),
    dubois_0.6  = mean(bsa_m2_dubois > 0.6),
    haycock_0.4 = mean(bsa_m2_haycock > 0.4),
    haycock_0.5 = mean(bsa_m2_haycock > 0.5),
    haycock_0.6 = mean(bsa_m2_haycock > 0.6),
    .by = age_mn
  ) |> 
  pivot_longer(
    cols = c(
      starts_with("dubois"), 
      starts_with("haycock")
    ),
    names_to = "group",
    values_to = "percent_above_threshold"
  ) |> 
  separate(
    col = group, 
    into = c("method", "threshold"), 
    sep = "_"
  ) |> 
  mutate(threshold = paste("BSA >", threshold, "m^2")) |> 
  ggplot(aes(
    x = age_mn, 
    y = percent_above_threshold, 
    linetype = method, 
    shape = method
  )) +
  scale_y_continuous(label = scales::label_percent()) +
  scale_x_continuous(breaks = seq(0, 24, 6)) +
  geom_path() +
  geom_point() +
  facet_wrap(~threshold) +
  theme(legend.position = "bottom")
```

