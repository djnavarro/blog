---
title: "regex-backreferences"
description: "This is a subtitle"
date: "2024-11-26"
--- 

<!--------------- my typical setup ----------------->

```{r}
#| label: setup
#| include: false
very_wide <- 500
wide <- 136
narrow <- 76
options(width = narrow)
cache_images <- TRUE
set.seed(1)
```

```{r}
highlight <- function(x) {
  stringr::str_replace_all(
    string = x,
    pattern = "\\<([^<>]+)\\>", 
    #replacement = "\\1", 
    #replacement = "\n\n:::{style='color:blue'} \\1 \n:::" 
    replacement = "<span style='color:#008080'>&lt;\\1&gt;</span>"
  )
}

knitr::knit_hooks$set(
  output = function(x, options) {
    if (options$highlight == TRUE) {
      return(c("<pre>", highlight(x), "</pre>"))
    } 
    c("<pre>", x, "</pre>")
  }
)

knitr::opts_chunk$set(highlight = TRUE)

#base_hook <- knitr::knit_hooks$get("output")
```

<!--------------- post begins here ----------------->

Regular expressions are the bane of my existence. They are everything I hate about programming. They are the very apotheosis of "taking a concept that makes sense and making it utterly incomprehensible to save a few keystrokes". They are the *worst*.

No, I do not want to hear your argument for why they're actually great.

```{r}
feather <- brio::read_lines("feather.txt")
cat(feather[1:10], sep = "\n")
```

## The regex

```{r}
library(stringr)
```

Match a specific sequence of characters

```{r}
str_view(feather, "do")
```

Oh right, actually we would like to match "Do" or "do":

```{r}
str_view(feather, "[Dd]o")
```

Ah well, we really only want to match "do-do" but not "do" or "done"

```{r}
str_view(feather, "[Dd]o-[Dd]o")
```

But wait, now we catch "do-do" but not "do-do-do"

```{r}
str_view(feather, "([Dd]o)(-\\1)+")
```

Ah, so maybe it needs to be this then:

```{r}
str_view(feather, "([Dd]o)(-[Dd]o)+")
```

## Replace

```{r}
feather |> 
  str_replace_all("([Dd]o)(-[Dd]o)+", "ðŸŽ¶") |> 
  head(n = 20) |> 
  cat(sep = "\n")
```

## Extract

How to mimic `str_extract()` in base?

This isn't quite what we want:

```{r}
#grep("([0-9])\\1{2}", convo, value = TRUE)
```

Closer, but not quite:

```{r}
#regmatches(convo, regexpr("([0-9])\\1{2}", convo))
```

To return a match or `NA`:

```{r}
base_extract <- function(string, pattern) {
  m <- regexpr(pattern, string)
  v <- regmatches(string, m)
  out <- rep(NA_character_, length(string))
  out[which(m > 0)] <- v
  out
}
#base_extract(convo, "([0-9])\\1{2}")
```

## Replace

```{r}
#str_replace(convo, "([0-9])\\1{2}", "***")
```

```{r}
#gsub("([0-9])\\1{2}", "***", convo)
```


