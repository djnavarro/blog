---
title: "Bayesian Emax regression using brms"
description: "This is a draft post, please do not cite or share yet"
date: "2025-06-14"
draft: true
draft-mode: unlinked
--- 

<!--------------- my typical setup ----------------->

```{r}
#| label: setup
#| include: false
very_wide <- 500
wide <- 136
narrow <- 76
options(width = narrow)
cache_images <- TRUE
set.seed(1)


# https://blog.djnavarro.net/posts/2021-04-18_pretty-little-clis/
ansi_aware_handler <- function(x, options) {
  paste0(
    "<pre class=\"r-output\"><code>",
    fansi::sgr_to_html(x = x, warn = FALSE, term.cap = "256"),
    "</code></pre>"
  )
}

knitr::knit_hooks$set(
  output = ansi_aware_handler,
  message = ansi_aware_handler,
  warning = ansi_aware_handler,
  error = ansi_aware_handler
)

options(crayon.enabled = TRUE)
```

<!--------------- post begins here ----------------->

This is another in the ongoing series of posts I've written on [pharmacometrics](/#category=Pharmacometrics), and more specifically on the Emax framework for modelling exposure-response (ER) relationships (previous Emax posts are [here](/posts/2024-01-09_emax-models/) and [here](/posts/2024-11-11_emax-parameters/)). I've been focusing on Emax ER models for two reasons: (1) I do a lot of ER analysis in my job and Emax models are a very handy addition to the ER toolkit, and (2) I've been collaborating with Kenta Yoshida on some updates to the [rstanemax](https://yoshidk6.github.io/rstanemax/) package,^[For those in pharmacometrics-land who have noticed Kenta's recent work on the [BayesERtools](https://mc-stan.org/docs/stan-users-guide/latent-discrete.html) package and the [BayesERbook](https://genentech.github.io/BayesERbook/) guide... yes, Kenta has kindly extended an invitation for me to assist with those too, and this post has indeed been written in service of that work.] and to that end I've been diving into the tooling that exists within R for using these models. 

In this post, I'll talk about implementing Emax regression models within the lovely [brms](https://paulbuerkner.com/brms/) package. Like anyone in Bayes-land who hasn't been living under a rock, I've followed Paul BÃ¼rkner's fabulous work on brms with interest for many years, but it is only in my new life as a pharmacometrician that I've found an excuse to put it to good use.^[This might seem odd given that in my former professional life I was an [academic mathematical psychologist](https://papers.djnavarro.net/), and brms is well-equipped to handle classic psychometric tools like IRT models and math psych models like Weiner diffusion, but my specific field of work tended to force me to run head-first into the nightmare of [latent discrete parameters](https://mc-stan.org/docs/stan-users-guide/latent-discrete.html), which limited the usefulness of stan for me. Happily for me, this is rarely an issue in pharmacometrics, so I have now joined the Church of the No U-Turn Sampler and offer up my daily prayers to Our Lady of the Hamiltonian Monte Carlo like all the other Bayesian girls.]

```{r}
#| label: packages
#| message: false
library(brms)
library(dplyr)
library(tidyr)
library(tibble)
library(ggplot2)
library(tidybayes)
```

```{r}
if (require(cmdstanr)) {
  # prefer cmdstanr and cache binaries
  options(
    brms.backend = "cmdstanr", 
    cmdstanr_write_stan_file_dir = "_brms-cache"
  )
  dir.create("_brms-cache", FALSE)
} else {
  rstan::rstan_options(auto_write = TRUE)
}
```


## Continuous response

I'll start by considering the simplest case: a simple Emax regression model for a continuous response variable, with no covariates. First, the formalism. Letting $\phi_i$ denote^[Using $\phi_i$ here is not standard notation, and insofar as exposure is treated as a predictor for the response (as it is in the logistic regression context) you can think of it statistically in the same way you would a covariate. That would suggest that $x_i$ would be a sensible notation choice, but it is a little misleading. From a scientific perspective exposure-response modelling treats exposure as a qualitatively different entity to the covariates, and within the Emax regression framework in particular exposure is structurally different to other covariates. As such it seems sensible to use a distinct symbol.] the observed exposure for the $i$-th subject, and letting $y_i$ denote the observed response, the Emax model for a continuous response is written as follows:

$$
y_i = E_0 + E_{max} \frac{\phi_i^\gamma}{EC_{50}^\gamma + \phi_i^\gamma} + \epsilon_i 
$$

where $\epsilon_i \sim \mbox{Normal}(0, \sigma^2)$ supplies the measurement model for the data set. The (nonlinear) predictor function in an Emax regression is described by four parameters:

- $E_0$ is represents the baseline response when drug exposure is zero
- $E_{max}$ defines the maximum change from baseline as the drug exposure increases
- $EC_{50}$ defines the exposure at which the change from baseline is 50% of the maximum
- $\gamma$ is the Hill coefficient, and describes the steepness of the response curve. In the regular version of the Emax model (sometimes called the "hyperbolic" Emax model) we fix $\gamma = 1$, and for the purposes of this post I'll make this restriction rather than use the full "sigmoidal" Emax model

In addition, the "iid Gaussian error" measurement model implies a fifth parameter:

- $\sigma^2$ is the residual variance that describes the amount of measurement error in the data

### Simulated data

Simulating semi-plausible data sets for exposure-response analysis isn't trivial when you don't have a properly specified pharmacokinetic (PK) model under the hood, but if we make a few simplifying assumptions it's not too difficult. I talked about this in [an earlier blog post](/posts/2024-11-11_emax-parameters/), so I won't repeat myself here. Instead, I'll wrap everything in a `make_continuous_data()` function here:

::: {.callout-caution collapse="true" appearance="minimal" title="Click to see the code"}

```{r}
#| label: continuous-data
emax_fn <- function(exposure, emax, ec50, e0, gamma = 1, ...) {
  e0 + emax * (exposure ^ gamma) / (ec50 ^ gamma + exposure ^ gamma)
}

make_continuous_data <- function(seed = 123) {
  
  set.seed(seed)
  
  # exposures are assumed to be slightly-truncated log-normal distributed
  # variates, and scale linearly with dose
  generate_exposure <- function(dose, n, meanlog = 4, sdlog = 0.5) {
    dose * qlnorm(
      p = runif(n, min = .01, max = .99), 
      meanlog = meanlog,
      sdlog = sdlog
    )
  }
  
  # for simplicity, continuous covariates presumed to be 
  generate_covariate <- function(n) {
    rbeta(n, 2, 2) * 10
  }
  
  make_data <- function(dose, n, par) {
    tibble(
      
      # exposure depends on dose, of course
      dose = dose, 
      exposure = generate_exposure(max(dose, .01), n = n), 
      
      # covariates
      cov_a = generate_covariate(n = n),
      cov_b = generate_covariate(n = n),
      cov_c = generate_covariate(n = n),
      
      # response is an emax function of exposure plus covariate model
      response = emax_fn(
        exposure,
        emax = par$emax, 
        ec50 = par$ec50, 
        e0 = par$e0, 
        gamma = par$gamma
      ) + 
        par$coef_a * cov_a + 
        par$coef_b * cov_b + 
        par$coef_c * cov_c + 
        rnorm(n, 0, par$sigma)
    )
  }
  
  # parameters governing the whole thing
  par <- list(
    emax   = 10, 
    ec50   = 4000, 
    e0     = 5,
    gamma  = 1,
    sigma  = .6,
    coef_a = .3,
    coef_b = .2,
    coef_c = 0
  )
  
  # simulate a simple experiment with three dose groups
  dat <- bind_rows(
    make_data(dose = 100, n = 100, par = par),  
    make_data(dose = 200, n = 100, par = par),
    make_data(dose = 300, n = 100, par = par)
  ) 
  
  return(dat)
}
```

:::

Using this function we can simulate a data set suitable for Emax regression with a continuous response. In addition to the continuous `exposure` and `response` variables, the data set contains three three continuous covariates that could potentially be related to the response:

```{r}
continuous_data <- make_continuous_data()
continuous_data
```

In this data set I'm being deliberately vague about the specific `exposure` metric under consideration, and similarly vague about the nature of the covariates (`cov_a`, `cov_b`, and `cov_c`) and the `response` variable. The data set isn't meant to represent a real-life scenario, after all. But to give you a general sense of what the simulated data set looks like, here are some scatter plots depicting how the response variable is related to exposure and to the three covariates in the data set:

```{r}
#| fig-height: 8
#| fig-width: 8
continuous_data |> 
  pivot_longer(
    cols = c(exposure, cov_a, cov_b, cov_c), 
    names_to = "variable",
    values_to = "value"
  ) |> 
  ggplot(aes(value, response)) + 
  geom_point() + 
  geom_smooth(formula = y ~ x, method = "loess") + 
  facet_wrap(~ variable, scales = "free_x") + 
  theme_bw()
```

At a quick glance it's clear that `exposure` is related to `response` (as one would hope), but it also seems clear that the response is related to `cov_a` and possibly also `cov_b`. Some modelling will be required to disentangle these effects.

### Simple Emax regression

In the first instance, we'll ignore the covariates entirely and focus only on the relationship between `exposure` and `response`. To build an Emax regression model within brms we have to specify three components: the model formula, the measurement model, and the parameter priors. I'll discuss each of these in turn.

The first step in the model building process is describing the nonlinear predictor function. We do this in brms using the `brmsformula()` function, or just `bf()` if we want to use the shorthand:^[My personal preference is to use `brmsformula()`. In general I prefer informative function names, even if they require a few extra keystrokes. Among other things, it helps me remember that `bf()` does *not* stand for [Bayes factor](/posts/2023-04-12_bayes-factors/). I have far too much trauma around Bayes factors, and as much as I'm trying to repent my sins in this regard, my therapist isn't very well versed in statistical model selection and has not been particularly helpful.]

```{r}
#| label: simple-continuous-emax-model
base_model <- brmsformula(
  response ~ e0 + emax * exposure / (ec50 + exposure),
  e0 ~ 1,
  emax ~ 1,
  ec50 ~ 1,
  nl = TRUE
) 
```

There are a few important things to note here. 

- First, notice that we've set `nl = TRUE`. This is important because the syntax for a nonlinear model formula is qualitatively different to the syntax for a linear model formula. For linear models, we use the compact syntax where the model parameters (i.e., the regression coefficients) are *implicit*, like `y ~ x1 + x2` corresponds to the regression model $y_i = b_0 + b_1 x_1 + b_2 x_2$. For nonlinear models, this approach won't work because brms has no way to know the form of the model. So we have to be *explicit* and include the parameters (in this case `e0`, `emax`, and `ec50`) in the model formula.

- Second, note that I explicitly included formulas `e0 ~ 1`, `emax ~ 1`, and `ec50 ~ 1` in the model specification. This serves two purposes. First, it tells brms that `e0`, `emax` and `ec50` should be interpreted as model parameters (and brms will expect a prior for these parameters), whereas `exposure` should be treated as a predictor (brms will look for it in the data set).

- Third, be aware that the formula notation like `e0 ~ 1` is not arbitrary. In this particular model, `e0` will be treated like an "intercept" parameter: it's a single parameter and doesn't have a covariate model or any random effects attached to it. I'll come back to this later, but for now let's just be aware of this because you'll see this pop up in the output later.

Okay, let's get back on track. 

The second step is specifying the error model and link function. In an Emax regression with continuous response variables, we typically adopt the same approach we would do in an ordinary linear regression, and assume that measurement errors are normally distributed with an identity link:

```{r}
#| label: gaussian-error-model
gaussian_measurement <- brmsfamily(
  family = "gaussian", 
  link = "identity"
)
```

Finally we need to specify priors. By default brms places an improper flat prior over regression parameters, but that's not usually the best approach and (at least in my experience) can misbehave when you have a nonlinear model such as Emax.^[I discussed this in an [earlier blog post](/posts/2024-11-11_emax-parameters/). The structure of an Emax model more or less guarantees that if you don't have strong information provided either by the data or the priors, you'll run into some unpleasant model identifability issues. For this post I'll be supplying mildly informative priors and using data sets that are moderately informative, so we won't run into the pathological cases I constructed in that post, but it is still important to be mindful of this as an issue.] In addition, since the `e0` and `emax` variables are interpreted on the same scale as `response`, and `ec50` is interpreted on the same scale as `exposure`, it's usually possible to set informed priors that make sense for the experimental design (e.g., if you've already built a PK model you have a good sense of the range of possible exposures, and that in turn tells you something about the plausible range for your EC50 parameter). Anyway, here's a prior that is pretty conservative but not unreasonable for this design (e.g., I'm allowing for an exposure-response relationship but not specifying the direction in advance), but rules out nonsense parameters (e.g., you really shouldn't have negative EC50 values):^[Okay yes, I have not manually specified the prior for the error variance $\sigma^2$. Feel free to inspect the Stan code to see how brms handles that.]

```{r}
parameter_prior <- c(
  prior(normal(0, 5), nlpar = "e0"),
  prior(normal(0, 5), nlpar = "emax"),
  prior(normal(2000, 500), nlpar = "ec50", lb = 0)
)
```

Now that we have all three components we are ready to go. It's possible to use `make_stancode()` to inspect the Stan code that brms generates, and you can take a look at it here if you want to get a sense of what the "brms to stan" translation does, but I'll admit it's not always very pretty:

::: {.callout-caution collapse="true" appearance="minimal" title="Click to see the Stan code"}

```{r}
#| label: stancode-continuous-emax-model
make_stancode(
  formula = base_model, 
  family = gaussian_measurement, 
  data = continuous_data, 
  prior = parameter_prior
)
```

:::

More important for our current purposes we can fit the model by calling `brm()`:

```{r}
#| label: run-continuous-emax-model
#| cache: true
#| message: false
#| results: hide
continuous_base_fit <- brm(
  formula = base_model, 
  family = gaussian_measurement, 
  data = continuous_data, 
  prior = parameter_prior
) 
```

Print the output:

```{r}
continuous_base_fit
```

Extract model predictions:

```{r}
continuous_base_epred <- continuous_base_fit |> 
  epred_draws(newdata = tibble(exposure = seq(0, 50000, 1000))) |> 
  ungroup() |> 
  summarize(response = mean(.epred), .by = exposure)

continuous_base_epred
```

Plot:

```{r}
ggplot(mapping = aes(exposure, response)) + 
  geom_path(data = continuous_base_epred) + 
  geom_point(data = continuous_data) + 
  theme_bw()
```

### Adding covariates

We can adapt the exposure-response curve in the last example to illustrate why the simple emax regression model `base_model` is inadequate. If we shade the data points by the value of `cov_a` it is clear that the effect of this covariate has not been properly accounted for in the model:

```{r}
ggplot(mapping = aes(exposure, response)) + 
  geom_path(data = continuous_base_epred) + 
  geom_point(mapping = aes(color = cov_a), data = continuous_data) + 
  scale_color_distiller(palette = "PuOr", limits = c(0, 10)) + 
  theme_bw()
```

Clearly we need an extended model, one that includes the effect of covariates $\mathbf{X} = [x_{ik}]$. In the usual case covariates are included as additional linear terms, which gives us this model:

$$
y_i = E_0 + E_{max} \frac{\phi_i^\gamma}{EC_{50}^\gamma + \phi_i^\gamma} + \sum_k b_k x_{ik} + \epsilon_i 
$$

If we were to translate this formula literally in the call to `brmsformula()` the model specification would look like this:

```{r}
full_model <- brmsformula(
  response ~ e0 + emax * exposure / (ec50 + exposure) + 
    a * cov_a + b * cov_b + c * cov_c,
  e0 ~ 1,
  emax ~ 1,
  ec50 ~ 1,
  a ~ 1, 
  b ~ 1,
  c ~ 1,
  nl = TRUE
)
```

A model written this way would work just fine but it is a little inelegant, and we can do better than this. Earlier in the post I mentioned that the recommended way to think about nonlinear "parameters" in brms is to think of them as "placeholders". This is the point at which that becomes relevant. We can write a more general formulation of Emax regression with covariates like this:

$$
y_i = f_1(X_i) + f_2(X_i) \frac{\phi_i^{f_4(X)}}{f_3(X_i) ^ {f_4(X_i)} + \phi_i ^ {f_4(X_i)}} + \epsilon_i
$$
where each of the functions $f_1$, $f_2$, $f_3$ and $f_4$ describe a linear predictor, $X_i$ denotes the covariate vector for the $i$-th subject, and for simplicity the dependence on regression coefficients is suppressed in the notation. When we specify an emax model without covariates all four of these functions correspond to "intercept-only" models and are constant with respect to $X_i$:

$$
\begin{array}{rcl}
f_1(X_i) &=& E_0 \\
f_2(X_i) &=& E_{max} \\
f_3(X_i) &=& EC_{50} \\
f_4(X_i) &=& \gamma
\end{array}
$$

If we fix $\gamma = 1$ we can drop $f_4$ entirely:

$$
y_i = f_1(X_i) + f_2(X_i) \frac{\phi_i}{f_3(X_i) + \phi_i} + \epsilon_i
$$

In principle we could specify a covariate model for any of these functions, but in the typical case we would do so only for $f_1$. Letting $b_k$ denote the regression coefficient for the $k$-th covariate:

$$
\begin{array}{rcl}
f_1(X_i) &=& E_0 + \sum_k b_k x_{ik} \\
f_2(X_i) &=& E_{max} \\
f_3(X_i) &=& EC_{50}
\end{array}
$$
Or, if we wrote this in the "classical" R formula style where, it would look something like this:

```r
e0 ~ 1 + x1 + x2 + ...
emax ~ 1
ec50 ~ 1
```

Oh hey, that's how it works in brms. The first line in the model formula defines Emax as a structural model, and subsequent lines specify covariate models for each of the Emax components:

```{r}
full_model <- brmsformula(
  response ~ e0 + emax * exposure / (ec50 + exposure), # structural model
  e0   ~ 1 + cov_a + cov_b + cov_c, # covariate model for baseline
  emax ~ 1,                         # covariate model for max response
  ec50 ~ 1,                         # covariate model for EC50
  nl = TRUE
)
```

Having done so, the prior specification looks like this:

```{r}
parameter_prior <- c(
  prior(normal(0, 5), nlpar = "e0"),
  prior(normal(0, 5), nlpar = "emax"),
  prior(normal(2000, 500), nlpar = "ec50", lb = 0)
)
```

Although this specification of `parameter_prior` is identical to the one I wrote down earlier, it's worth noting that brms interprets this prior slightly differently in the context of the two models. In `base_model` there is only one `e0` parameter (the intercept) over which the normal prior is specified. In contrast, `full_model` has four parameters (intercept plus three coefficients), and each of those four terms is supplied with its own normal prior. In other words, the specification `prior(normal(0, 5), nlpar = "e0")` is interpreted as a prior to be applied across all parameters in the `e0` part of the structural model. You can see this if you look closely at the Stan code, which is tucked below the fold here, but it's not the most thrilling read so let's move on, shall we?

::: {.callout-caution collapse="true" appearance="minimal" title="Click to see the Stan code"}

```{r}
#| label: stancode-continuous-emax-model-with-covariates
make_stancode(
  formula = full_model, 
  family = gaussian_measurement, 
  data = continuous_data, 
  prior = parameter_prior
)
```

:::

Now that the model is full specified we can call `brm()` and estimate model parameters:

```{r}
#| label: run-continuous-emax-model-with-covariates
#| cache: true
#| message: false
#| results: hide
continuous_full_fit <- brm(
  formula = full_model, 
  family = gaussian_measurement, 
  data = continuous_data, 
  prior = parameter_prior
) 
```

Here they are:

```{r}
continuous_full_fit
```

### Model comparison

The brms package provides a flexible interface for model comparison using LOO-CV and WAIC, using the [loo](http://mc-stan.org/loo/) package under the hood to do the work. Because the interface is flexible there are several ways to write the code: the approach below is my preferred way to do it. First, we use `add_criterion()` to run the LOO-CV procedure, and store the results internally within the brmsfit object:

```{r}
continuous_full_fit <- add_criterion(continuous_full_fit, "loo")
continuous_base_fit <- add_criterion(continuous_base_fit, "loo")
```

You can extract the stored result like this if you need to use it for some other purpose:

```{r}
continuous_full_fit$criteria$loo
```

Now that we have the required samples stored within both model fit objects, we can call `loo_compare()` to perform the model comparison:

```{r}
continuous_loo_compare <- loo_compare(continuous_full_fit, continuous_base_fit)
continuous_loo_compare
```

By default the printed output only shows the most important columns, but the return value from `loo_compare()` is richer than this. It's an object of class "compare.loo", and if we call the print method with `simplify = FALSE` it will show all the columns:

```{r}
print(continuous_loo_compare, simplify = FALSE)
```

## Binary response

The emax regression framework also supports binary response data (e.g., adverse events in an exposure-safety analysis). Letting $p_i = Pr(y_i = 1)$ be the probability of an event,

$$
\mbox{logit}(p_i) = E_0 + E_{max} \frac{\phi_i^\gamma}{EC_{50}^\gamma + \phi_i^\gamma} 
$$

where 

$$
\mbox{logit}(p_i) = \ln \left(\frac{p_i}{1-p_i} \right)
$$

### Simulated data

Generating binary-outcome ER data sets isn't any more interesting than generating their continuous equivalents, so once again I'll wrap the code in a `make_binary_data()` function that you can browse if you really feel like it:

::: {.callout-caution collapse="true" appearance="minimal" title="Click to see the code"}

```{r}
#| label: binary-data
make_binary_data <- function(seed = 123) {
  
  set.seed(seed)
  
  # exposures are assumed to be slightly-truncated log-normal distributed
  # variates, and scale linearly with dose
  generate_exposure <- function(dose, n, meanlog = 4, sdlog = 0.5) {
    dose * qlnorm(
      p = runif(n, min = .01, max = .99), 
      meanlog = meanlog,
      sdlog = sdlog
    )
  }
  
  # for simplicity, continuous covariates presumed to be 
  generate_covariate <- function(n) {
    rbeta(n, 2, 2) * 10
  }
  
  make_data <- function(dose, n, par) {
    tibble(
      
      # exposure depends on dose, of course
      dose = dose, 
      exposure = generate_exposure(max(dose, .01), n = n), 
      
      # covariates
      cov_a = generate_covariate(n = n),
      cov_b = generate_covariate(n = n),
      cov_c = generate_covariate(n = n),
      
      # linear predictor is an emax function of exposure plus covariate model
      pred = emax_fn(
        exposure,
        emax = par$emax, 
        ec50 = par$ec50, 
        e0 = par$e0, 
        gamma = par$gamma
      ) + 
        par$coef_a * cov_a + 
        par$coef_b * cov_b + 
        par$coef_c * cov_c,
      
      # probability of outcome is a standard logistic function of pred
      prob = 1 / (1 + exp(-pred)),
      
      # response is bernoulli(prob)
      response = as.numeric(runif(n) < prob)
      
    ) #|> select(-pred, -prob)
  }
  
  # parameters governing the whole thing
  par <- list(
    emax   = 5, 
    ec50   = 8000, 
    e0     = -3,
    gamma  = 1,
    coef_a = .2,
    coef_b = 0,
    coef_c = 0
  )
  
  # simulate a simple experiment with three dose groups
  dat <- bind_rows(
    make_data(dose = 100, n = 100, par = par),  
    make_data(dose = 200, n = 100, par = par),
    make_data(dose = 300, n = 100, par = par)
  ) 
  
  return(dat)
}
```

:::

Here's a data set we can use for Emax regression with a binary response variable, and three continuous covariates:

```{r}
binary_data <- make_binary_data()
binary_data
```

To see what's going on in this data set I'll show violin plots for `exposure`, `cov_a`, `cov_b`, and `cov_c` stratified by whether the `response` variable is 0 or 1:

```{r}
#| fig-height: 8
#| fig-width: 8
binary_data |> 
  pivot_longer(
    cols = c(exposure, cov_a, cov_b, cov_c), 
    names_to = "variable",
    values_to = "value"
  ) |> 
  mutate(response = factor(response)) |> 
  ggplot(aes(response, value)) + 
  geom_violin(draw_quantiles = .5) + 
  facet_wrap(~ variable, scales = "free_y") + 
  theme_bw()
```

### Simple Emax regression

The model formula is identical to the one we specified last time. I'll write it out again just so that you can see it, but I don't really need to because it's the same code:

```{r}
#| label: simple-binary-emax-model
base_model <- brmsformula(
  response ~ e0 + emax * exposure / (ec50 + exposure),
  e0 ~ 1,
  emax ~ 1,
  ec50 ~ 1,
  nl = TRUE
) 
```

There's no reason to modify the prior either: we can use the exact same `parameter_prior` object that we specified for the continuous outcome case. It has a slightly different meaning in the binary model because the Emax predictions now have a logistic relationship to the data because of the logit-link that is usually applied for binary outcome data, but that is more properly considered part of the measurement model. Speaking of which, here is the measurement model we usually apply for binary data: 

```{r}
#| label: bernoulli-error-model
bernoulli_measurement <- brmsfamily(
  family = "bernoulli", 
  link = "logit"
)
```

In truth, the measurement model is the only thing I've changed when switching from continuous to binary data, which is terribly convenient. So now we can estimate the model parameters with `brm()` as follows:

```{r}
#| label: run-binary-emax-model
#| message: false
#| results: hide
binary_base_fit <- brm(
  formula = base_model, 
  family = bernoulli_measurement, 
  data = binary_data, 
  prior = parameter_prior
) 
```

Here's the results:

```{r}
binary_base_fit
```

As before, we can extract model predictions...

```{r}
binary_base_epred <- binary_base_fit |> 
  epred_draws(newdata = tibble(exposure = seq(0, 50000, 1000))) |> 
  ungroup() |> 
  summarize(response = mean(.epred), .by = exposure)

binary_base_epred
```

and we can make a pretty plot...

```{r}
ggplot(mapping = aes(exposure, response)) + 
  geom_path(data = binary_base_epred) + 
  geom_jitter(data = binary_data, width = 0, height = .05) + 
  theme_bw()
```

### Adding covariates

At this point you're hardly going to be shocked to discover that the model formula for the full model is unchanged from the one we used in the continuous case, so we can just reuse the `full_model` formula we wrote down before. Same goes for the prior, so all we need to do is use `bernoulli_measurement` as the model family, which gives us this:

```{r}
#| label: run-binary-emax-model-with-covariates
#| message: false
#| results: hide
binary_full_fit <- brm(
  formula = full_model, 
  family = bernoulli_measurement, 
  data = binary_data, 
  prior = parameter_prior
) 
```

```{r}
binary_full_fit
```

### Model comparison

```{r}
binary_full_fit <- add_criterion(binary_full_fit, "loo")
binary_base_fit <- add_criterion(binary_base_fit, "loo")

loo_compare(binary_full_fit, binary_base_fit)
```

