---
title: "Making tables in R with table1"
description: "A pretty reckless dive into a package that hits the sweet spot for me"
date: "2024-06-21"
categories: ["R"]
format: 
  html:
    css: style-tweaks.css
--- 

<!--------------- my typical setup ----------------->

```{r}
#| label: setup
#| include: false
very_wide <- 500
wide <- 136
narrow <- 76
options(width = wide)
cache_images <- TRUE
set.seed(1)
```

<!--------------- post begins here ----------------->

> I'll never be good enough <br>
> You make me wanna die <br>
> And everything you love will burn up in the light <br>
> And every time I look inside your eyes <br>
> You make me wanna die <br>
> &nbsp; &nbsp; - [*The Pretty Reckless*](https://www.youtube.com/watch?v=txBfhpm1jI0)

It's no secret that my health hasn't been so great these last few months. Nothing life-threatening, I hasten to add, but severe enough that I've spent a depressing amount of 2024 in bed, and not in the fun way. I'm fortunate enough to have a remote job, and the workload this year hasn't been as demanding as it was last year. I've been able to manage, yes,^[It always strikes me as a bitter failure of public policy that when someone falls sick, their first thought is *always* something along the lines of "can I still work?" Very few people actually love their jobs so much that they want to work through a serious illness, but the fear that the company will discard you the moment something bad happens is built into our society at a low level. If you're not dead you work. Because capitalism.] but it has been rough. I've necessarily been focusing what little energy I've had on my kids and on my day to day work. I've had no bandwidth at all to write, or make art, or learn new things. A sorry state of affairs, and one that sucks much of the joy out of life.

Happily, things have started to turn around in recent weeks. I've had a little more energy, I've been able to work from my desk rather than my bed, and while the artistic impulse hasn't come back yet I've started to write once more. 

The [table1](https://benjaminrich.github.io/table1/) package by Benjamin Rich. Package source code is on [github](https://github.com/benjaminrich/table1), and the [package vignette](https://benjaminrich.github.io/table1/vignettes/table1-examples.html) provides a lot of useful detail that you can't necessarily find by browsing the help files.


![](./make-me-wanna-die.jpg)

## Getting started

```{r}
#| label: packages
#| message: false
#| warning: false
library(palmerpenguins)
library(table1)
library(dplyr)
```

```{r}
#| label: penguins-data
penguins
```


Basic usage:^[The output of a call to `table1()` has S3 class "table1", and internally specifies an HTML table (more on that later). When printed in a quarto or R markdown document like this one, in the normal course of events the `table1:::knit_print.table()` method is called, in which case the table1 object is coerced to a data frame and the end result looks the same as a data frame would look when `knitr::kable()` is called. However, this is slightly different to how the table looks if you call it interactively in an R session where the S3 method called is `table1:::print.table1()`. Because I want the output in this post to look as close as possible to the typical output when calling `table1()` in a regular R session, I've set `results = "asis"` for all my code chunks in this document, thereby ending up with tables that look the same as the ones you see interactively in the R session.]

```{r}
#| label: simple-table
#| results: asis
table1(~ island + bill_length_mm | species, penguins)
```

<br>

The stratification variable (i.e. `species`) isn't actually necessary to create a table, and if you wanted you could produce a table using a formula like `~ island + bill_length_mm`. In practice, however, I've found that I never do this: almost every table I've created in real life has a stratification variable.

## Applying labels

Adding labels:^[The table1 package also supports units as a separate piece of metadata via the `units()` function, but I have to admit I never really use that one.]

```{r}
#| label: labelling-1
#| results: asis
label(penguins$island) <- "Island"
label(penguins$bill_length_mm) <- "Bill Length (mm)"

table1(~ island + bill_length_mm | species, penguins)
```

<br>

Using the `label()` function in table1 is how I've seen most people do it, but in truth there's nothing fancy here: all that the function does is set the "label" metadata attribute for the relevant object, so you could totally do it in base R via the `attr()` function:

```{r}
#| label: labelling-2
#| results: asis
attr(penguins$bill_depth_mm, "label") <- "Bill Depth (mm)"

table1(~ bill_depth_mm | species, penguins)
```

<br>

However, I am slowly coming to like the `setLabel()` convenience function in table1 because it returns the labelled object and hence plays nicely with a dplyr workflow: 

```{r}
#| label: labelling-3
#| results: asis
penguins <- penguins |> 
  mutate(
    flipper_length_mm = setLabel(flipper_length_mm, "Flipper Length (mm)"),
    body_mass_g = setLabel(body_mass_g, "Body Mass (g)"),
    sex = setLabel(sex, "Sex"),
    year = setLabel(year, "Year")
  )

table1(~ flipper_length_mm + body_mass_g + sex + year | species, penguins)
```

<br>


![](my-medicine.jpg)

## Customing cell content

> Somebody mixed my medicine <br>
> Somebody's in my head again <br>
> Well, I'll drink what you leak and I'll smoke what you sigh <br>
> See across the room with a look in your eye <br>
> &nbsp; &nbsp; --[*The Pretty Reckless*](https://www.youtube.com/watch?v=cJMSDlWlfMM)

One thing I really like about the table1 package is that it supplies very sensible defaults for tables of descriptive statistics: continuous variables are summarised not only via means and standard deviations, but you also get the medians, ranges, and missing data summaries. Categorical variables are summarised with counts and percentages, and again you get a missing data summary. Very often this is exactly the summary you want, and no customisation at all is required.

Inevitably, though, every data analyst comes across as situation that requires a different collection of summary statistics. At that point, you need to dive a little deeper and understand the syntax table1 uses to modify the summaries that it produces. 

### Using abbreviated codes

The table1 package has a very practical and flexible mechanism for customising the descriptive statistics that it produces, but one that needs a bit of unpacking to understand. If you really want to do so, you can write an entire "rendering" function from scratch that affords very fine grained control over the output (more on that later!) but most of the time you don't actually want to go to all that effort. In most situations, all you *really* want to do is swap out one widely-used descriptive statistic for a different widely-used descriptive statistic. It would be no fun for the analyst if they had to write an entire rendering function from scratch just to switch from reporting arithmetic means to reporting geometric means. To that end, table1 provides a compact syntax using "abbreviated codes" that covers a lot of common use cases.

As a concrete example, let's consider the task I described above: reporting geometric means and standard deviations. This is a very common task in pharmacometrics because a lot of observed data are approximately log-normal in distribution, and in my everyday work I find I have to do this a lot. Luckily for me, the table1 package recognises the strings `"GMEAN"` and `"GSD"` as abbreviated codes, and internally will replace them with function calls that compute the geometric mean and geometric standard deviation. To define a custom render that produces these two statistics, all I have to do is define a named vector like this one:

```{r}
#| label: geometric-summary
render_geometric <- c(
  "Geometric mean" = "GMEAN", 
  "Geometric SD" = "GSD"
)
```

In this compressed syntax, the names define the row labels that will be printed in the output table (e.g., `"Geometric mean"` becomes a row label), and the values are interpreted using the abbreviated code (e.g., the `"GMEAN"` string is replaced by the value of the geometric mean). To apply this custom render to my table only to the continuous variables in the summary table, all I have to do is include `render.continuous = render_geometric` in the call to `table1()`:

```{r}
#| label: render-continuous-1
#| results: asis
table1(
  x = ~ flipper_length_mm + body_mass_g + sex + year | species, 
  data = penguins, 
  render.continuous = render_geometric
)
```

<br>

As you can see from the output, the custom render has been applied to the two continuous variables `flipper_length_mm` and `body_mass_g` but not the categorical variables `sex` and `year`, just as you'd expect given that the argument I specified is called `render.continuous`. However, there are two features that might be a little surprising:

- The missing data summary for the continuous variables is unaffected
- If you look at the documentation for `table1()` you'll notice it has a `render` argument but not a `render.continuous` argument

I'll unpack both of those things later in the blog post, but I wanted to mention them now because these things confused me a little when I first started using table1. For now, let's just accept that it works and move on.

The table1 package comes equipped with quite a few of these abbreviated codes, which makes life considerably easier. For instance if we needed to compute the 10th, 50th, and 90th percentiles of each continuous variable, we could use the `"q10"`, `"q50"`, and `"q90"` keywords, like so:

```{r}
#| label: render-continuous-2
#| results: asis
table1(
  x = ~ flipper_length_mm + body_mass_g + sex | species, 
  data = penguins, 
  render.continuous = c(
    "10th percentile" = "q10", 
    "50th percentile" = "q50",
    "90th percentile" = "q90"
  )
)
```

<br>

Very handy. 


### Supported aliases

The natural question you might have as the user of the package is, of course, what abbreviated codes does the table1 package understand? As documented [here](https://benjaminrich.github.io/table1/vignettes/table1-examples.html#using-abbreviated-code-to-specify-a-custom-renderer) in the package vignette, you can find a complete listing by playing around with the `stats.default()` function.^[If you're a foolish person like I am you can also dig into the [source code](https://github.com/benjaminrich/table1/blob/master/R/table1.R) to find the answer, because why would I be smart and read the package vignette *before* reading the source code?] So let's do that. For continuous variables, this is the list of supported aliases:

```{r}
#| label: narrow-text
#| include: false
options(width = narrow + 10)
```

```{r}
#| label: continuous-aliases
continuous <- 1:10
names(stats.default(continuous)) 
```

Here's what each of these mean:^[If you want a more precise answer, you can use a command like `parse.abbrev.render.code("GMEAN")` to return the actual function that is executed whenever a `"GMEAN"` is computed during the table rendering process.]

- `"N"`, `"NMISS"`: these compute the number of non-missing observations and number of missing observations respectively
- `"SUM"`, `"MEAN"`, `"SD"`, `"MEDIAN"`, `"MIN"`, `"MAX"`: these all correspond to to the functions of the same name, e.g., `"SUM"` produces a call to `sum()`, with missing values removed
- `"CV"`: the coefficient of variation, i.e., 100 times the standard deviation divided by the absolute value of the mean
- `"GMEAN"`, `"GSD"`, `"GCV"`: the geometric mean, geometric standard deviation, and geometric coefficient of variation
- `q01`, `q02.5`, `"q05"`, `"q10"`, `"q25"`, `"q50"`, `"q75"`, `"q90"`, `"q95"`, `"q97.5"`, `"q99"`: these are understood to refer to specific quantiles, e.g., `"q25"` is translated as a function call that computes the 25th percentile
- `"Q1"`, `"Q2"` `"Q3"`: these are used to compute quartiles (25th, 50th, and 75th percentiles)
- `"T1"`, `"T2"`: these are used to compute tertiles (33rd and 67th percentiles)
- `"IQR"`: this computes the interquartile range

In all cases except for `"NMISS"`, the relevant statistics are computed after removing missing values. Turning now to categorical variables, we can again use the `stats.default()` function to find the supported abbreviated codes:^[If you're curious as to why I'm extracting the first element of the output in this code, try playing around with `stats.default()` and looking at the differences between how the output is structured for continuous versus categorical inputs.]

```{r}
#| label: categorical-aliases
categorical <- c("a", "b", "c")
names(stats.default(categorical)[[1]])
```

The interpretation of these is as follows:

- `"FREQ"`: the frequency count for a category
- `"PCT"`: the percent relative frequency, with missing values included in the denominator
- `"PCTnoNA"`: the percent relative frequency, after missing values are removed
- `"NMISS"`: the number of missing values, as before

The nice thing about these abbreviated codes is that they cover a surprisingly wide variety of use cases. More often than not I've found that the descriptive statistics I need can be specified using this mechanism. From the analyst perspective this is great: you really don't want to waste time writing more code than you have to, so if you can specify your table of descriptive statistics without bothering to write a function, you're doing well.

![](hit-me-like-a-man.jpg)

### Writing render functions

> I am strong, love is evil <br>
> It's a version of perversion that is only for the lucky people <br>
> Take your time and do with me what you will <br>
> I won't mind, you know I'm ill, you know I'm ill <br>
> So hit me like a man <br>
> And love me like a woman <br>
> &nbsp; &nbsp; -- *[The Pretty Reckless](https://www.youtube.com/watch?v=Z6ZtYZiHong)*

Alas life is not always kind to us, and it's not uncommon to run into situations where your table of descriptive statistics requires the computation of something that doesn't have an abbreviated code in table1. When that happens, the only recourse is for the user to write a rendering function that takes the data as input and returns a vector of strings to be printed into the table. As an example, suppose you have a need to report [Winsorised](https://en.wikipedia.org/wiki/Winsorizing) summary statistics for your continuous variables:

```{r}
#| label: render-winsorized
render_winsorized <- function(x, cutoff = .05, ...) {
  lo <- quantile(x, cutoff, na.rm = TRUE)
  hi <- quantile(x, 1 - cutoff, na.rm = TRUE)
  x[x < lo] <- lo
  x[x > hi] <- hi
  strs <- c(
    "",
    "Winsorized mean" = sprintf("%1.2f", mean(x, na.rm = TRUE)),
    "Winsorized SD" = sprintf("%1.2f", sd(x, na.rm = TRUE))
  )
  return(strs)
}
```

Notice that this `render_winsorized()` function returns a named vector of strings that follows the same convention that we followed with the simpler `render_geometric` example earlier: the names of the output string become the row labels, and the values are printed into the table itself. Along similar lines, we can define a rendering function to be applied to the categorical variables in the data. Here's a very simple one that reports only the absolute frequencies for each category:

```{r}
#| label: render-counts
render_counts <- function(x, ...) c("", table(stringr::str_to_title(x)))
```

Having defined our render functions, we produce the desired table by passing `render_winsorized()` as the handler for continuous variables and `render_counts()` as the handler for categorical variables:

```{r}
#| label: render-categorical
#| results: asis
table1(
  x = ~ flipper_length_mm + body_mass_g + sex | species, 
  data = penguins, 
  render.continuous = render_winsorized,
  render.categorical = render_counts
)
```

<br>

Our table is mostly done, but we still don't have a method for adjusting how the missing data summaries are produced. To do that we need to define one more rendering function and pass it as the `render.missing` argument:

```{r}
#| label: render-missing
#| results: asis
render_missing <- function(x, ...) c("Missing" = sum(is.na(x)))

table1(
  x = ~ flipper_length_mm + body_mass_g + sex | species, 
  data = penguins, 
  render.continuous = render_winsorized,
  render.categorical = render_counts,
  render.missing = render_missing
)
```

<br>

### Unpacking render functions

There's still a bit of a mystery here, because the `table1()` function doesn't have arguments `render.continuous`, `render.categorical`, or `render.missing`: instead, it has a `render` argument. What's actually going on here is that the default value for `render` is the `render.default()` function exported by table1, and `render.default()` accepts `render.continuous`, `render.categorical`, or `render.missing` as arguments. In other words, what's happening in the code above is that my custom functions end up being passed to `render.default()` via the dots. 

There's nothing to prevent you from bypassing this whole process by writing your own render function that handles *all* the input variables. For example, here's a very simple rendering function that counts the number of non-missing observations, and prints it in the same row as the variable name:

```{r}
#| label: custom-render
#| results: asis
render_n <- function(x, ...) sum(!is.na(x))

table1(
  x = ~ flipper_length_mm + body_mass_g + sex | species, 
  data = penguins, 
  render = render_n
)
```

<br>

I have to confess it took me waaaaay too long to realise that I could do this in table1. True, I don't often have a need to bypass the `render.default()` function, but there are definitely times when that's a handy little bit of functionality. Sigh. Sometimes I'm quite dense. 

![](follow-me-down.jpg)

## Table annotations

> Follow me down to the river <br>
> Drink while the water is clean <br>
> Follow me down to the river tonight <br>
> I'll be down here on my knees <br>
> &nbsp; &nbsp; --*[The Pretty Reckless](https://www.youtube.com/watch?v=vfwJ-SoYw4U)*

Time to switch gears a little. In the previous section I talked about how to customise the statistics that are reported in the table cells. Implicit in this discussion is the fact that a custom render function allows you to customise the row labels associated with each statistic, in exactly the same way that variable labels allow you to customise the variable descriptions that appear in the leftmost column of the table. Taken together, these two mechanisms (render functions and variable labels) give the user a *lot* of control over what appears in the leftmost column of the table. But what about the header row? How do we customise that in table1?

### Strata column labels

To start with, let's consider the columns that associated with a particular stratum. In the penguins tables I've been creating, the strata are defined by the `species` variable so are three columns that are associated with a specific stratum. By default `table1()` will add a description for each such column in the header row that contains the category name (e.g., "Gentoo") and the number of observations that belong to this category. But perhaps we don't want those sample size numbers? Maybe all we want is the category name. To customise how each stratum is labelled in the header row, the `table1()` function has an argument called `render.strat` that takes a function as its value. The strata rendering function takes three arguments: the `label` is the value in the data that defines that category (e.g., `"Gentoo"`), `n` is the number of observations that have been assigned to the category, and `transpose` is a logical variable indicating whether the table is transposed (more on that later). The output of the function is a string that specifies (as HTML) what should appear in the header row. To illustrate the idea, here's a very simple stratum rendering function that only prints the category label:

```{r}
#| label: render-strat-1
#| results: asis
render_strat <- function(label, n, transpose = FALSE) {
  sprintf("<span class='stratlabel'>%s</span>", label)
}
```

The only subtlety to this `render_strat()` function is that it outputs some HTML that wraps the `label` in an HTML span tag and assigns it to a class that we can (and will) use later on to create some fancy styling using CSS. But I'm getting ahead of myself a little. For now, it's enough to note that `render_strat()` creates a very simple label that just prints out the category label. Here it is in action: 

```{r}
#| label: render-strat-2
#| results: asis
table1(
  x = ~ flipper_length_mm + body_mass_g | species,
  data = penguins,
  render.strat = render_strat
)
```

<br>

Indeed it performs as expected: the sample size annotations are gone and we now have very minimalistic labels for each of the three penguin species. So let's move along.

### Other column labels

There are two other columns that typically appear in a table1 output object: on the left we have column that contains the row labels, and on the right we have a table that contains the descriptive statistics for the "overall" data set where we collapse across all strata. By default, the row label column on the left has no label and the aggregated column on the right uses that label "Overall". Both of these are customisable in the call to `table1()`, using the `overall` and `rowlabelhead` arguments. An example of this is illustrated below:

```{r}
#| label: column-labels
#| results: asis
table1(
  x = ~ flipper_length_mm + body_mass_g | species,
  data = penguins,
  overall = "All Species",
  rowlabelhead = "Measurement"
)
```

<br>

### Footnotes and captions

In addition to allowing you to customise the header row, the table1 package also supports the addition of captions and footnotes. Shockingly, it turns out you can specify these with `table1()` by using the `caption` and `footnote` arguments. Both of these take a single string as their input, and you can use HTML tags here. For example, here's a footer that acknowledges the two packages I've relied on most in this post, specifying the package names in boldface:

```{r}
#| label: adding-footnotes
#| results: asis
table1(
  x = ~ flipper_length_mm + body_mass_g | species,
  data = penguins,
  footnote = "Created using <b>table1</b> and <b>palmerpenguins</b>"
)
```

<br>

Specifying captions is very similar. Here's a simple example:

```{r}
#| label: adding-captions
#| results: asis
table1(
  x = ~ flipper_length_mm + body_mass_g | species,
  data = penguins,
  caption = "Flipper length and body mass by species among the Palmer penguins"
)
```

<br>

## Table structure

So far we've discussed how to control what statistics are computed in the table, and in the process I've also talked about how to specify the row and columns labels that are associated with the various statistics. I've also talked about other marginalia associated with a table, which in table1 is really just the footnote and caption. What I haven't talked about yet is how to control the *structure* of the table that gets produced. For the most part, this structure is controlled by the formula that you use to specify the table. When I specify a table like this

```r
~ flipper_length_mm + body_mass_g | species
```

I will generally get a table that has one column for each unique value of `species` (the strata), and a block of rows associated with each of the variables (`flipper_length_mm` and `body_mass_g`) that supply the relevant descriptive statistics. By default we also get one additional "overall" column that collapses the strata and reports descriptive statistics for the entire data set. Most of the time this is exactly the structure we want, but not always. To that end, table1 allows you to customise the structure in various ways.

### Removing "overall"

The simplest way to modify the table structure is to remove the "overall" column that collapses the strata. We can do this using the `overall` argument. In the last section I showed how to use this argument to change the label associated with this column by passing a string, but if instead we set `overall = FALSE`, that column will be removed entirely:

```{r}
#| label: remove-overall
#| results: asis
table1(
  x = ~ flipper_length_mm + body_mass_g | species,
  data = penguins,
  overall = FALSE
)
```

<br>

### Nested stratifications

Up to this point in the post I've used only a single variable to define the strata in the table. At the start of the post I mentioned that you can drop the stratification entirely simply by specifying a one-sided formula like `~ flipper_length_mm + body_mass_g` that doesn't include anything on the right hand side of the `|` separator. But that's rarely of interest to us in real world data analysis. The thing we're more likely to want is a *nested* stratification, where we define strata based on all unique combinations of two variables. For example, let's suppose I wanted to compute descriptive statistics for each `species` of penguin, but for each species the statistics should be computed separately for each `island`. Happily, the table1 package supports this kind of two-level stratification. All I have to do is write `species * island` on the right hand side of the separator like so:

```{r}
#| label: nested-strata-1
#| results: asis
table1(
  x = ~ flipper_length_mm + body_mass_g | species * island,
  data = penguins,
  overall = FALSE
)
```

<br>

As it happens, only the Adelie penguins appear on all three islands: the Chinstrap penguins appear only on Dream Island, and the Gentoo penguins appear only on Biscoe Island. So the table here contains three columns for the Adelie penguins, and only one each for the Chinstrap and Gentoo penguins. 

There are some limitations to this functionality. You can't stratify by more than two variables, and the stratification variables cannot contain any missing values. Even so, the functionality is pretty handy, and it is sensitive to the order in which you specify the two stratification variables. If I write `island * species` rather than `species * island`, I get this table instead:

```{r}
#| label: nested-strata-2
#| results: asis
table1(
  x = ~ flipper_length_mm + body_mass_g | island * species,
  data = penguins,
  overall = FALSE
)
```

<br>

I've found this functionality useful many times in my everyday life. 

### Adding extra columns

Another kind of "structural" customisation that table1 allows is adding new columns. A common use case for this functionality is to add a column that reports a p-value associated with a particular row. For example, suppose what I wanted my table to do is run a one-way ANOVA for each of the continuous variables in the table, to test to see if the categories have different group means. To handle something like this we'll again need to write a custom render function that accepts data from *all* groups -- as a list of vectors -- and returns a string that should be printed into the relevant cell in the new "p-values" column. This `render_p_value()` function will do this for me:

```{r}
#| label: render-p-value
render_p_value <- function(x, ...) {
  dat <- bind_rows(
    purrr::map(x, ~ data.frame(value = .)), 
    .id = "group"
  )
  mod <- aov(value ~ group, dat)
  p <- summary(mod)[[1]][1, 5]
  return(scales::label_pvalue()(p))
}
```

I don't want to dive into the details of what this function is doing, but if you're familiar with the standard interface for linear models in R it should look very familiar. If not, here's the gist: the first part of the code rearranges the list of vectors input into a data frame format, the second part estimates parameters for the model, runs the usual F-test, and extracts the p-value from the output. Finally, it returns the p-value as a prettily-formatted string.

The `render_p_value()` function is the one we'll use to render our new column, but for the purposes of this example I'll also define a custom renderer for the contents of the strata columns as well, so that the only thing it does is report the mean value for the group. You don't have to do this, I'm only doing it because I want my table to be as simple as possible. 

```{r}
#| label: render-mean
render_mean <- function(x, ...) sprintf("%1.1f", mean(x, na.rm = TRUE))
```

Now that we have our rendering functions, I can specify one or more additional columns in my table by passing a named list of functions to the `extra.col` argument (the names are used to specify the column labels). In my case I'm only adding a single extra column with the p-value so my list has only a single function, but it's not too hard to imagine scenarios where I'd want to add more than one (e.g., maybe I want to report the degrees of freedom associated with my F-test). Anyway, here's the code:

```{r}
#| label: extra-columns
#| results: asis
table1(
  x = ~ flipper_length_mm + body_mass_g | species,
  data = penguins,
  render = render_mean,
  extra.col = list("p-value" = render_p_value)
)
```

<br>

Very nice.

### Transposing tables

```{r}
#| label: transposing-tables
#| results: asis
render_mean_sd <- function(x, ...) {
  m <- mean(x, na.rm = TRUE)
  s <- sd(x, na.rm = TRUE)
  sprintf("%1.1f (%1.1f)", m, s)
}

table1(
  x = ~ bill_length_mm + bill_depth_mm + flipper_length_mm + body_mass_g | species,
  data = penguins,
  transpose = TRUE,
  rowlabelhead = "Species",
  render = render_mean_sd,
  render.strat = render_strat
)
```

<br>

### Arbitrary stratification

> Why'd you bring a shotgun to the party? <br>
> &nbsp; &nbsp; --[*The Pretty Reckless*](https://www.youtube.com/watch?v=PYxd8gh7g_k)

Using the data frame interface we can exercise finer-grained control over the strata.

```{r}
#| label: arbitrary-strata
#| results: asis
penguins <- penguins |>
  mutate(
    sex = stringr::str_to_title(sex),
    year = factor(year)
  )

penguins_strata <- c(
    split(penguins, ~species), 
    split(penguins, ~sex),
    list("All" = penguins)
  )

penguins_labels <- list(
    variables = list(island = "Island", year = "Year"), 
    groups = list("Species", "Sex", "")
  )

table1(penguins_strata, penguins_labels, groupspan = c(3, 2, 1))
```

<br>

## Styling tables

### Built-in styles

There are a few built-in styles, discussed in the package vignette:

- `zebra`: alternating shaded and unshaded rows
- `grid`: show all grid lines
- `shade`: shade the header in gray
- `times`: use a serif font
- `center`: center all columns

Selecting a style using the `topclass` argument:

```{r}
#| label: built-in-style-1
table1(
  x = ~ flipper_length_mm + body_mass_g | species,
  data = penguins,
  topclass = "Rtable1-zebra",
  render = render_mean,
  render.strat = render_strat,
  footnote = "Source: palmerpenguins"
)
```

```{r}
#| label: built-in-style-2
table1(
  x = ~ flipper_length_mm + body_mass_g | species,
  data = penguins,
  topclass = "Rtable1-zebra Rtable1-shade Rtable1-times",
  render = render_mean,
  render.strat = render_strat,
  footnote = "Source: palmerpenguins"
)
```


### Using custom CSS

> Signed with the devil <br>
> Signed with the devil <br>
> Signed with the devil, oh <br>
> &nbsp; &nbsp; --*[The Pretty Reckless](https://www.youtube.com/watch?v=BQpZv2r8fb4)*

Here's the HTML that gets generated for a table:

```{r}
#| label: css-styling-1
tbl <- table1(
  x = ~ flipper_length_mm + body_mass_g | species,
  data = penguins,
  topclass = "mytable",
  render = render_mean,
  render.strat = render_strat,
  footnote = "Source: palmerpenguins"
)

cat(as.character(tbl))
```

So we can add a bit of custom CSS like so:

```css
.mytable {
  .Rtable1-footnote {
    font-style: italic;
  }
  .stratlabel {
    color: hotpink
  }
}
```

Now the result looks like this:

```{r}
#| label: css-styling-2
#| results: asis
tbl
```

<br>

![](take-me-down.jpg)

## Epilogue

In the process of writing this post I discovered that The Pretty Reckless have recorded a [cover](https://www.youtube.com/watch?v=PJ9Xy3RJoOA) of "Champagne Supernova" and I cannot stop laughing. It's good to laugh again.

