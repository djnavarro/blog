---
title: "A deep dive into table1"
description: "This is a subtitle"
date: "2024-06-21"
--- 

<!--------------- my typical setup ----------------->

```{r}
#| label: setup
#| include: false
very_wide <- 500
wide <- 136
narrow <- 76
options(width = narrow)
cache_images <- TRUE
set.seed(1)
```

<!--------------- post begins here ----------------->


```{r}
#| label: packages
#| message: false
#| warning: false
library(palmerpenguins)
library(table1)
library(dplyr)
```

The [table1](https://benjaminrich.github.io/table1/) package ([github link](https://github.com/benjaminrich/table1))

Basic usage:

```{r}
#| label: minimal-use
table1(~ island + bill_length_mm | species, penguins)
```

## Labels

Adding labels:

```{r}
#| label: labelling-1
label(penguins$island) <- "Island"
label(penguins$bill_length_mm) <- "Bill Length (mm)"

table1(~ island + bill_length_mm | species, penguins)
```

Using the `label<-()` function in table1 is how I've seen most people do it, but in truth there's nothing fancy here: all that the function does is set the "label" metadata attribute for the relevant object, so you could totally do it in base R via the `attr<-()` function:

```{r}
#| label: labelling-2
attr(penguins$bill_depth_mm, "label") <- "Bill Depth (mm)"

table1(~ island + bill_depth_mm | species, penguins)
```

However, I am slowly coming to like the `setLabel()` convenience function in table1 because it returns the labelled object and hence plays nicely with a dplyr workflow: 

```{r}
#| label: labelling-3
penguins <- penguins |> 
  mutate(
    flipper_length_mm = setLabel(flipper_length_mm, "Flipper Length (mm)"),
    body_mass_g = setLabel(body_mass_g, "Body Mass (g)"),
    sex = setLabel(sex, "Sex"),
    year = setLabel(year, "Year")
  )

table1(~ flipper_length_mm + body_mass_g + sex + year | species, penguins)
```

## Custom statistics

Okay so yeah you can do this to get geometric means and standard deviations...

```{r}
#| label: custom-render-1
table1(
  x = ~ flipper_length_mm + body_mass_g + sex + year | species, 
  data = penguins, 
  render.continuous = c("Geometric mean" = "GMEAN", "Geometric SD" = "GSD")
)
```

That's important in my job where almost every continuous variable is lognormal. You can see that this affects only the continuous variables not the discrete ones. Similarly you can do this...

```{r}
#| label: custom-render-2
table1(
  x = ~ flipper_length_mm + body_mass_g + sex | species, 
  data = penguins, 
  render.continuous = c(
    "10th percentile" = "q10", 
    "50th percentile" = "q50",
    "90th percentile" = "q90"
  )
)
```

The tricky part to this is that it's not documented. You have to dig into the [source code](https://github.com/benjaminrich/table1/blob/master/R/table1.R) to work out what "aliases" are supported, and it's not at all clear from the documentation how this mini-language works. Looking at the source code though you can see that the following names are understood for continuous variables:

- `"N"` and `"NMISS"` compute the number of non-missing observations and number of missing observations respectively
- The strings `"SUM"`, `"MEAN"`, `"SD"`, `"MEDIAN"`, `"MIN"`, and `"MAX"` are all translated to the functions of the same name (e.g., `"SUM"` produces a call to `sum()`)
- `"CV"` computes the coefficient of variation, i.e., 100 times the standard deviation divided by the absolute value of the mean
- `"GMEAN"`, `"GSD"`, and `"GCV"` compute the geometric mean, geometric standard deviation, and geometric coefficient of variation
- The strings `q01`, `q02.5`, `"q05"`, `"q10"`, `"q25"`, `"q50"`, `"q75"`, `"q90"`, `"q95"`, `"q97.5"`, and `"q99"` are understood, and compute the relevant quantiles (e.g., `"q25"` is translated as a function call that computes the 25th percentile)
- Along the same lines `"Q1"`, `"Q2"`, and `"Q3"` are used to compute quartiles (25th, 50th, and 75th percentiles), and `"T1"` and `"T2"` are used for tertiles (33rd and 67th percentiles)
- `"IQR"` computes the interquartile range

In all cases (except for `"NMISS"`, obviously) the statistics are computed after removing missing values.

However, you don't have to use this mini-language. You can instead write your own function that takes the data as input and returns a vector of strings to be printed into the table. As an example, here's how you would do the same thing as the previous example by supplying the function explicitly:

```{r}
#| label: custom-render-3
render_quantiles <- function(x, ...) {
  vals <- quantile(x, probs = c(.1, .5, .9), na.rm = TRUE, names = FALSE)
  strs <- c(
    "",
    "10th percentile" = vals[1],
    "50th percentile" = vals[2],
    "90th percentile" = vals[3]
  )
  return(strs)
}
```

The `render_quantiles()` function returns a named vector of strings: the names become the row labels (in the leftmost column of the table), and the values are printed into the table itself. 

Here's another example that is appropriate for discrete variable:

```{r}
render_counts <- function(x, ...) {
  c("", table(stringr::str_to_title(x)))
}
```

Having defined our render functions, we produce the table like this:

```{r}
#| label: custom-render-4
table1(
  x = ~ flipper_length_mm + body_mass_g + sex | species, 
  data = penguins, 
  render.continuous = render_quantiles,
  render.categorical = render_counts
)
```

Notice, however, that neither of these two functions affect the row in the table that handles the missing values. If you want to change that, you need to specify another function:

```{r}
#| label: custom-render-5
render_missing <- function(x, ...) {
  c("Missing" = sum(is.na(x)))
}

table1(
  x = ~ flipper_length_mm + body_mass_g + sex | species, 
  data = penguins, 
  render.continuous = render_quantiles,
  render.categorical = render_counts,
  render.missing = render_missing
)
```

There's still a bit of a mystery here, because the `table1()` function doesn't have arguments `render.continuous`, `render.categorical`, or `render.missing`: instead, it has a `render` argument. What's actually going on here is that the default value for `render` is the `render.default()` function exported by table1, and `render.default()` accepts `render.continuous`, `render.categorical`, or `render.missing` as arguments. In other words, what's happening in the code above is that my custom functions end up being passed to `render.default()` via the dots. 

There's nothing to prevent you from bypassing this whole process by writing your own render function that handles *all* the input variables. For example, here's a very simple rendering function that counts the number of non-missing observations, and prints it in the same row as the variable name:

```{r}
#| label: custom-render-6
render_n <- function(x, ...) sum(!is.na(x))

table1(
  x = ~ flipper_length_mm + body_mass_g + sex | species, 
  data = penguins, 
  render = render_n
)
```

## Tweaking tables

Two levels of stratification:

```{r}
#| label: table-tweak-1
table1(
  x = ~ flipper_length_mm + body_mass_g | species * sex,
  data = penguins |> filter(!is.na(sex))
)
```

Removing the overall column:

```{r}
#| label: table-tweak-2
table1(
  x = ~ flipper_length_mm + body_mass_g | species,
  data = penguins,
  overall = FALSE
)
```

Tweaking the header row, adding footnotes, adding captions etc:

```{r}
#| label: table-tweak-3
table1(
  x = ~ flipper_length_mm + body_mass_g | species,
  data = penguins,
  overall = "All Species",
  rowlabelhead = "Measurement",
  footnote = "Created using table1 and palmerpenguins"
)
```

Adding extra columns:

```{r}
render_p_value <- function(x, ...) {
  dat <- bind_rows(
    purrr::map(x, ~ data.frame(value = .)), 
    .id = "group"
  )
  mod <- aov(value ~ group, dat)
  p <- summary(mod)[[1]][1, 5]
  return(scales::label_pvalue()(p))
}

render_mean_sd <- function(x, ...) {
  paste0(
    round(mean(x, na.rm = TRUE), 1), 
    " (", 
    round(sd(x, na.rm = TRUE), 1), 
    ")"
  )
}

table1(
  x = ~ flipper_length_mm + body_mass_g | species,
  data = penguins,
  render = render_mean_sd,
  extra.col = list("p-value" = render_p_value)
)
```
