---
title: "A short post about p-splines"
description: "Yes, this is also secretly about GAMLSS regression"
date: "2025-09-06"
categories: ["statistics", "R"]
knitr:
  opts_chunk: 
    dev.args:
      bg: "#00000000"
--- 

<!--------------- my typical setup ----------------->

```{r}
#| label: setup
#| include: false
blog_dir <- rprojroot::find_root_file(criterion = rprojroot::has_file("_quarto.yml"))
source(fs::path(blog_dir, "shared", "common.R"))
ggplot2::theme_set(theme_custom())
set.seed(1)
```

<!--------------- post begins here ----------------->

```{r}
#| message: false
library(dplyr)
library(purrr)
library(tibble)
library(ggplot2)
```

This is a post about penalised splines, and lets be brutally honest I do not care for penalised splines any more than I care for the [Box-Cox power exponential distribution](/posts/2025-08-02_box-cox-power-exponential/) that I wittered on about in the last post. I did not care about the BCPE then and I do not care about P-splines now. Unfortunately, in much the same way that I had to learn about the BCPE distribution in order to understand the [GAMLSS regression](https://en.wikipedia.org/wiki/Generalized_additive_model_for_location,_scale_and_shape) framework that I'm going to talk about in the [next post](/posts/2025-09-07_gamlss/), so much so that my BCPE notes became their own post, I have fallen prey to my own vices and again found myself through the looking glass, shaving an unhappy yak, and writing about a topic very different to the one I originally intended to. 

Oh well.

## Splines

A [spline](https://en.wikipedia.org/wiki/Spline_(mathematics)) is just a piecewise polynomial, and for the sake of my sanity I'm only going to consider polynomials in a single variable $x$, and consider a spline function $f(x)$ defined over the interval $[a, b]$. To build the spline, we partition the interval $[a, b]$ into $m$ disjoint regions $r_1, r_2, \ldots, r_m$, whose edges are defined by a vector of **knot** points $\mathbf{k} = (k_0, k_1, \ldots, k_m)$.^[Conventionally, the knot points are denoted $t$ but I think that's stupid and the number of knots uses $k$ as the notation but honestly I think that's stupid and just makes it harder to understand.] If we order the knot points such that $k_i \leq k_{i+1}$ and set $k_0 = a$ and $k_m = b$, then the $i$-th region corresponds to the interval $[k_{i-1}, k_i]$ between two successive knots.^[I suppose if I were being nitpicky enough to define the partition properly I would be a bit more precise and use half-open intervals like $[k_{i-1}, k_i)$ and then make a special case for the final interval by making that one closed, i.e., $[k_{m-1}, k_m]$, but this isn't the kind of post where I'm going to be that technical, and frankly even if I tried I'd probably just fuck it up.] Given this partition we can then define a continuous spline function in terms of $m$ distinct polynomial functions $p_1(x), p_2(x), \ldots p_m(x)$, one for each subinterval. Our spline function is just a fancy if-then rule. If the point $x$ lies within region $r_i$, use the polynomial $p_i(x)$:

$$
f(x) = 
\left\{
\begin{array}{rcl}
p_1(x) &\mbox{if}& x \in r_1 \\
p_2(x) &\mbox{if}& x \in r_2 \\
\ldots \\
p_k(x) &\mbox{if}& x \in r_k \\
\end{array}
\right.
$$

To ensure that the resulting spline function $f(x)$ is continuous, the polynomials must be constrained so the polynomials on either side of the knot point have the same value at the knot point that connects them.^[To write it slightly more tediously in order to pretend that the author is smart, she notes that the constraint is that $p_i(k_i) = p_{i+1}(k_i)$ for $i = 1, 2, \ldots m-1$. This adds precisely nothing of value to the post, of course. However, in deference to her undiagnosed-but-painfully-obvious autism she will dump it in a footnote and move on.] To help get a feel for how splines work, I wrote `piecewise()` function that takes knot vector and a list of functions as inputs, and returns the corresponding piecewise polynomial function `f`. The source for `piecewise()` isn't very interesting but for what it's worth it's hidden below the fold here:

```{r}
#| code-fold: true
#| code-summary: Code for piecewise()
piecewise <- function(knots, funs) { 
  f <- function(x) {
    k <- length(funs)
    n <- length(x)
    y <- rep(NA_real_, n)
    r <- rep(NA_integer_, n)
    for (i in 1:k) {
      ind <- x >= knots[i] & x < knots[i + 1]
      r[ind] <- i
      y[ind] <- funs[[i]](x[ind])
    }
    ind <- x == knots[k + 1]
    r[ind] <- k
    y[ind] <- funs[[k]](x[ind])
    attr(y, "region") <- r
    y
  }
  attr(f, "knots") <- knots
  attr(f, "funs") <- funs
  return(f)
}
```

In my implementation the spline function is undefined outside the interval $[a, b]$ so the values outside the interval are always `NA`, but I suppose other choices could be made. It's not important: my `piecewise()` function isn't intended for serious use, it's just something I wrote so that I could play around with simple splines before moving into the world of pain that is B-splines and P-splines. Armed with this entirely uninteresting tool, let's consider the following example. At the risk of stretching the imagination beyond the limits of human capability, let's try to pretend that I am deeply interested in the following spline: 

$$
f(x) = 
\left\{
\begin{array}{rcl}
2x^2 - 3x + 2 & \mbox{if} & x \in [0, 1] \\
x & \mbox{if} & x \in [1, 3] \\
-x^3 + 28x - 54 &\mbox{if} & x \in [3, 3.5] \\
\end{array}
\right.
$$

It is comprised of three polynomials of different [degree](https://en.wikipedia.org/wiki/Degree_of_a_polynomial): there's a linear function (degree 1), a quadratic function (degree 2), and a cubic function (degree 3). So the degree of our spline is at most 3. For reasons that escape me, if the maximum degree of any of the polynomial pieces is $d$, we say that the spline is of **order** $d+1$. So this is a spline of order 4. Again, thrilling. But let's suppose I want to implement this spline using my `piecewise()` function. All I need to do is this:

```{r}
f <- piecewise(
  knots = c(0, 1, 3, 3.5),
  funs = list(
    \(x) 2*x^2 - 3*x + 2, # left piece is quadratic
    \(x) x,               # middle piece is linear
    \(x) -x^3 + 28*x - 54 # right piece is cubic
  )
) 
```

Yay. To get a sense of what the function looks like I'll also define a `plot_piecewise()` function that plots the spline over the interval $[a, b]$, but it's really boring so I'm again going to hide the code behind the fold and jump straight to plotting the spline function `f`:

```{r}
#| code-fold: true
#| code-summary: Code for plot_piecewise()
plot_piecewise <- function(f, n = 5000L) {

  lb <- min(attr(f, "knots"))
  ub <- max(attr(f, "knots"))
  x <- seq(lb, ub, length.out = n)

  dat_sp <- tibble(
    x = x, 
    y = f(x),
    r = factor(attr(y, "region"))
  )

  dat_pn <- attr(f, "funs") |> 
    map(\(p) tibble(x = x, y = p(x))) |> 
    bind_rows(.id = "r") |> 
    mutate(r = factor(r))

  dat_kn <- tibble(
    x = attr(f, "knots"),
    y = f(x)
  )

  plt <- ggplot() +
    geom_path(data = dat_sp, aes(x, y, color = r), linewidth = 5, alpha = .25) + 
    geom_path(data = dat_pn, aes(x, y, color = r)) +
    geom_path(data = dat_sp, aes(x, y, group = r), linewidth = 1) + 
    geom_point(data = dat_kn, mapping = aes(x, y), size = 3) + 
    labs(x = "x", y = "f(x)", color = "polynomial")

  return(plt)
}
```

```{r}
#| warning: false
#| label: piecewise-0
plot_piecewise(f) + lims(y = c(0, 4))
```

First derivatives are continuous:

```{r}
#| warning: false
#| label: piecewise-1
f_deriv1 <- piecewise(
  knots = c(0, 1, 3, 3.5),
  funs = list(
    \(x) 4*x - 3,       # 1st derivative of left piece
    \(x) 1,             # 1st derivative of middle piece 
    \(x) -3 * x^2 + 28  # 1st derivative of right piece
  )
)
plot_piecewise(f_deriv1) + lims(y = c(-10, 2))
```

Second derivatives are not:

```{r}
#| warning: false
#| label: piecewise-2
f_deriv2 <- piecewise(
  knots = c(0, 1, 3, 3.5),
  funs = list(
    \(x) 4,      # 2nd derivative of left piece
    \(x) 0,      # 2nd derivative of middle piece
    \(x) -6 * x  # 2nd derivative of right piece
  )
)
plot_piecewise(f_deriv2)
```

To put it in slightly fancier language, since the 0th derivative (the function) and 1st derivative are continuous everywhere we say that our example spline has **smoothness 1 everywhere**. However, because the 2nd derivatives are discontinuous at the knot points, the spline does not have smoothness 2 at the knots. More generally, for the spline to have [smoothness](https://en.wikipedia.org/wiki/Smoothness) $s$ at a knot, the derivatives of orders $0, 1, \ldots, s$ of adjacent polynomials must all be equal at the knot point.

Yeah, yeah, whatever.

## B-splines

Next comes the "basis spline" trick. As it happens, you can rewrite *any* spline as a weighted sum of so-called B-splines. Let $f_{m, \mathbf{k}}(x)$ denote a spline function of order $m$ with knot vector $\mathbf{k}$. Then 

$$
f_{m, \mathbf{k}}(x) = \sum_i \alpha_i \ B_{i,m}(x)
$$

where $B_{i,m}(x)$ is a **basis spline** ([B-spline](https://en.wikipedia.org/wiki/B-spline)) function defined with respect to the same knot vector $\mathbf{k}$, and the coefficient $\alpha_i$ define the weight assigned to the $i$-th basis spline of order $m$. The basis spline functions are themselves splines, but they are a specific set of spline functions designed to give us the result above.^[Something something about B-splines forming a basis for the spline function space or whatever.] From the perspective of a data analyst who wants to fit an arbitrary spline function to a set of points, it can be awfully convenient to work with basis splines because the problem of estimating the unknown spline function $f(x)$ can be transformed into the problem of estimating the coefficients $\alpha$. 

## P-splines


