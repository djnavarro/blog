---
title: "Use of flextable"
description: "In which the author explores the flextable R package for table construction, and gushes far too much about the work of Iain M. Banks"
date: "2024-07-04"
image: "cover.jpg"
image-alt: "Cover art to 'Use of Weapons' by Iain M. Banks"
categories: ["R", "Data Wrangling"]
--- 

<!--------------- my typical setup ----------------->

```{r}
#| label: setup
#| include: false
very_wide <- 500
wide <- 136
narrow <- 76
options(width = narrow)
cache_images <- TRUE
set.seed(1)
```

<!--------------- post begins here ----------------->

- [flextable package](https://davidgohel.github.io/flextable/)
- [flextable book](https://ardata-fr.github.io/flextable-book/)

There are nine books that make up the Culture novels, starting with the 1988 novel *Consider Phlebas* and finishing with *The Hydrogen Sonata* in 2012. 

```{r}
#| echo: false
#| message: false
readr::read_csv("culture.csv", col_types = "ciccccc") |> 
  dplyr::mutate(title = paste0("[", title, "](", url, ")")) |> 
  dplyr::select(title, image, description) |> 
  flextable::flextable(col_keys = c("title", "image", "description")) |> 
  flextable::set_header_labels(
    title = "Book Title",
    description = "Description",
    image = "Cover"
  ) |> 
  ftExtra::colformat_md(j = "title") |> 
  flextable::colformat_image(j = "image", width = .75, height = 1.2) |> 
  flextable::autofit()
```

## Basic use

To get started, I'll load all the packages needed to create the various tables that appeatr in this post:

```{r}
#| message: false
library(flextable)
library(ftExtra)
library(tibble)
library(stringr)
library(dplyr)
library(tidyr)
library(readr)
library(ggplot2)
```

For the purposes of this post I put together a small data set using information taken from the [wikipedia page](https://en.wikipedia.org/wiki/Culture_series) on the Culture novels:

```{r}
novels <- read_csv("culture.csv", col_types = "ciccccc")
novels
```

To construct a table using a subset of these columns, we can use the `flextable()` function. In the simplest case, we pass a data fram to `flextable()` and we get an HTML table as output:

```{r}
novels |>
  select(title:isbn) |> 
  flextable()
```

This is a promising beginning, but it can be improved in any number of ways.

## Column widths

The most obvious shortcoming in the previous table is the column widths, which we can adjust manually by passing a vector of widths (in inches) as the `cwidth` argument to `flextable()`:

```{r}
novels |>
  select(title:isbn) |> 
  flextable(cwidth = c(3, 1, 4, 2))
```

There are situations where this manual control is helpful, but often you can avoid the tedious tinkering to get the widths right simply by using `autofit()` to select nice column widths:

```{r}
novels |>
  select(title:isbn) |> 
  flextable() |> 
  autofit()
```

## Column labels

Now that we have better-spaced columns, the thing that pops out at us next is the column headers. We can do better than using variable names as column headers. To do so we can use `set_header_labels()`, which takes name-value pairs as inputs, like this:

```{r}
novels |>
  select(title:isbn) |> 
  flextable(cwidth = c(3, 1, 4, 2)) |> 
  set_header_labels(
    title = "Book Title",
    publication_date = "Published",
    setting_date = "Story Date", 
    isbn = "ISBN"
  )
```

## Column formats

When deciding how to format the values displayed in the cells, flextable tries to supply sensible defaults for different data types, but you can override these defaults with the assistance of the `colformat_*()` functions:

- `colformat_char()`: Format character cells
- `colformat_date()`: Format date cells
- `colformat_datetime()`: Format datetime cells
- `colformat_double()`: Format numeric cells
- `colformat_image()`: Format cells as images
- `colformat_int()`: Format integer cells
- `colformat_lgl()`: Format logical cells
- `colformat_num()`: Format numeric cells

To give an example, the table we have so far doesn't display the publication dates very nicely. The default convention for numeric values uses commas as the "big mark" character (e.g., one million would be written "1,000,000" not "1000000"). That isn't very helpful in this case because the column should actually be interpreted as year, and by convention we normally write "1987" for the year rather than "1,987". We can fix this by using the `colformat_int()` function to set `big.mark = ""`:

```{r}
novels |>
  select(title:isbn) |> 
  flextable(cwidth = c(3, 1, 4, 2)) |> 
  set_header_labels(
    title = "Book Title",
    publication_date = "Published",
    setting_date = "Story Date", 
    isbn = "ISBN"
  ) |> 
  colformat_int(big.mark = "")
```

I'm pretty happy with the contents of this table (though I'll tweak the style later), so I'll store this as the `base` table that I can use it again:

```{r}
base <- novels |>
  select(title:isbn) |> 
  flextable(cwidth = c(3, 1, 4, 2)) |> 
  set_header_labels(
    title = "Book Title",
    publication_date = "Published",
    setting_date = "Story Date", 
    isbn = "ISBN"
  ) |> 
  colformat_int(big.mark = "")
```

You can define your own formatter function to be applied to specific columns by using the `set_formatter()` function. Suppose, for example, that I wanted the book titles to be shown in all-caps, and wanted to simplify the setting date to (a) remove the ambigious entries (b) drop the "c." for circa, (c) remove the "CE" string for current era, and (d) replace the "BCE" string with the older "BC" convention. I could do that as follows:

```{r}
base |> 
  set_formatter(
    title = str_to_upper,
    setting_date = function(x) x |> 
      str_replace_all("BCE", "BC") |> 
      str_remove_all("CE") |> 
      str_remove_all("c\\.") |> 
      str_remove_all("^(Varies|Unspe).*") |> 
      str_squish() 
  )
```

## Table themes

Theme functions are simpler than ggplot2. It's a function that takes a flextable as input and returns a flextable as ouput. Default is `theme_booktabs()` but there are several that come bundled with the package:

- `theme_alafoli()`
- `theme_apa()`
- `theme_booktabs()` (default)
- `theme_box()`
- `theme_tron()`
- `theme_tron_legacy()`
- `theme_vader()`
- `theme_vanilla()`
- `theme_zebra()`

Here are a few of them:

```{r}
base |> theme_box()
```

```{r}
base |> theme_alafoli()
```

```{r}
base |> theme_tron()
```

## Table defaults

At the time a table is constructed by calling `flextable()` a collection of default values are applied to the table. You can get a list of these values by calling `get_flextable_defaults()`, and you can modify them with `set_flextable_defaults()`

```{r}
set_flextable_defaults(
  font.color = "purple",
  background.color = "ghostwhite",
  table.layout = "autofit"
)

novels |> 
  select(title:isbn) |> 
  flextable()
```

These defaults are applied to any new table, which I don't want. So I'll restore defaults to their original values:

```{r}
init_flextable_defaults()
```

## Table parts

It's often helpful to define formatting rules that apply only to a subset of the table. For instance, we might want to use boldface text for the column headers but not the body of the table. Or perhaps some rows or columns should appear in a different colour for one reason or another. To do this effectively it is helpful to understand how flextables are structured. All flextables are comprised of three parts: a set of **header** rows at the top, a grid of cells in the table **body**, and a set of footer rows at the bottom. Many functions in flextable have a `part` argument that you can use to select one (or all) of these three parts. For example, the `bg()` function is used to set the background colour, and the example below takes our `base` table and gives the header a red background, the body a green background, and the footer a blue background:

```{r}
base |> 
  bg(bg = "#ff000040", part = "header") |> # red header
  bg(bg = "#00cc0040", part = "body") |>   # green body
  bg(bg = "#0000ff40", part = "footer") |> # blue footer
  theme_box()
```

As you can see from this output, the default in flextable is to have a single header row containing the column names, a body comprised of the data values in the table, and no footer at all. We can add extra content to the header and footer if we want using the `add_header_lines()` and `add_footer_lines()` functions:

```{r}
base |>
  add_header_lines("The Culture Novels") |> 
  add_footer_lines("by Iain M. Banks") |> 
  bg(bg = "#ff000040", part = "header") |> # red header
  bg(bg = "#00cc0040", part = "body") |>   # green body
  bg(bg = "#0000ff40", part = "footer") |> # blue footer
  theme_box()
```

Notice that the `add_header_lines()` and `add_footer_lines()` functions create extra rows that span all the cells in the table. Sometimes we might prefer a little more fine-grained control, by creating a new row that is subdivided into cells. We can do this with the `add_header_row()` and `add_footer_row()` functions:

```{r}
base |>
  add_header_row(
    values = c("A", "Header", "Row"), 
    colwidths = c(1, 2, 1)
  ) |> 
  add_footer_row(
    values = c("And", "A", "Footer", "Row"), 
    colwidths = c(1, 1, 1, 1)
  ) |> 
  bg(bg = "#ff000040", part = "header") |> # red header
  bg(bg = "#00cc0040", part = "body") |>   # green body
  bg(bg = "#0000ff40", part = "footer") |> # blue footer
  theme_box()
```

Notice that these new rows are subdivided into cells. For the footer, I've not merged anything so there are four cells in the footer row; whereas for the new header row there are only three cells because I merged two of them using the `colwidths` argument. 

If I were more serious about these particular tables, I'd use the `align()` function to tidy up the text alignment and other formatting in the new header and footer rows, but I'm not really interested in doing that here so I'll move on. 

## Row and column selectors

The `part` argument discussed in the previous section allows you to apply formatting rules selectively to the header, body, and footer of the table, but it doesn't let you apply rules selectively to a subset of rows or columns. If you need to do this, you can use the row selector argument `i` and the columns selector argument `j`. These selector arguments can be specified in three ways:

- Numerical values select rows or columns using their numerical index
- Character values can select one or more columns by name
- Formulas can be used to define a logical selection

It's a lot easier to understand when you see it in action. In this example, I use `i = 1:2` (selection by indices) to set the background colour for the top two rows to purple, and `i = ~ publication_date > 2000` (logical selection) to set the background colour for the bottom three rows to orange: 

```{r}
base |> 
  bg(i = 1:2, bg = "#cc22cc40") |>                    # purple rows
  bg(i = ~ publication_date > 2000, bg = "#ffa50040") # orange rows
```

Along the same lines the next example uses `j = 1:2` to set the background colour for the first two columns to brown, and `j = "isbn"` (selection by name) to set a teal background for the fourth column:

```{r}
base |> 
  bg(j = 1:2, bg = "#80471c40") |>  # brown columns
  bg(j = "isbn", bg = "#00808040")  # teal column
```

Notice that these background colours are applied only to the body of the table. However, the `bg()` function has a `part` argument, and we can extend this background shading to the entire table by settingh `part = "all"`":

```{r}
base |> 
  bg(j = 1:2, bg = "#80471c40", part = "all") |>  # brown columns
  bg(j = "isbn", bg = "#00808040", part = "all")  # teal column
```

If you specify a row selection and column selection, the formatting rule is applied to those cells that satisfy both criteria:

```{r}
base |> 
  bg(i = 1:2, j = 3:4, bg = "#cc22cc40") |>   # purple cells
  bg(i = 7:8, j = 1:2, bg = "#00808040")      # teal cells  
```

Note that formatting rules are applied sequentially, allowing you to override previously defined formatting. For example, in this example I set the top two rows to purple, then set the rightmost column to teal, and then finally set the bottom three rows to orange. The result looks like this:

```{r}
base |> 
  bg(i = 1:2, bg = "#cc22cc40") |>                    # purple rows
  bg(j = "isbn", bg = "#00808040") |>                 # teal column
  bg(i = ~ publication_date > 2000, bg = "#ffa50040") # orange rows
```

## Visual style

Controlling the appearance of the text:

- `font()`: Set font
- `fontsize()`: Set font size
- `italic()`: Set italic font
- `bold()`: Set bold font
- `color()`: Set font color
- `highlight()`: Text highlight color
- `rotate()`: Rotate cell text

Controlling alignment:

- `align()`: Set horizontal alignment 
- `align_text_col()`: Set horizontal alignment for text columns
- `align_nottext_col()`: Set horizontal alignment for non-text columns
- `valign()`: Set vertical alignment

Cell appearance:

- `bg()`: Set background color
- `padding()`: Set paragraph paddings
- `line_spacing()`: Set text alignment

Other:

- `style()`: Set flextable style
- `tab_settings()`: Set tabulation marks configuration
- `empty_blanks()`: Make blank columns as transparent 

```{r}
base |>
  bg(part = "header", bg = "grey30") |> 
  color(part = "header", color = "ghostwhite") |> 
  italic(j = "title")
```


## Borders

Horizontal and vertical lines:

- `hline()`: Set horizontal borders
- `hline_bottom()`: Set bottom horizontal border
- `hline_top()`: Set top horizontal border
- `vline()`: Set vertical borders
- `vline_left()`: Set left vertical borders
- `vline_right()`: Set right vertical borders

Borders:

- `border_inner()`: Set vertical and horizontal inner borders
- `border_inner_h()`: Set horizontal inner borders
- `border_inner_v()`: Set vertical inner borders
- `border_outer()`: Set outer borders
- `border_remove()`: Remove borders
- `surround()`: Set borders for a selection of cells 

Others:

- `fp_border_default()`: Border formatting properties
- `fix_border_issues()`: Fix border issues when cell are merged

```{r}
base |>
  vline(j = "title") |> 
  border_outer(
    border = fp_border_default(
      color = "black", 
      width = 2
    )
  )
```

## Cell contents

Use `compose()` or `mk_par()` (the latter is an alias to make life easier in case of conficts between `purrr::compose()` and `flextable::compose()` to build cell contents from constituent parts:

```{r}
base |> 
  compose(
    j = "publication_date",
    value = as_paragraph(as.character(publication_date), " CE")
  )
```

Fancier formatting to a specific chunk using `as_chunk()` and `fp_text_default()`. Notice that `color()` here is just a convenience function. I could do the same thing using `compose()`, `as_paragraph()`, `as_chunk()`, and `fp_text_default()`:

```{r}
base |> 
  compose(
    i = ~ title == "Use of Weapons",
    j = "title",
    value = as_paragraph(as_chunk(
      title, 
      props = fp_text_default(color = "blue")
    ))
  ) |> 
  color(
    i = ~ title == "Surface Detail",
    j = "title",
    color = "red" 
  )
```

## Merging cells

To construct the data for the table I put together a data set containing a [list of ships](https://theculture.fandom.com/wiki/List_of_spacecraft) that are referred to in the Culture novels. I'll use that to count the number of ships from each civilisation in each of the novels:

```{r}
ships <- read_csv("ship-list.csv", show_col_types = FALSE)

ship_count <- ships |> 
  mutate(Civilisation = case_when(
    str_detect(Civilisation, "^Culture ") ~ "Culture",
    str_detect(Civilisation, "^Non-aligned ") ~ "Non-aligned",
    TRUE ~ Civilisation
  )) |> 
  group_by(Novel, Civilisation) |>
  count(name = "Ships") |> 
  ungroup() |> 
  arrange(Novel, desc(Ships))

ship_count
```

```{r}
ship_count |> 
  flextable() |> 
  autofit() |> 
  theme_box()
```

```{r}
ship_count |> 
  flextable() |> 
  autofit() |> 
  merge_v(j = "Novel") |> 
  theme_box()
```

```{r}
ship_count |> 
  as_grouped_data(groups = "Novel") |> 
  flextable() |> 
  autofit()
```

## Markdown columns

Flextable doesn't natively support markdown syntax in data columns, but the [ftExtra](https://ftextra.atusy.net/) package provides this.

```{r}
novels |> 
  mutate(title = paste0("[", title, "](", url, ")")) |> 
  select(title, description) |> 
  flextable(col_keys = c("title", "description")) |> 
  set_header_labels(
    title = "Book Title",
    description = "Description"
  ) |> 
  colformat_md(j = "title") |> 
  autofit()
```

## Inserting equations

Markdown columns are a very handy tool whenever you have tables that need to include equations or other kinds of cell content that have very specific formatting requirements. 

```{r}
tbl <- tribble(
  ~expression,                  ~text,
  "x^2^ + y^2^ = 1",            "Formula for the unit circle",
  "**x** = (x~1~, ..., x~n~)" , "A vector of length n"
)
tbl
```

```{r}
tbl |> 
  flextable() |> 
  colformat_md(j = "expression") |> 
  autofit()
```

Math support:

```{r}
tbl <- tribble(
  ~expression,                       ~text,
  "$x^2 + y^2 = 1$",                 "Formula for the unit circle",
  "$\\bm{x} = (x_1, \\ldots, x_n)$", "A vector of length $n$",
  "$\\mathcal{R}^n$",                 "$n$-dimensional real space",
  "$e^{i\\pi} + 1 = 0$",             "Euler's identity^[A special case of Euler's formula]"
)
tbl
```

```{r}
tbl |> 
  flextable() |> 
  colformat_md() |> 
  autofit()
```

## Inserting images

```{r}
novels |> 
  mutate(title = paste0("[", title, "](", url, ")")) |> 
  select(title, image, description) |> 
  flextable(col_keys = c("title", "image", "description")) |> 
  set_header_labels(
    title = "Book Title",
    description = "Description",
    image = "Cover"
  ) |> 
  colformat_md(j = "title") |> 
  colformat_image(j = "image", width = .75, height = 1.2) |> 
  autofit()
```

## Inserting plots

```{r}
plot_name_lengths <- function(novel) {
  ships |> 
    filter(Novel == novel) |> 
    mutate(len = Name |> replace_na("") |> nchar()) |> 
    arrange(desc(len)) |> 
    mutate(pos = row_number()) |> 
    ggplot(aes(pos, len)) + 
    geom_point() + 
    geom_segment(aes(xend = pos, yend = 0)) + 
    lims(x = c(0, 60), y = c(0, 65)) + 
    theme_void()
}

ship_name_length <- tibble(
  title = novels$title,
  plot = lapply(title, plot_name_lengths)
)

ship_name_length
```

```{r}
ship_name_length |> 
  flextable(cwidth = c(2, 4)) |> 
  set_header_labels(
    title = "Title", 
    plot = "Ship Name Lengths"
  ) |> 
  compose(
    j = "plot", 
    value = as_paragraph(
      gg_chunk(value = plot, width = 6, height = .8)
    )
  ) |> 
  align_nottext_col(align = "center")
```
