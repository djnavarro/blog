---
title: "Use of flextable"
description: "In which the author explores the flextable R package for table construction, and gushes far too much about the work of Iain M. Banks"
date: "2024-07-04"
image: "cover.jpg"
image-alt: "Cover art to 'Use of Weapons' by Iain M. Banks"
categories: ["R", "Data Wrangling"]
--- 

<!--------------- my typical setup ----------------->

```{r}
#| label: setup
#| include: false
very_wide <- 500
wide <- 136
narrow <- 76
options(width = narrow)
cache_images <- TRUE
set.seed(1)
```

<!--------------- post begins here ----------------->

> "Tell me, what is happiness?" <br>
> "Happiness? Happiness ... is to wake up, on a bright spring morning, after an exhausting first night spent with a beautiful ... passionate ... multi-murderess." <br>
> "... Shit, is *that* all?" <br>
> &nbsp; &nbsp; &nbsp; &nbsp; -- *Use of Weapons*

The year is 1994. A closeted, miserable girl sits on the floor in the library. She is 16, it is her first year at university, and her first time living in a city. She knows very little about the world, or herself for that matter. But the library has a copy of *Use of Weapons*, and for the moment at least she is somewhere else. 

This is a post about making tables in R using the rather-lovely [flextable package](https://davidgohel.github.io/flextable/), documented terribly well in the [flextable book](https://ardata-fr.github.io/flextable-book/). I use flextable a lot at work, but until recently I hadn't explored it very thoroughly. Last week I ran into something I didn't know how to solve^[It was a markdown column issue, which I now realise is easy to address.] and found myself diving deeper and inevitably, ended up writing up some notes. 
It is also a post about the [Culture novels](https://en.wikipedia.org/wiki/Culture_series) by Iain Banks, one of my all-time favourite science fiction series, and the work of Iain Banks more generally I suppose. 

I discovered the Culture novels as an undergraduate, and have loved them deeply ever since. There are nine books that make up the Culture novels, starting with the 1988 novel *Consider Phlebas* and finishing with *The Hydrogen Sonata* in 2012. Each of the books is a standalone story set in the same universe, and largely revolve around the Culture, a utopian anarchic society of hedonistic humans and scheming hyper-intelligent machines. I'd imagine that a great many people in my usual audience are familiar with the Culture novels, but for those who are not here's the wikipedia summary of each of the novels:

```{r}
#| echo: false
#| message: false
readr::read_csv("culture.csv", col_types = "ciccccc") |> 
  dplyr::mutate(title = paste0("[", title, "](", url, ")")) |> 
  dplyr::select(title, image, description) |> 
  flextable::flextable(col_keys = c("title", "image", "description")) |> 
  flextable::set_header_labels(
    title = "Book Title",
    description = "Description",
    image = "Cover"
  ) |> 
  ftExtra::colformat_md(j = "title") |> 
  flextable::colformat_image(j = "image", width = .75, height = 1.2) |> 
  flextable::autofit()
```

I made this table in R using flextable. It's surprisingly easy to do, once you wrap your head around how the package works. So let's have a look at how it all works, shall we?

```{r}
#| message: false
library(flextable)
library(ftExtra)
library(tibble)
library(stringr)
library(dplyr)
library(tidyr)
library(readr)
library(ggplot2)
```

## Getting started

> All great promises are threats, I suppose, to the way things have been until that point, to some aspect of our lives, and we all suddenly become conservative, even though we want and need what the promise holds, and look forward to the promised change at the same time. <br>
> &nbsp; &nbsp; -- *The Hydrogen Sonata*

For the purposes of this post I put together a small data set using information taken from the [wikipedia page](https://en.wikipedia.org/wiki/Culture_series) on the Culture novels:

```{r}
novels <- read_csv("culture.csv", col_types = "ciccccc")
novels
```

To construct a table using a subset of these columns, we can use the `flextable()` function. In the simplest case, we pass a data fram to `flextable()` and we get an HTML table as output:

```{r}
novels |>
  select(title:isbn) |> 
  flextable()
```

This is a promising beginning, but it can be improved in any number of ways.

## Column widths

> He was tall and very dark-skinned and he had fabulously blond hair and a voice that could raise bumps on your skin at a hundred meters, or, better still, millimeters. <br>
> &nbsp; &nbsp; -- *Excession*

The most obvious shortcoming in the previous table is the column widths, which we can adjust manually by passing a vector of widths (in inches) as the `cwidth` argument to `flextable()`:

```{r}
novels |>
  select(title:isbn) |> 
  flextable(cwidth = c(3, 1, 4, 2))
```

There are situations where this manual control is helpful, but often you can avoid the tedious tinkering to get the widths right simply by using `autofit()` to select nice column widths:

```{r}
novels |>
  select(title:isbn) |> 
  flextable() |> 
  autofit()
```

## Column labels

> YOU MAY ENTER. <br>
> THERE IS DEATH HERE. <br>
> BE WARNED. <br>
> &nbsp; &nbsp; -- *Consider Phlebas*


Now that we have better-spaced columns, the thing that pops out at us next is the column headers. We can do better than using variable names as column headers. To do so we can use `set_header_labels()`, which takes name-value pairs as inputs, like this:

```{r}
novels |>
  select(title:isbn) |> 
  flextable(cwidth = c(3, 1, 4, 2)) |> 
  set_header_labels(
    title = "Book Title",
    publication_date = "Published",
    setting_date = "Story Date", 
    isbn = "ISBN"
  )
```

## Column formats

> He looked up from it at the stars again, and the view was warped and distorted by something in his eyes, which at first he thought was rain. <br>
> &nbsp; &nbsp; --*The Player of Games*

When deciding how to format the values displayed in the cells, flextable tries to supply sensible defaults for different data types, but you can override these defaults with the assistance of the `colformat_*()` functions:

- `colformat_char()`: Format character cells
- `colformat_date()`: Format date cells
- `colformat_datetime()`: Format datetime cells
- `colformat_double()`: Format numeric cells
- `colformat_image()`: Format cells as images
- `colformat_int()`: Format integer cells
- `colformat_lgl()`: Format logical cells
- `colformat_num()`: Format numeric cells

To give an example, the table we have so far doesn't display the publication dates very nicely. The default convention for numeric values uses commas as the "big mark" character (e.g., one million would be written "1,000,000" not "1000000"). That isn't very helpful in this case because the column should actually be interpreted as year, and by convention we normally write "1987" for the year rather than "1,987". We can fix this by using the `colformat_int()` function to set `big.mark = ""`:

```{r}
novels |>
  select(title:isbn) |> 
  flextable(cwidth = c(3, 1, 4, 2)) |> 
  set_header_labels(
    title = "Book Title",
    publication_date = "Published",
    setting_date = "Story Date", 
    isbn = "ISBN"
  ) |> 
  colformat_int(big.mark = "")
```

I'm pretty happy with the contents of this table (though I'll tweak the style later), so I'll store this as the `base` table that I can use it again:

```{r}
base <- novels |>
  select(title:isbn) |> 
  flextable(cwidth = c(3, 1, 4, 2)) |> 
  set_header_labels(
    title = "Book Title",
    publication_date = "Published",
    setting_date = "Story Date", 
    isbn = "ISBN"
  ) |> 
  colformat_int(big.mark = "")
```

You can define your own formatter function to be applied to specific columns by using the `set_formatter()` function. Suppose, for example, that I wanted the book titles to be shown in all-caps, and wanted to simplify the setting date to (a) remove the ambigious entries (b) drop the "c." for circa, (c) remove the "CE" string for current era, and (d) replace the "BCE" string with the older "BC" convention. I could do that as follows:

```{r}
base |> 
  set_formatter(
    title = str_to_upper,
    setting_date = function(x) x |> 
      str_replace_all("BCE", "BC") |> 
      str_remove_all("CE") |> 
      str_remove_all("c\\.") |> 
      str_remove_all("^(Varies|Unspe).*") |> 
      str_squish() 
  )
```

## Table themes

> Just before the *Clear Air Turbulence* went back into warp and its crew sat down at table, the ship expelled the limp corpse of Zallin. Where it had found a live man in a suit, it left a dead youth in shorts and a tattered shirt, tumbling and freezing while a thin shell of air molecules expanded around the body, like an image of departing life. <br>
> &nbsp; &nbsp; -- *Consider Phlebas*

Theme functions are simpler than ggplot2. It's a function that takes a flextable as input and returns a flextable as ouput. Default is `theme_booktabs()` but there are several that come bundled with the package:

- `theme_alafoli()`
- `theme_apa()`
- `theme_booktabs()` (default)
- `theme_box()`
- `theme_tron()`
- `theme_tron_legacy()`
- `theme_vader()`
- `theme_vanilla()`
- `theme_zebra()`

Here are a few of them:

```{r}
base |> theme_box()
```

```{r}
base |> theme_alafoli()
```

```{r}
base |> theme_tron()
```

## Table defaults

> In life you hoped to do what you could but mostly you did what you were told and that was the end of it. <br>
> &nbsp; &nbsp; -- *Matter*

At the time a table is constructed by calling `flextable()` a collection of default values are applied to the table. You can get a list of these values by calling `get_flextable_defaults()`, and you can modify them with `set_flextable_defaults()`

```{r}
set_flextable_defaults(
  font.color = "purple",
  background.color = "ghostwhite",
  table.layout = "autofit"
)

novels |> 
  select(title:isbn) |> 
  flextable()
```

These defaults are applied to any new table, which I don't want. So I'll restore defaults to their original values:

```{r}
init_flextable_defaults()
```

## Table parts

> The rose-red stones were jumbled and askew. Most of the streets were gone, long ago buried under the soft encroaching sands. Ruined arches, fallen lintels, collapsed walls littered the slopes of sand; at the scalloped edge of shore, brushed by the waves, more fallen blocks broke the incoming waves. A little out to sea, tilted towers and the fragments of an arch rose from the waters, sucked at by the waves like the bones of the long-drowned. <br>
> &nbsp; &nbsp; -- *The Bridge*


It's often helpful to define formatting rules that apply only to a subset of the table. For instance, we might want to use boldface text for the column headers but not the body of the table. Or perhaps some rows or columns should appear in a different colour for one reason or another. To do this effectively it is helpful to understand how flextables are structured. All flextables are comprised of three parts: a set of **header** rows at the top, a grid of cells in the table **body**, and a set of footer rows at the bottom. Many functions in flextable have a `part` argument that you can use to select one (or all) of these three parts. For example, the `bg()` function is used to set the background colour, and the example below takes our `base` table and gives the header a red background, the body a green background, and the footer a blue background:

```{r}
base |> 
  bg(bg = "#ff000040", part = "header") |> # red header
  bg(bg = "#00cc0040", part = "body") |>   # green body
  bg(bg = "#0000ff40", part = "footer") |> # blue footer
  theme_box()
```

As you can see from this output, the default in flextable is to have a single header row containing the column names, a body comprised of the data values in the table, and no footer at all. We can add extra content to the header and footer if we want using the `add_header_lines()` and `add_footer_lines()` functions:

```{r}
base |>
  add_header_lines("The Culture Novels") |> 
  add_footer_lines("by Iain M. Banks") |> 
  bg(bg = "#ff000040", part = "header") |> # red header
  bg(bg = "#00cc0040", part = "body") |>   # green body
  bg(bg = "#0000ff40", part = "footer") |> # blue footer
  theme_box()
```

Notice that the `add_header_lines()` and `add_footer_lines()` functions create extra rows that span all the cells in the table. Sometimes we might prefer a little more fine-grained control, by creating a new row that is subdivided into cells. We can do this with the `add_header_row()` and `add_footer_row()` functions:

```{r}
base |>
  add_header_row(
    values = c("A", "Header", "Row"), 
    colwidths = c(1, 2, 1)
  ) |> 
  add_footer_row(
    values = c("And", "A", "Footer", "Row"), 
    colwidths = c(1, 1, 1, 1)
  ) |> 
  bg(bg = "#ff000040", part = "header") |> # red header
  bg(bg = "#00cc0040", part = "body") |>   # green body
  bg(bg = "#0000ff40", part = "footer") |> # blue footer
  theme_box()
```

Notice that these new rows are subdivided into cells. For the footer, I've not merged anything so there are four cells in the footer row; whereas for the new header row there are only three cells because I merged two of them using the `colwidths` argument. 

If I were more serious about these particular tables, I'd use the `align()` function to tidy up the text alignment and other formatting in the new header and footer rows, but I'm not really interested in doing that here so I'll move on. 

## Row and column selectors

> &nbsp; &nbsp; He looked out through the open faceplate, and wiped a little sweat from his brow. It was dusk over the plateau. A few metres away, by the light of two moons and a fading sun, he could see the rimrock, frost-whitened. Beyond was the great gash in the desert which provided the setting for the ancient half-empty city where Tsoldrin Beychae now lived. <br>
> &nbsp; &nbsp; Clouds drifted, and the dust collected. <br>
> &nbsp; &nbsp; "Well," he sighed, to no-one in particular, and looked up into yet another alien sky. "Here we go again." <br>
> &nbsp; &nbsp; &nbsp; &nbsp; -- *Use of Weapons*

The `part` argument discussed in the previous section allows you to apply formatting rules selectively to the header, body, and footer of the table, but it doesn't let you apply rules selectively to a subset of rows or columns. If you need to do this, you can use the row selector argument `i` and the columns selector argument `j`. These selector arguments can be specified in three ways:

- Numerical values select rows or columns using their numerical index
- Character values can select one or more columns by name
- Formulas can be used to define a logical selection

It's a lot easier to understand when you see it in action. In this example, I use `i = 1:2` (selection by indices) to set the background colour for the top two rows to purple, and `i = ~ publication_date > 2000` (logical selection) to set the background colour for the bottom three rows to orange: 

```{r}
base |> 
  bg(i = 1:2, bg = "#cc22cc40") |>                    # purple rows
  bg(i = ~ publication_date > 2000, bg = "#ffa50040") # orange rows
```

Along the same lines the next example uses `j = 1:2` to set the background colour for the first two columns to brown, and `j = "isbn"` (selection by name) to set a teal background for the fourth column:

```{r}
base |> 
  bg(j = 1:2, bg = "#80471c40") |>  # brown columns
  bg(j = "isbn", bg = "#00808040")  # teal column
```

Notice that these background colours are applied only to the body of the table. However, the `bg()` function has a `part` argument, and we can extend this background shading to the entire table by settingh `part = "all"`":

```{r}
base |> 
  bg(j = 1:2, bg = "#80471c40", part = "all") |>  # brown columns
  bg(j = "isbn", bg = "#00808040", part = "all")  # teal column
```

If you specify a row selection and column selection, the formatting rule is applied to those cells that satisfy both criteria:

```{r}
base |> 
  bg(i = 1:2, j = 3:4, bg = "#cc22cc40") |>   # purple cells
  bg(i = 7:8, j = 1:2, bg = "#00808040")      # teal cells  
```

Note that formatting rules are applied sequentially, allowing you to override previously defined formatting. For example, in this example I set the top two rows to purple, then set the rightmost column to teal, and then finally set the bottom three rows to orange. The result looks like this:

```{r}
base |> 
  bg(i = 1:2, bg = "#cc22cc40") |>                    # purple rows
  bg(j = "isbn", bg = "#00808040") |>                 # teal column
  bg(i = ~ publication_date > 2000, bg = "#ffa50040") # orange rows
```

## Visual style

> And in her mind saw again the line of desert hills beyond the stone balustrade of the hotel room balcony, and the faint crease of dawn-light above, suddenly swamped by the stuttering pulses of silent fire from beyond the horizon. She had watched -- dazed and dazzled and wondering -- as that distant eruption of annihilation had lit up the face of her lover <br>
> &nbsp; &nbsp; &nbsp; &nbsp; -- *Against a Dark Background*

*Against a Dark Background* is not really a Culture novel, it's more of a standalone work with different premises. But consistency has never been much of a concern on this blog, and I'll quote what I want with merry abandon.

Controlling the appearance of the text:

- `font()`: Set font
- `fontsize()`: Set font size
- `italic()`: Set italic font
- `bold()`: Set bold font
- `color()`: Set font color
- `highlight()`: Text highlight color
- `rotate()`: Rotate cell text

Controlling alignment:

- `align()`: Set horizontal alignment 
- `align_text_col()`: Set horizontal alignment for text columns
- `align_nottext_col()`: Set horizontal alignment for non-text columns
- `valign()`: Set vertical alignment

Cell appearance:

- `bg()`: Set background color
- `padding()`: Set paragraph paddings
- `line_spacing()`: Set text alignment

Other:

- `style()`: Set flextable style
- `tab_settings()`: Set tabulation marks configuration
- `empty_blanks()`: Make blank columns as transparent 

```{r}
base |>
  bg(part = "header", bg = "grey30") |> 
  color(part = "header", color = "ghostwhite") |> 
  italic(j = "title")
```


## Borders

> The usual example given to illustrate an Outside Context Problem was imagining you were a tribe on a largish, fertile island; you'd tamed the land, invented the wheel or writing or whatever, the neighbours were cooperative or enslaved but at any rate peaceful and you were busy raising temples to yourself with all the excess productive capacity you had, you were in a position of near-absolute power and control which your hallowed ancestors could hardly have dreamed of and the whole situation was just running along nicely like a canoe on wet grass... when suddenly this bristling lump of iron appears sailless and trailing steam in the bay and these guys carrying long funny-looking sticks come ashore and announce you've just been discovered, you're all subjects of the Emperor now, he's keen on presents called tax and these bright-eyed holy men would like a word with your priests. <br>
> &nbsp; &nbsp; -- *Excession*


Horizontal and vertical lines:

- `hline()`: Set horizontal borders
- `hline_bottom()`: Set bottom horizontal border
- `hline_top()`: Set top horizontal border
- `vline()`: Set vertical borders
- `vline_left()`: Set left vertical borders
- `vline_right()`: Set right vertical borders

Borders:

- `border_inner()`: Set vertical and horizontal inner borders
- `border_inner_h()`: Set horizontal inner borders
- `border_inner_v()`: Set vertical inner borders
- `border_outer()`: Set outer borders
- `border_remove()`: Remove borders
- `surround()`: Set borders for a selection of cells 

Others:

- `fp_border_default()`: Border formatting properties
- `fix_border_issues()`: Fix border issues when cell are merged

```{r}
base |>
  vline(j = "title") |> 
  border_outer(
    border = fp_border_default(
      color = "black", 
      width = 2
    )
  )
```

## Cell contents

> "In all the human societies we have ever reviewed, in every age and every state, there has seldom if ever been a shortage of eager young males prepared to kill and die to preserve the security, comfort and prejudices of their elders, and what you call heroism is just an expression of this fact; there is never a scarcity of idiots." <br>
> &nbsp; &nbsp; -- *Use of Weapons*

Use `compose()` or `mk_par()` (the latter is an alias to make life easier in case of conficts between `purrr::compose()` and `flextable::compose()` to build cell contents from constituent parts:

```{r}
base |> 
  compose(
    j = "publication_date",
    value = as_paragraph(as.character(publication_date), " CE")
  )
```

Fancier formatting to a specific chunk using `as_chunk()` and `fp_text_default()`. Notice that `color()` here is just a convenience function. I could do the same thing using `compose()`, `as_paragraph()`, `as_chunk()`, and `fp_text_default()`:

```{r}
base |> 
  compose(
    i = ~ title == "Use of Weapons",
    j = "title",
    value = as_paragraph(as_chunk(
      title, 
      props = fp_text_default(color = "blue")
    ))
  ) |> 
  color(
    i = ~ title == "Surface Detail",
    j = "title",
    color = "red" 
  )
```

## Merging cells

> Oh, they never lie. They dissemble, evade, prevaricate, confound, confuse, distract, obscure, subtly misrepresent and willfully misunderstand with what often appears to be a positively gleeful relish and are generally perfectly capable of contriving to give one an utterly unambiguous impression of their future course of action while in fact intending to do exactly the opposite, but they never lie. Perish the thought. <br>
> &nbsp; &nbsp; -- *Look to Windward*

To construct the data for the table I put together a data set containing a [list of ships](https://theculture.fandom.com/wiki/List_of_spacecraft) that are referred to in the Culture novels. I'll use that to count the number of ships from each civilisation in each of the novels:

```{r}
ships <- read_csv("ship-list.csv", show_col_types = FALSE)

ship_count <- ships |> 
  mutate(Civilisation = case_when(
    str_detect(Civilisation, "^Culture ") ~ "Culture",
    str_detect(Civilisation, "^Non-aligned ") ~ "Non-aligned",
    TRUE ~ Civilisation
  )) |> 
  group_by(Novel, Civilisation) |>
  count(name = "Ships") |> 
  ungroup() |> 
  arrange(Novel, desc(Ships))

ship_count
```

```{r}
ship_count |> 
  flextable() |> 
  autofit() |> 
  theme_box()
```

```{r}
ship_count |> 
  flextable() |> 
  autofit() |> 
  merge_v(j = "Novel") |> 
  theme_box()
```

```{r}
ship_count |> 
  as_grouped_data(groups = "Novel") |> 
  flextable() |> 
  autofit()
```

## Markdown columns

> The point is, there is no feasible excuse for what are, for what we have made of ourselves. We have chosen to put profits before people, money before morality, dividends before decency, fanaticism before fairness, and our own trivial comforts before the unspeakable agonies of others <br>
> &nbsp; &nbsp; -- *Complicity*

Flextable doesn't natively support markdown syntax in data columns, but the [ftExtra](https://ftextra.atusy.net/) package provides this.

```{r}
novels |> 
  mutate(title = paste0("[", title, "](", url, ")")) |> 
  select(title, description) |> 
  flextable(col_keys = c("title", "description")) |> 
  set_header_labels(
    title = "Book Title",
    description = "Description"
  ) |> 
  colformat_md(j = "title") |> 
  autofit()
```

## Inserting equations

> Allegedly there was some extra set of coordinates, or even a single mathematical operation, a transform, which, when applied to any given set of coordinates in the original list, somehow magically derived the exact position of that system's portal.<br>
> &nbsp; &nbsp; -- *The Algebraist*

Again, not a Culture novel, but a standalone science fiction work by Banks. But it seems appropriate to quote from it given the topic of the section.

Markdown columns are a very handy tool whenever you have tables that need to include equations or other kinds of cell content that have very specific formatting requirements. 

```{r}
tbl <- tribble(
  ~expression,                  ~text,
  "x^2^ + y^2^ = 1",            "Formula for the unit circle",
  "**x** = (x~1~, ..., x~n~)" , "A vector of length n"
)
tbl
```

```{r}
tbl |> 
  flextable() |> 
  colformat_md(j = "expression") |> 
  autofit()
```

Math support:

```{r}
tbl <- tribble(
  ~expression,                       ~text,
  "$x^2 + y^2 = 1$",                 "Formula for the unit circle",
  "$\\bm{x} = (x_1, \\ldots, x_n)$", "A vector of length $n$",
  "$\\mathcal{R}^n$",                 "$n$-dimensional real space",
  "$e^{i\\pi} + 1 = 0$",             "Euler's identity^[A special case of Euler's formula]"
)
tbl
```

```{r}
tbl |> 
  flextable() |> 
  colformat_md() |> 
  autofit()
```

## Inserting images

> That was how divorced from the human scale modern warfare had become. You could smash and destroy from unthinkable distances, obliterate planets from beyond their own system and provoke stars into novae from light-years off...and still have no good idea why you were really fighting. <br>
> &nbsp; &nbsp; -- *Consider Phlebas*

```{r}
novels |> 
  mutate(title = paste0("[", title, "](", url, ")")) |> 
  select(title, image, description) |> 
  flextable(col_keys = c("title", "image", "description")) |> 
  set_header_labels(
    title = "Book Title",
    description = "Description",
    image = "Cover"
  ) |> 
  colformat_md(j = "title") |> 
  colformat_image(j = "image", width = .75, height = 1.2) |> 
  autofit()
```

## Inserting plots

> People were always sorry. Sorry they had done what they had done, sorry they were doing what they were doing, sorry they were going to do what they were going to do; but they still did whatever it is. The sorrow never stopped them; it just made them feel better. And so the sorrow never stopped. <br>
> &nbsp; &nbsp; -- *Against a Dark Background*

```{r}
plot_name_lengths <- function(novel) {
  ships |> 
    filter(Novel == novel) |> 
    mutate(len = Name |> replace_na("") |> nchar()) |> 
    arrange(desc(len)) |> 
    mutate(pos = row_number()) |> 
    ggplot(aes(pos, len)) + 
    geom_point() + 
    geom_segment(aes(xend = pos, yend = 0)) + 
    lims(x = c(0, 60), y = c(0, 65)) + 
    theme_void()
}

ship_name_length <- tibble(
  title = novels$title,
  plot = lapply(title, plot_name_lengths)
)

ship_name_length
```

```{r}
ship_name_length |> 
  flextable(cwidth = c(2, 4)) |> 
  set_header_labels(
    title = "Title", 
    plot = "Ship Name Lengths"
  ) |> 
  compose(
    j = "plot", 
    value = as_paragraph(
      gg_chunk(value = plot, width = 6, height = .8)
    )
  ) |> 
  align_nottext_col(align = "center")
```


## Epilogue

> Just as one might do useful work without fully understanding the job one was engaged in, or even what the point of it was, so the behaviour of devotion still mattered to the all-forgiving God, and just as the habitual performance of a task gradually raised one’s skills to something close to perfection, bringing a deeper understanding of the work, so the actions of faith would lead to the state of faith. <br>
> &nbsp; &nbsp; -- *Surface Detail*
