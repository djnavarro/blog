---
title: "Use of flextable"
description: "This is a subtitle"
date: "2024-07-04"
image: "img/swatch.png"
image-alt: "A table of four horizontal textured bands in pastel shades"
categories: ["R", "Data Wrangling"]
--- 

<!--------------- my typical setup ----------------->

```{r}
#| label: setup
#| include: false
very_wide <- 500
wide <- 136
narrow <- 76
options(width = narrow)
cache_images <- TRUE
set.seed(1)
```

<!--------------- post begins here ----------------->


```{r}
#| message: false
library(flextable)
library(ftExtra)
library(tibble)
library(stringr)
library(dplyr)
library(tidyr)
library(readr)
library(ggplot2)
```

- [flextable package](https://davidgohel.github.io/flextable/)
- [flextable book](https://ardata-fr.github.io/flextable-book/)

- [list of spacecraft](https://theculture.fandom.com/wiki/List_of_spacecraft)

## Basic use

There are nine books that make up the Culture novels, starting with the 1988 novel *Consider Phlebas* and finishing with *The Hydrogen Sonata* in 2012. For the purposes of this post I put together a small data set using information taken from the [wikipedia page](https://en.wikipedia.org/wiki/Culture_series) on the Culture novels:

```{r}
novels <- read_csv("culture.csv", show_col_types = FALSE)
novels
```

To construct a table using a subset of these columns, we can use the `flextable()` function. In the simplest case, we pass a data fram to `flextable()` and we get an HTML table as output:


```{r}
novels %>%
  select(title:isbn) %>% 
  flextable()
```

This is a promising beginning, but it can be improved in any number of ways.

## Column widths

The most obvious shortcoming is the column widths, which we can adjust manually by passing a vector of widths (in inches) as the `cwidth` argument to `flextable()`:

```{r}
novels %>%
  select(title:isbn) %>% 
  flextable(cwidth = c(3, 1, 4, 2))
```

There are situations where this manual control is helpful, but often you can avoid the tedious tinkering to get the widths right simply by using `autofit()` to select nice column widths:

```{r}
novels %>%
  select(title:isbn) %>% 
  flextable() %>% 
  autofit()
```

## Column labels

Now that we have better-spaced columns, the thing that pops out at us next is the column headers. We can do better than using variable names as column headers. To do so we can use `set_header_labels()`, which takes name-value pairs as inputs, like this:

```{r}
novels %>%
  select(title:isbn) %>% 
  flextable(cwidth = c(3, 1, 4, 2)) %>% 
  set_header_labels(
    title = "Book Title",
    publication_date = "Published",
    setting_date = "Story Date", 
    isbn = "ISBN"
  )
```

## Column formats

```{r}
novels %>%
  mutate(publication_date = as.integer(publication_date)) %>% 
  select(title:isbn) %>% 
  flextable(cwidth = c(3, 1, 4, 2)) %>% 
  set_header_labels(
    title = "Book Title",
    publication_date = "Published",
    setting_date = "Story Date", 
    isbn = "ISBN"
  ) %>% 
  colformat_int(big.mark = "")
```

I'll store this as the `base` table to be modified later:

```{r}
base <- novels %>%
  mutate(publication_date = as.integer(publication_date)) %>% 
  select(title:isbn) %>% 
  flextable(cwidth = c(3, 1, 4, 2)) %>% 
  set_header_labels(
    title = "Book Title",
    publication_date = "Published",
    setting_date = "Story Date", 
    isbn = "ISBN"
  ) %>% 
  colformat_int(big.mark = "")
```

## Table themes

Theme functions are simpler than ggplot2. It's a function that takes a flextable as input and returns a flextable as ouput. Default is `theme_booktabs()` but there are several that come bundled with the package:

```{r}
base %>% theme_box()
```

```{r}
base %>% theme_alafoli()
```

```{r}
base %>% theme_tron()
```

## Table defaults

At the time a table is constructed by calling `flextable()` a collection of default values are applied to the table. You can get a list of these valuse by calling `get_flextable_defaults()`, and you can modify them with `set_flextable_defaults()`

```{r}
set_flextable_defaults(
  font.color = "purple",
  background.color = "ghostwhite",
  table.layout = "autofit"
)

novels %>% 
  select(title:isbn) %>% 
  flextable()
```

These defaults are applied to any new table, which I don't want. So I'll restore defaults to their original values:

```{r}
init_flextable_defaults()
```

## Table parts

It's often helpful to define formatting rules that apply only to a subset of the table. For instance, we might want to use boldface text for the column headers but not the body of the table. Or perhaps some rows or columns should appear in a different colour for one reason or another. To do this effectively it is helpful to understand how flextables are structured. All flextables are comprised of three parts: a set of **header** rows at the top, a grid of cells in the table **body**, and a set of footer rows at the bottom. Many functions in flextable have a `part` argument that you can use to select one (or all) of these three parts. For example, the `bg()` function is used to set the background colour, and the example below takes our `base` table and gives the header a red background, the body a green background, and the footer a blue background:

```{r}
base %>% 
  bg(bg = "#ff000040", part = "header") %>% # red header
  bg(bg = "#00cc0040", part = "body") %>%   # green body
  bg(bg = "#0000ff40", part = "footer") %>% # blue footer
  theme_box()
```

As you can see from this output, the default in flextable is to have a single header row containing the column names, a body comprised of the data values in the table, and no footer at all. We can add extra content to the header and footer if we want using the `add_header_lines()` and `add_footer_lines()` functions:

```{r}
base %>%
  add_header_lines("The Culture Novels") %>% 
  add_footer_lines("by Iain M. Banks") %>% 
  bg(bg = "#ff000040", part = "header") %>% # red header
  bg(bg = "#00cc0040", part = "body") %>%   # green body
  bg(bg = "#0000ff40", part = "footer") %>% # blue footer
  theme_box()
```

Notice that the `add_header_lines()` and `add_footer_lines()` functions create extra rows that span all the cells in the table. Sometimes we might prefer a little more fine-grained control, by creating a new row that is subdivided into cells. We can do this with the `add_header_row()` and `add_footer_row()` functions:

```{r}
base %>%
  add_header_row(
    values = c("A", "Header", "Row"), 
    colwidths = c(1, 2, 1)
  ) %>% 
  add_footer_row(
    values = c("And", "A", "Footer", "Row"), 
    colwidths = c(1, 1, 1, 1)
  ) %>% 
  bg(bg = "#ff000040", part = "header") %>% # red header
  bg(bg = "#00cc0040", part = "body") %>%   # green body
  bg(bg = "#0000ff40", part = "footer") %>% # blue footer
  theme_box()
```

Notice that these new rows are subdivided into cells. For the footer, I've not merged anything so there are four cells in the footer row; whereas for the new header row there are only three cells because I merged two of them using the `colwidths` argument. 

If I were more serious about these particular tables, I'd use the `align()` function to tidy up the text alignment and other formatting in the new header and footer rows, but I'm not really interested in doing that here so I'll move on. 

## Row and column selectors

```{r}
base %>% 
  bg(i = 1:2, bg = "#cc22cc40") %>%                   # purple rows
  bg(i = ~ publication_date > 2000, bg = "#ffa50040") # orange rows
```

```{r}
base %>% 
  bg(j = 1:2, bg = "#80471c40") %>% # brown columns
  bg(j = "isbn", bg = "#00808040")  # teal column
```


```{r}
base %>% 
  bg(j = 1:2, bg = "#80471c40", part = "all") %>% # brown columns
  bg(j = "isbn", bg = "#00808040", part = "all")  # teal column
```

```{r}
base %>% 
  bg(i = 1:2, j = 3:4, bg = "#cc22cc40") %>%  # purple cells
  bg(i = 7:8, j = 1:2, bg = "#00808040")      # teal cells  
```

```{r}
base %>% 
  bg(i = 1:2, bg = "#cc22cc40") %>%                   # purple rows
  bg(j = "isbn", bg = "#00808040") %>%                # teal column
  bg(i = ~ publication_date > 2000, bg = "#ffa50040") # orange rows
```

## Tinkering

```{r}
base %>%
  bg(part = "header", bg = "grey50") %>% 
  color(part = "header", color = "ghostwhite") %>% 
  italic(j = "title", part = "all") %>% 
  vline(j = "title") %>% 
  border_outer(
    border = fp_border_default(
      color = "black", 
      width = 2
    )
  )
```

## Cell contents

Use `compose()` or `mk_par()` (the latter is an alias to make life easier in case of conficts between `purrr::compose()` and `flextable::compose()` to build cell contents from constituent parts:

```{r}
base %>% 
  compose(
    j = "publication_date",
    value = as_paragraph(as.character(publication_date), " CE")
  )
```

Fancier formatting to a specific chunk using `as_chunk()` and `fp_text_default()`. Notice that `color()` here is just a convenience function. I could do the same thing using `compose()`, `as_paragraph()`, `as_chunk()`, and `fp_text_default()`:

```{r}
base %>% 
  compose(
    i = ~ title == "Use of Weapons",
    j = "title",
    value = as_paragraph(as_chunk(
      title, 
      props = fp_text_default(color = "blue")
    ))
  ) %>% 
  color(
    i = ~ title == "Surface Detail",
    j = "title",
    color = "red" 
  )
```

## Merging cells

Data for the table:

```{r}
ships <- read_csv("ship-list.csv", show_col_types = FALSE)

ship_count <- ships %>% 
  mutate(Civilisation = case_when(
    str_detect(Civilisation, "^Culture ") ~ "Culture",
    str_detect(Civilisation, "^Non-aligned ") ~ "Non-aligned",
    TRUE ~ Civilisation
  )) %>% 
  group_by(Novel, Civilisation) %>%
  count(name = "Ships") %>% 
  ungroup() %>% 
  arrange(Novel, desc(Ships))

ship_count
```

```{r}
ship_count %>% 
  flextable() %>% 
  autofit() %>% 
  theme_box()
```

```{r}
ship_count %>% 
  flextable() %>% 
  autofit() %>% 
  merge_v(j = "Novel") %>% 
  theme_box()
```

```{r}
ship_count %>% 
  as_grouped_data(groups = "Novel") %>% 
  flextable() %>% 
  autofit()
```

## Markdown columns

Flextable doesn't natively support markdown syntax in data columns, but the [ftExtra](https://ftextra.atusy.net/) package provides this.

```{r}
novels %>% 
  mutate(title = paste0("[", title, "](", url, ")")) %>% 
  select(title, description) %>% 
  flextable(col_keys = c("title", "description")) %>% 
  set_header_labels(
    title = "Book Title",
    description = "Description"
  ) %>% 
  colformat_md(j = "title") %>% 
  autofit()
```

## Inserting equations

Markdown columns are a very handy tool whenever you have tables that need to include equations or other kinds of cell content that have very specific formatting requirements. 

```{r}
tbl <- tribble(
  ~expression,                  ~text,
  "x^2^ + y^2^ = 1",            "Formula for the unit circle",
  "**x** = (x~1~, ..., x~n~)" , "A vector of length n"
)
tbl
```

```{r}
tbl %>% 
  flextable() %>% 
  colformat_md(j = "expression") %>% 
  autofit()
```

Math support:

```{r}
tbl <- tribble(
  ~expression,                       ~text,
  "$x^2 + y^2 = 1$",                 "Formula for the unit circle",
  "$\\bm{x} = (x_1, \\ldots, x_n)$", "A vector of length $n$",
  "$\\mathcal{R}^n$",                 "$n$-dimensional real space",
  "$e^{i\\pi} + 1 = 0$",             "Euler's identity^[A special case of Euler's formula]"
)
tbl
```

```{r}
tbl %>% 
  flextable() %>% 
  colformat_md() %>% 
  autofit()
```

## Inserting images

```{r}
novels %>% 
  mutate(title = paste0("[", title, "](", url, ")")) %>% 
  select(title, image, description) %>% 
  flextable(col_keys = c("title", "image", "description")) %>% 
  set_header_labels(
    title = "Book Title",
    description = "Description",
    image = "Cover"
  ) %>% 
  colformat_md(j = "title") %>% 
  colformat_image(j = "image", width = .75, height = 1.2) %>% 
  autofit()
```

## Inserting plots

```{r}
swatch <- function(seed, n = 2000) {
  set.seed(seed)
  ggplot(
    data = tibble(
      x = runif(n, -4, 3), 
      y = runif(n),
      len = runif(n), 
      shade = runif(n)
    ), 
    mapping = aes(
      x = x, 
      y = y, 
      xend = x + len,
      yend = y,
      color = shade
    )
  ) + 
    geom_segment(show.legend = FALSE, alpha = .5, linetype = "dotted") + 
    coord_cartesian(xlim = c(-3, 3)) + 
    scale_color_gradientn(colors = sample(colors(), size = 3)) + 
    theme_void()
}

df <- tibble(
  seed = 100:108,
  plot = lapply(seed, swatch)
)

df
```

```{r}
flextable(df) %>% 
  set_header_labels(seed = "Seed", plot = "Swatch") %>% 
  compose(
    j = "plot", 
    value = as_paragraph(
      gg_chunk(value = plot, width = 4, height = .8)
    )
  ) %>% 
  autofit()
```
